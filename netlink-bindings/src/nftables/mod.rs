#![doc = "Netfilter nftables configuration over netlink."]
#![allow(clippy::all)]
#![allow(unused_imports)]
#![allow(unused_assignments)]
#![allow(non_snake_case)]
#![allow(unused_variables)]
#![allow(irrefutable_let_patterns)]
#![allow(unreachable_code)]
#![allow(unreachable_patterns)]
use crate::builtin::{PushBuiltinBitfield32, PushBuiltinNfgenmsg};
use crate::consts;
use crate::utils::*;
use crate::{NetlinkRequest, Protocol};
pub const PROTONAME: &CStr = c"nftables";
pub const PROTONUM: u16 = 12u16;
#[doc = "Original name: \"meta-keys\" (enum) - defines an integer enumeration, with values for each entry incrementing by 1, (e.g. 0, 1, 2, 3)"]
#[derive(Debug, Clone, Copy)]
pub enum MetaKeys {
    Len = 0,
    Protocol = 1,
    Priority = 2,
    Mark = 3,
    Iif = 4,
    Oif = 5,
    Iifname = 6,
    Oifname = 7,
    Iftype = 8,
    Oiftype = 9,
    Skuid = 10,
    Skgid = 11,
    Nftrace = 12,
    Rtclassid = 13,
    Secmark = 14,
    Nfproto = 15,
    L4Proto = 16,
    BriIifname = 17,
    BriOifname = 18,
    Pkttype = 19,
    Cpu = 20,
    Iifgroup = 21,
    Oifgroup = 22,
    Cgroup = 23,
    Prandom = 24,
    Secpath = 25,
    Iifkind = 26,
    Oifkind = 27,
    BriIifpvid = 28,
    BriIifvproto = 29,
    TimeNs = 30,
    TimeDay = 31,
    TimeHour = 32,
    Sdif = 33,
    Sdifname = 34,
    BriBroute = 35,
}
impl MetaKeys {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            0 => Self::Len,
            1 => Self::Protocol,
            2 => Self::Priority,
            3 => Self::Mark,
            4 => Self::Iif,
            5 => Self::Oif,
            6 => Self::Iifname,
            7 => Self::Oifname,
            8 => Self::Iftype,
            9 => Self::Oiftype,
            10 => Self::Skuid,
            11 => Self::Skgid,
            12 => Self::Nftrace,
            13 => Self::Rtclassid,
            14 => Self::Secmark,
            15 => Self::Nfproto,
            16 => Self::L4Proto,
            17 => Self::BriIifname,
            18 => Self::BriOifname,
            19 => Self::Pkttype,
            20 => Self::Cpu,
            21 => Self::Iifgroup,
            22 => Self::Oifgroup,
            23 => Self::Cgroup,
            24 => Self::Prandom,
            25 => Self::Secpath,
            26 => Self::Iifkind,
            27 => Self::Oifkind,
            28 => Self::BriIifpvid,
            29 => Self::BriIifvproto,
            30 => Self::TimeNs,
            31 => Self::TimeDay,
            32 => Self::TimeHour,
            33 => Self::Sdif,
            34 => Self::Sdifname,
            35 => Self::BriBroute,
            _ => return None,
        })
    }
}
#[doc = "Original name: \"bitwise-ops\" (enum) - defines an integer enumeration, with values for each entry incrementing by 1, (e.g. 0, 1, 2, 3)"]
#[derive(Debug, Clone, Copy)]
pub enum BitwiseOps {
    #[doc = "mask-and-xor operation used to implement NOT, AND, OR and XOR boolean operations\n  dreg = (sreg & mask) ^ xor\nwith these mask and xor values:\n          mask    xor\n  NOT:    1       1\n  OR:     ~x      x\n  XOR:    1       x\n  AND:    x       0\n"]
    MaskXor = 0,
    Lshift = 1,
    Rshift = 2,
    And = 3,
    Or = 4,
    Xor = 5,
}
impl BitwiseOps {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            0 => Self::MaskXor,
            1 => Self::Lshift,
            2 => Self::Rshift,
            3 => Self::And,
            4 => Self::Or,
            5 => Self::Xor,
            _ => return None,
        })
    }
}
#[doc = "Original name: \"cmp-ops\" (enum) - defines an integer enumeration, with values for each entry incrementing by 1, (e.g. 0, 1, 2, 3)"]
#[derive(Debug, Clone, Copy)]
pub enum CmpOps {
    Eq = 0,
    Neq = 1,
    Lt = 2,
    Lte = 3,
    Gt = 4,
    Gte = 5,
}
impl CmpOps {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            0 => Self::Eq,
            1 => Self::Neq,
            2 => Self::Lt,
            3 => Self::Lte,
            4 => Self::Gt,
            5 => Self::Gte,
            _ => return None,
        })
    }
}
#[doc = "Original name: \"object-type\" (enum) - defines an integer enumeration, with values for each entry incrementing by 1, (e.g. 0, 1, 2, 3)"]
#[derive(Debug, Clone, Copy)]
pub enum ObjectType {
    Unspec = 0,
    Counter = 1,
    Quota = 2,
    CtHelper = 3,
    Limit = 4,
    Connlimit = 5,
    Tunnel = 6,
    CtTimeout = 7,
    Secmark = 8,
    CtExpect = 9,
    Synproxy = 10,
}
impl ObjectType {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            0 => Self::Unspec,
            1 => Self::Counter,
            2 => Self::Quota,
            3 => Self::CtHelper,
            4 => Self::Limit,
            5 => Self::Connlimit,
            6 => Self::Tunnel,
            7 => Self::CtTimeout,
            8 => Self::Secmark,
            9 => Self::CtExpect,
            10 => Self::Synproxy,
            _ => return None,
        })
    }
}
#[doc = "Original name: \"nat-range-flags\" (flags) - defines an integer enumeration, with values for each entry occupying a bit, starting from bit 0, (e.g. 1, 2, 4, 8)"]
#[derive(Debug, Clone, Copy)]
pub enum NatRangeFlags {
    MapIps = 1 << 0,
    ProtoSpecified = 1 << 1,
    ProtoRandom = 1 << 2,
    Persistent = 1 << 3,
    ProtoRandomFully = 1 << 4,
    ProtoOffset = 1 << 5,
    Netmap = 1 << 6,
}
impl NatRangeFlags {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            n if n == 1 << 0 => Self::MapIps,
            n if n == 1 << 1 => Self::ProtoSpecified,
            n if n == 1 << 2 => Self::ProtoRandom,
            n if n == 1 << 3 => Self::Persistent,
            n if n == 1 << 4 => Self::ProtoRandomFully,
            n if n == 1 << 5 => Self::ProtoOffset,
            n if n == 1 << 6 => Self::Netmap,
            _ => return None,
        })
    }
}
#[doc = "Original name: \"table-flags\" (flags) - defines an integer enumeration, with values for each entry occupying a bit, starting from bit 0, (e.g. 1, 2, 4, 8)"]
#[derive(Debug, Clone, Copy)]
pub enum TableFlags {
    Dormant = 1 << 0,
    Owner = 1 << 1,
    Persist = 1 << 2,
}
impl TableFlags {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            n if n == 1 << 0 => Self::Dormant,
            n if n == 1 << 1 => Self::Owner,
            n if n == 1 << 2 => Self::Persist,
            _ => return None,
        })
    }
}
#[doc = "Original name: \"chain-flags\" (flags) - defines an integer enumeration, with values for each entry occupying a bit, starting from bit 0, (e.g. 1, 2, 4, 8)"]
#[derive(Debug, Clone, Copy)]
pub enum ChainFlags {
    Base = 1 << 0,
    HwOffload = 1 << 1,
    Binding = 1 << 2,
}
impl ChainFlags {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            n if n == 1 << 0 => Self::Base,
            n if n == 1 << 1 => Self::HwOffload,
            n if n == 1 << 2 => Self::Binding,
            _ => return None,
        })
    }
}
#[doc = "Original name: \"set-flags\" (flags) - defines an integer enumeration, with values for each entry occupying a bit, starting from bit 0, (e.g. 1, 2, 4, 8)"]
#[derive(Debug, Clone, Copy)]
pub enum SetFlags {
    Anonymous = 1 << 0,
    Constant = 1 << 1,
    Interval = 1 << 2,
    Map = 1 << 3,
    Timeout = 1 << 4,
    Eval = 1 << 5,
    Object = 1 << 6,
    Concat = 1 << 7,
    Expr = 1 << 8,
}
impl SetFlags {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            n if n == 1 << 0 => Self::Anonymous,
            n if n == 1 << 1 => Self::Constant,
            n if n == 1 << 2 => Self::Interval,
            n if n == 1 << 3 => Self::Map,
            n if n == 1 << 4 => Self::Timeout,
            n if n == 1 << 5 => Self::Eval,
            n if n == 1 << 6 => Self::Object,
            n if n == 1 << 7 => Self::Concat,
            n if n == 1 << 8 => Self::Expr,
            _ => return None,
        })
    }
}
#[doc = "Original name: \"lookup-flags\" (flags) - defines an integer enumeration, with values for each entry occupying a bit, starting from bit 0, (e.g. 1, 2, 4, 8)"]
#[derive(Debug, Clone, Copy)]
pub enum LookupFlags {
    Invert = 1 << 0,
}
impl LookupFlags {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            n if n == 1 << 0 => Self::Invert,
            _ => return None,
        })
    }
}
#[doc = "Original name: \"ct-keys\" (enum) - defines an integer enumeration, with values for each entry incrementing by 1, (e.g. 0, 1, 2, 3)"]
#[derive(Debug, Clone, Copy)]
pub enum CtKeys {
    State = 0,
    Direction = 1,
    Status = 2,
    Mark = 3,
    Secmark = 4,
    Expiration = 5,
    Helper = 6,
    L3protocol = 7,
    Src = 8,
    Dst = 9,
    Protocol = 10,
    ProtoSrc = 11,
    ProtoDst = 12,
    Labels = 13,
    Pkts = 14,
    Bytes = 15,
    Avgpkt = 16,
    Zone = 17,
    Eventmask = 18,
    SrcIp = 19,
    DstIp = 20,
    SrcIp6 = 21,
    DstIp6 = 22,
    CtId = 23,
}
impl CtKeys {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            0 => Self::State,
            1 => Self::Direction,
            2 => Self::Status,
            3 => Self::Mark,
            4 => Self::Secmark,
            5 => Self::Expiration,
            6 => Self::Helper,
            7 => Self::L3protocol,
            8 => Self::Src,
            9 => Self::Dst,
            10 => Self::Protocol,
            11 => Self::ProtoSrc,
            12 => Self::ProtoDst,
            13 => Self::Labels,
            14 => Self::Pkts,
            15 => Self::Bytes,
            16 => Self::Avgpkt,
            17 => Self::Zone,
            18 => Self::Eventmask,
            19 => Self::SrcIp,
            20 => Self::DstIp,
            21 => Self::SrcIp6,
            22 => Self::DstIp6,
            23 => Self::CtId,
            _ => return None,
        })
    }
}
#[doc = "Original name: \"ct-direction\" (enum) - defines an integer enumeration, with values for each entry incrementing by 1, (e.g. 0, 1, 2, 3)"]
#[derive(Debug, Clone, Copy)]
pub enum CtDirection {
    Original = 0,
    Reply = 1,
}
impl CtDirection {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            0 => Self::Original,
            1 => Self::Reply,
            _ => return None,
        })
    }
}
#[doc = "Original name: \"quota-flags\" (flags) - defines an integer enumeration, with values for each entry occupying a bit, starting from bit 0, (e.g. 1, 2, 4, 8)"]
#[derive(Debug, Clone, Copy)]
pub enum QuotaFlags {
    Invert = 1 << 0,
    Depleted = 1 << 1,
}
impl QuotaFlags {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            n if n == 1 << 0 => Self::Invert,
            n if n == 1 << 1 => Self::Depleted,
            _ => return None,
        })
    }
}
#[doc = "Original name: \"verdict-code\" (enum) - defines an integer enumeration, with values for each entry incrementing by 1, (e.g. 0, 1, 2, 3)"]
#[derive(Debug, Clone, Copy)]
pub enum VerdictCode {
    Continue = 4294967295,
    Break = 4294967294,
    Jump = 4294967293,
    Goto = 4294967292,
    Return = 4294967291,
    Drop = 0,
    Accept = 1,
    Stolen = 2,
    Queue = 3,
    Repeat = 4,
}
impl VerdictCode {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            4294967295 => Self::Continue,
            4294967294 => Self::Break,
            4294967293 => Self::Jump,
            4294967292 => Self::Goto,
            4294967291 => Self::Return,
            0 => Self::Drop,
            1 => Self::Accept,
            2 => Self::Stolen,
            3 => Self::Queue,
            4 => Self::Repeat,
            _ => return None,
        })
    }
}
#[doc = "Original name: \"fib-result\" (enum) - defines an integer enumeration, with values for each entry incrementing by 1, (e.g. 0, 1, 2, 3)"]
#[derive(Debug, Clone, Copy)]
pub enum FibResult {
    Oif = 0,
    Oifname = 1,
    Addrtype = 2,
}
impl FibResult {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            0 => Self::Oif,
            1 => Self::Oifname,
            2 => Self::Addrtype,
            _ => return None,
        })
    }
}
#[doc = "Original name: \"fib-flags\" (flags) - defines an integer enumeration, with values for each entry occupying a bit, starting from bit 0, (e.g. 1, 2, 4, 8)"]
#[derive(Debug, Clone, Copy)]
pub enum FibFlags {
    Saddr = 1 << 0,
    Daddr = 1 << 1,
    Mark = 1 << 2,
    Iif = 1 << 3,
    Oif = 1 << 4,
    Present = 1 << 5,
}
impl FibFlags {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            n if n == 1 << 0 => Self::Saddr,
            n if n == 1 << 1 => Self::Daddr,
            n if n == 1 << 2 => Self::Mark,
            n if n == 1 << 3 => Self::Iif,
            n if n == 1 << 4 => Self::Oif,
            n if n == 1 << 5 => Self::Present,
            _ => return None,
        })
    }
}
#[doc = "Original name: \"reject-types\" (enum) - defines an integer enumeration, with values for each entry incrementing by 1, (e.g. 0, 1, 2, 3)"]
#[derive(Debug, Clone, Copy)]
pub enum RejectTypes {
    IcmpUnreach = 0,
    TcpRst = 1,
    IcmpxUnreach = 2,
}
impl RejectTypes {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            0 => Self::IcmpUnreach,
            1 => Self::TcpRst,
            2 => Self::IcmpxUnreach,
            _ => return None,
        })
    }
}
#[doc = "Original name: \"payload-base\" (enum) - defines an integer enumeration, with values for each entry incrementing by 1, (e.g. 0, 1, 2, 3)"]
#[derive(Debug, Clone, Copy)]
pub enum PayloadBase {
    LinkLayerHeader = 0,
    NetworkHeader = 1,
    TransportHeader = 2,
    InnerHeader = 3,
    TunHeader = 4,
}
impl PayloadBase {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            0 => Self::LinkLayerHeader,
            1 => Self::NetworkHeader,
            2 => Self::TransportHeader,
            3 => Self::InnerHeader,
            4 => Self::TunHeader,
            _ => return None,
        })
    }
}
#[doc = "Range operator"]
#[doc = "Original name: \"range-ops\" (enum) - defines an integer enumeration, with values for each entry incrementing by 1, (e.g. 0, 1, 2, 3)"]
#[derive(Debug, Clone, Copy)]
pub enum RangeOps {
    Eq = 0,
    Neq = 1,
}
impl RangeOps {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            0 => Self::Eq,
            1 => Self::Neq,
            _ => return None,
        })
    }
}
#[doc = "nf_tables registers.\nnf_tables used to have five registers: a verdict register and four data\nregisters of size 16. The data registers have been changed to 16 registers\nof size 4. For compatibility reasons, the NFT_REG_[1-4] registers still\nmap to areas of size 16, the 4 byte registers are addressed using\nNFT_REG32_00 - NFT_REG32_15.\n"]
#[doc = "Original name: \"registers\" (enum) - defines an integer enumeration, with values for each entry incrementing by 1, (e.g. 0, 1, 2, 3)"]
#[derive(Debug, Clone, Copy)]
pub enum Registers {
    RegVerdict = 0,
    Reg1 = 1,
    Reg2 = 2,
    Reg3 = 3,
    Reg4 = 4,
    Reg3200 = 8,
    Reg3201 = 9,
    Reg3202 = 10,
    Reg3203 = 11,
    Reg3204 = 12,
    Reg3205 = 13,
    Reg3206 = 14,
    Reg3207 = 15,
    Reg3208 = 16,
    Reg3209 = 17,
    Reg3210 = 18,
    Reg3211 = 19,
    Reg3212 = 20,
    Reg3213 = 21,
    Reg3214 = 22,
    Reg3215 = 23,
}
impl Registers {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            0 => Self::RegVerdict,
            1 => Self::Reg1,
            2 => Self::Reg2,
            3 => Self::Reg3,
            4 => Self::Reg4,
            8 => Self::Reg3200,
            9 => Self::Reg3201,
            10 => Self::Reg3202,
            11 => Self::Reg3203,
            12 => Self::Reg3204,
            13 => Self::Reg3205,
            14 => Self::Reg3206,
            15 => Self::Reg3207,
            16 => Self::Reg3208,
            17 => Self::Reg3209,
            18 => Self::Reg3210,
            19 => Self::Reg3211,
            20 => Self::Reg3212,
            21 => Self::Reg3213,
            22 => Self::Reg3214,
            23 => Self::Reg3215,
            _ => return None,
        })
    }
}
#[doc = "Original name: \"numgen-types\" (enum) - defines an integer enumeration, with values for each entry incrementing by 1, (e.g. 0, 1, 2, 3)"]
#[derive(Debug, Clone, Copy)]
pub enum NumgenTypes {
    Incremental = 0,
    Random = 1,
}
impl NumgenTypes {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            0 => Self::Incremental,
            1 => Self::Random,
            _ => return None,
        })
    }
}
#[doc = "nf_tables log levels"]
#[doc = "Original name: \"log-level\" (enum) - defines an integer enumeration, with values for each entry incrementing by 1, (e.g. 0, 1, 2, 3)"]
#[derive(Debug, Clone, Copy)]
pub enum LogLevel {
    #[doc = "system is unusable"]
    Emerg = 0,
    #[doc = "action must be taken immediately"]
    Alert = 1,
    #[doc = "critical conditions"]
    Crit = 2,
    #[doc = "error conditions"]
    Err = 3,
    #[doc = "warning conditions"]
    Warning = 4,
    #[doc = "normal but significant condition"]
    Notice = 5,
    #[doc = "informational"]
    Info = 6,
    #[doc = "debug-level messages"]
    Debug = 7,
    #[doc = "enabling audit logging"]
    Audit = 8,
}
impl LogLevel {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            0 => Self::Emerg,
            1 => Self::Alert,
            2 => Self::Crit,
            3 => Self::Err,
            4 => Self::Warning,
            5 => Self::Notice,
            6 => Self::Info,
            7 => Self::Debug,
            8 => Self::Audit,
            _ => return None,
        })
    }
}
#[doc = "nf_tables log flags"]
#[doc = "Original name: \"log-flags\" (flags) - defines an integer enumeration, with values for each entry occupying a bit, starting from bit 0, (e.g. 1, 2, 4, 8)"]
#[derive(Debug, Clone, Copy)]
pub enum LogFlags {
    #[doc = "Log TCP sequence numbers"]
    Tcpseq = 1 << 0,
    #[doc = "Log TCP options"]
    Tcpopt = 1 << 1,
    #[doc = "Log IP options"]
    Ipopt = 1 << 2,
    #[doc = "Log UID owning local socket"]
    Uid = 1 << 3,
    #[doc = "Unsupported, don't reuse"]
    Nflog = 1 << 4,
    #[doc = "Decode MAC header"]
    Macdecode = 1 << 5,
}
impl LogFlags {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            n if n == 1 << 0 => Self::Tcpseq,
            n if n == 1 << 1 => Self::Tcpopt,
            n if n == 1 << 2 => Self::Ipopt,
            n if n == 1 << 3 => Self::Uid,
            n if n == 1 << 4 => Self::Nflog,
            n if n == 1 << 5 => Self::Macdecode,
            _ => return None,
        })
    }
}
#[doc = "Original name: \"log-attrs\""]
#[derive(Clone)]
pub enum LogAttrs<'a> {
    #[doc = "netlink group to send messages to"]
    Group(u16),
    #[doc = "prefix to prepend to log messages"]
    Prefix(&'a CStr),
    #[doc = "length of payload to include in netlink message"]
    Snaplen(u32),
    #[doc = "queue threshold"]
    Qthreshold(u16),
    #[doc = "log level\nAssociated type: \"LogLevel\" (enum)"]
    Level(u32),
    #[doc = "logging flags\nAssociated type: \"LogFlags\" (enum)"]
    Flags(u32),
}
impl<'a> Iterable<'a, LogAttrs<'a>> {
    #[doc = "netlink group to send messages to"]
    pub fn get_group(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let LogAttrs::Group(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("LogAttrs", "Group"))
    }
    #[doc = "prefix to prepend to log messages"]
    pub fn get_prefix(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let LogAttrs::Prefix(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("LogAttrs", "Prefix"))
    }
    #[doc = "length of payload to include in netlink message"]
    pub fn get_snaplen(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let LogAttrs::Snaplen(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("LogAttrs", "Snaplen"))
    }
    #[doc = "queue threshold"]
    pub fn get_qthreshold(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let LogAttrs::Qthreshold(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("LogAttrs", "Qthreshold"))
    }
    #[doc = "log level\nAssociated type: \"LogLevel\" (enum)"]
    pub fn get_level(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let LogAttrs::Level(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("LogAttrs", "Level"))
    }
    #[doc = "logging flags\nAssociated type: \"LogFlags\" (enum)"]
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let LogAttrs::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("LogAttrs", "Flags"))
    }
}
impl<'a> LogAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, LogAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Group",
            2u16 => "Prefix",
            3u16 => "Snaplen",
            4u16 => "Qthreshold",
            5u16 => "Level",
            6u16 => "Flags",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, LogAttrs<'a>> {
    type Item = Result<LogAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => LogAttrs::Group({
                    let res = parse_be_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => LogAttrs::Prefix({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => LogAttrs::Snaplen({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => LogAttrs::Qthreshold({
                    let res = parse_be_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => LogAttrs::Level({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => LogAttrs::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "LogAttrs",
            r#type.and_then(|t| LogAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, LogAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("LogAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                LogAttrs::Group(val) => fmt.field("Group", &val),
                LogAttrs::Prefix(val) => fmt.field("Prefix", &val),
                LogAttrs::Snaplen(val) => fmt.field("Snaplen", &val),
                LogAttrs::Qthreshold(val) => fmt.field("Qthreshold", &val),
                LogAttrs::Level(val) => {
                    fmt.field("Level", &FormatEnum(val.into(), LogLevel::from_value))
                }
                LogAttrs::Flags(val) => {
                    fmt.field("Flags", &FormatFlags(val.into(), LogFlags::from_value))
                }
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, LogAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("LogAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| LogAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                LogAttrs::Group(val) => {
                    if last_off == offset {
                        stack.push(("Group", last_off));
                        break;
                    }
                }
                LogAttrs::Prefix(val) => {
                    if last_off == offset {
                        stack.push(("Prefix", last_off));
                        break;
                    }
                }
                LogAttrs::Snaplen(val) => {
                    if last_off == offset {
                        stack.push(("Snaplen", last_off));
                        break;
                    }
                }
                LogAttrs::Qthreshold(val) => {
                    if last_off == offset {
                        stack.push(("Qthreshold", last_off));
                        break;
                    }
                }
                LogAttrs::Level(val) => {
                    if last_off == offset {
                        stack.push(("Level", last_off));
                        break;
                    }
                }
                LogAttrs::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("LogAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"numgen-attrs\""]
#[derive(Clone)]
pub enum NumgenAttrs {
    #[doc = "destination register\nAssociated type: \"Registers\" (enum)"]
    Dreg(u32),
    #[doc = "maximum counter value"]
    Modulus(u32),
    #[doc = "operation type\nAssociated type: \"NumgenTypes\" (enum)"]
    Type(u32),
    #[doc = "offset to be added to the counter"]
    Offset(u32),
}
impl<'a> Iterable<'a, NumgenAttrs> {
    #[doc = "destination register\nAssociated type: \"Registers\" (enum)"]
    pub fn get_dreg(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let NumgenAttrs::Dreg(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("NumgenAttrs", "Dreg"))
    }
    #[doc = "maximum counter value"]
    pub fn get_modulus(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let NumgenAttrs::Modulus(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("NumgenAttrs", "Modulus"))
    }
    #[doc = "operation type\nAssociated type: \"NumgenTypes\" (enum)"]
    pub fn get_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let NumgenAttrs::Type(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("NumgenAttrs", "Type"))
    }
    #[doc = "offset to be added to the counter"]
    pub fn get_offset(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let NumgenAttrs::Offset(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("NumgenAttrs", "Offset"))
    }
}
impl NumgenAttrs {
    pub fn new(buf: &'_ [u8]) -> Iterable<'_, NumgenAttrs> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Dreg",
            2u16 => "Modulus",
            3u16 => "Type",
            4u16 => "Offset",
            _ => return None,
        };
        Some(res)
    }
}
impl Iterator for Iterable<'_, NumgenAttrs> {
    type Item = Result<NumgenAttrs, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => NumgenAttrs::Dreg({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => NumgenAttrs::Modulus({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => NumgenAttrs::Type({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => NumgenAttrs::Offset({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "NumgenAttrs",
            r#type.and_then(|t| NumgenAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl std::fmt::Debug for Iterable<'_, NumgenAttrs> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("NumgenAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                NumgenAttrs::Dreg(val) => {
                    fmt.field("Dreg", &FormatEnum(val.into(), Registers::from_value))
                }
                NumgenAttrs::Modulus(val) => fmt.field("Modulus", &val),
                NumgenAttrs::Type(val) => {
                    fmt.field("Type", &FormatEnum(val.into(), NumgenTypes::from_value))
                }
                NumgenAttrs::Offset(val) => fmt.field("Offset", &val),
            };
        }
        fmt.finish()
    }
}
impl Iterable<'_, NumgenAttrs> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("NumgenAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| NumgenAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                NumgenAttrs::Dreg(val) => {
                    if last_off == offset {
                        stack.push(("Dreg", last_off));
                        break;
                    }
                }
                NumgenAttrs::Modulus(val) => {
                    if last_off == offset {
                        stack.push(("Modulus", last_off));
                        break;
                    }
                }
                NumgenAttrs::Type(val) => {
                    if last_off == offset {
                        stack.push(("Type", last_off));
                        break;
                    }
                }
                NumgenAttrs::Offset(val) => {
                    if last_off == offset {
                        stack.push(("Offset", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("NumgenAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"range-attrs\""]
#[derive(Clone)]
pub enum RangeAttrs<'a> {
    #[doc = "source register of data to compare\nAssociated type: \"Registers\" (enum)"]
    Sreg(u32),
    #[doc = "cmp operation\nAssociated type: \"RangeOps\" (enum)"]
    Op(u32),
    #[doc = "data range from"]
    FromData(Iterable<'a, DataAttrs<'a>>),
    #[doc = "data range to"]
    ToData(Iterable<'a, DataAttrs<'a>>),
}
impl<'a> Iterable<'a, RangeAttrs<'a>> {
    #[doc = "source register of data to compare\nAssociated type: \"Registers\" (enum)"]
    pub fn get_sreg(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let RangeAttrs::Sreg(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("RangeAttrs", "Sreg"))
    }
    #[doc = "cmp operation\nAssociated type: \"RangeOps\" (enum)"]
    pub fn get_op(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let RangeAttrs::Op(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("RangeAttrs", "Op"))
    }
    #[doc = "data range from"]
    pub fn get_from_data(&self) -> Result<Iterable<'a, DataAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let RangeAttrs::FromData(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("RangeAttrs", "FromData"))
    }
    #[doc = "data range to"]
    pub fn get_to_data(&self) -> Result<Iterable<'a, DataAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let RangeAttrs::ToData(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("RangeAttrs", "ToData"))
    }
}
impl<'a> RangeAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, RangeAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Sreg",
            2u16 => "Op",
            3u16 => "FromData",
            4u16 => "ToData",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, RangeAttrs<'a>> {
    type Item = Result<RangeAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => RangeAttrs::Sreg({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => RangeAttrs::Op({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => RangeAttrs::FromData({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => RangeAttrs::ToData({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "RangeAttrs",
            r#type.and_then(|t| RangeAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, RangeAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("RangeAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                RangeAttrs::Sreg(val) => {
                    fmt.field("Sreg", &FormatEnum(val.into(), Registers::from_value))
                }
                RangeAttrs::Op(val) => {
                    fmt.field("Op", &FormatEnum(val.into(), RangeOps::from_value))
                }
                RangeAttrs::FromData(val) => fmt.field("FromData", &val),
                RangeAttrs::ToData(val) => fmt.field("ToData", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, RangeAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("RangeAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| RangeAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                RangeAttrs::Sreg(val) => {
                    if last_off == offset {
                        stack.push(("Sreg", last_off));
                        break;
                    }
                }
                RangeAttrs::Op(val) => {
                    if last_off == offset {
                        stack.push(("Op", last_off));
                        break;
                    }
                }
                RangeAttrs::FromData(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                RangeAttrs::ToData(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("RangeAttrs", cur));
        }
        (stack, missing)
    }
}
#[doc = "Original name: \"batch-attrs\""]
#[derive(Clone)]
pub enum BatchAttrs {
    Genid(u32),
}
impl<'a> Iterable<'a, BatchAttrs> {
    pub fn get_genid(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let BatchAttrs::Genid(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("BatchAttrs", "Genid"))
    }
}
impl BatchAttrs {
    pub fn new(buf: &'_ [u8]) -> Iterable<'_, BatchAttrs> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Genid",
            _ => return None,
        };
        Some(res)
    }
}
impl Iterator for Iterable<'_, BatchAttrs> {
    type Item = Result<BatchAttrs, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => BatchAttrs::Genid({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "BatchAttrs",
            r#type.and_then(|t| BatchAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl std::fmt::Debug for Iterable<'_, BatchAttrs> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("BatchAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                BatchAttrs::Genid(val) => fmt.field("Genid", &val),
            };
        }
        fmt.finish()
    }
}
impl Iterable<'_, BatchAttrs> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("BatchAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| BatchAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                BatchAttrs::Genid(val) => {
                    if last_off == offset {
                        stack.push(("Genid", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("BatchAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"table-attrs\""]
#[derive(Clone)]
pub enum TableAttrs<'a> {
    #[doc = "name of the table"]
    Name(&'a CStr),
    #[doc = "bitmask of flags\nAssociated type: \"TableFlags\" (1 bit per enumeration)"]
    Flags(u32),
    #[doc = "number of chains in this table"]
    Use(u32),
    #[doc = "numeric handle of the table"]
    Handle(u64),
    #[doc = "user data"]
    Userdata(&'a [u8]),
}
impl<'a> Iterable<'a, TableAttrs<'a>> {
    #[doc = "name of the table"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TableAttrs::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("TableAttrs", "Name"))
    }
    #[doc = "bitmask of flags\nAssociated type: \"TableFlags\" (1 bit per enumeration)"]
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TableAttrs::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("TableAttrs", "Flags"))
    }
    #[doc = "number of chains in this table"]
    pub fn get_use(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TableAttrs::Use(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("TableAttrs", "Use"))
    }
    #[doc = "numeric handle of the table"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TableAttrs::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("TableAttrs", "Handle"))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TableAttrs::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("TableAttrs", "Userdata"))
    }
}
impl<'a> TableAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, TableAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Name",
            2u16 => "Flags",
            3u16 => "Use",
            4u16 => "Handle",
            5u16 => "Userdata",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, TableAttrs<'a>> {
    type Item = Result<TableAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => TableAttrs::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => TableAttrs::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => TableAttrs::Use({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => TableAttrs::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => TableAttrs::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "TableAttrs",
            r#type.and_then(|t| TableAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, TableAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("TableAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                TableAttrs::Name(val) => fmt.field("Name", &val),
                TableAttrs::Flags(val) => {
                    fmt.field("Flags", &FormatFlags(val.into(), TableFlags::from_value))
                }
                TableAttrs::Use(val) => fmt.field("Use", &val),
                TableAttrs::Handle(val) => fmt.field("Handle", &val),
                TableAttrs::Userdata(val) => fmt.field("Userdata", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, TableAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("TableAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| TableAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                TableAttrs::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                TableAttrs::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                TableAttrs::Use(val) => {
                    if last_off == offset {
                        stack.push(("Use", last_off));
                        break;
                    }
                }
                TableAttrs::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                TableAttrs::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("TableAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"chain-attrs\""]
#[derive(Clone)]
pub enum ChainAttrs<'a> {
    #[doc = "name of the table containing the chain"]
    Table(&'a CStr),
    #[doc = "numeric handle of the chain"]
    Handle(u64),
    #[doc = "name of the chain"]
    Name(&'a CStr),
    #[doc = "hook specification for basechains"]
    Hook(Iterable<'a, NftHookAttrs<'a>>),
    #[doc = "numeric policy of the chain"]
    Policy(u32),
    #[doc = "number of references to this chain"]
    Use(u32),
    #[doc = "type name of the chain"]
    Type(&'a CStr),
    #[doc = "counter specification of the chain"]
    Counters(Iterable<'a, NftCounterAttrs>),
    #[doc = "chain flags\nAssociated type: \"ChainFlags\" (1 bit per enumeration)"]
    Flags(u32),
    #[doc = "uniquely identifies a chain in a transaction"]
    Id(u32),
    #[doc = "user data"]
    Userdata(&'a [u8]),
}
impl<'a> Iterable<'a, ChainAttrs<'a>> {
    #[doc = "name of the table containing the chain"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ChainAttrs::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ChainAttrs", "Table"))
    }
    #[doc = "numeric handle of the chain"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ChainAttrs::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ChainAttrs", "Handle"))
    }
    #[doc = "name of the chain"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ChainAttrs::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ChainAttrs", "Name"))
    }
    #[doc = "hook specification for basechains"]
    pub fn get_hook(&self) -> Result<Iterable<'a, NftHookAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ChainAttrs::Hook(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ChainAttrs", "Hook"))
    }
    #[doc = "numeric policy of the chain"]
    pub fn get_policy(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ChainAttrs::Policy(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ChainAttrs", "Policy"))
    }
    #[doc = "number of references to this chain"]
    pub fn get_use(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ChainAttrs::Use(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ChainAttrs", "Use"))
    }
    #[doc = "type name of the chain"]
    pub fn get_type(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ChainAttrs::Type(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ChainAttrs", "Type"))
    }
    #[doc = "counter specification of the chain"]
    pub fn get_counters(&self) -> Result<Iterable<'a, NftCounterAttrs>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ChainAttrs::Counters(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ChainAttrs", "Counters"))
    }
    #[doc = "chain flags\nAssociated type: \"ChainFlags\" (1 bit per enumeration)"]
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ChainAttrs::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ChainAttrs", "Flags"))
    }
    #[doc = "uniquely identifies a chain in a transaction"]
    pub fn get_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ChainAttrs::Id(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ChainAttrs", "Id"))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ChainAttrs::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ChainAttrs", "Userdata"))
    }
}
impl<'a> ChainAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, ChainAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Table",
            2u16 => "Handle",
            3u16 => "Name",
            4u16 => "Hook",
            5u16 => "Policy",
            6u16 => "Use",
            7u16 => "Type",
            8u16 => "Counters",
            9u16 => "Flags",
            10u16 => "Id",
            11u16 => "Userdata",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, ChainAttrs<'a>> {
    type Item = Result<ChainAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => ChainAttrs::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => ChainAttrs::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => ChainAttrs::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => ChainAttrs::Hook({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => ChainAttrs::Policy({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => ChainAttrs::Use({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => ChainAttrs::Type({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => ChainAttrs::Counters({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => ChainAttrs::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => ChainAttrs::Id({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => ChainAttrs::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "ChainAttrs",
            r#type.and_then(|t| ChainAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, ChainAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("ChainAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                ChainAttrs::Table(val) => fmt.field("Table", &val),
                ChainAttrs::Handle(val) => fmt.field("Handle", &val),
                ChainAttrs::Name(val) => fmt.field("Name", &val),
                ChainAttrs::Hook(val) => fmt.field("Hook", &val),
                ChainAttrs::Policy(val) => fmt.field("Policy", &val),
                ChainAttrs::Use(val) => fmt.field("Use", &val),
                ChainAttrs::Type(val) => fmt.field("Type", &val),
                ChainAttrs::Counters(val) => fmt.field("Counters", &val),
                ChainAttrs::Flags(val) => {
                    fmt.field("Flags", &FormatFlags(val.into(), ChainFlags::from_value))
                }
                ChainAttrs::Id(val) => fmt.field("Id", &val),
                ChainAttrs::Userdata(val) => fmt.field("Userdata", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, ChainAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("ChainAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| ChainAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                ChainAttrs::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                ChainAttrs::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                ChainAttrs::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                ChainAttrs::Hook(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                ChainAttrs::Policy(val) => {
                    if last_off == offset {
                        stack.push(("Policy", last_off));
                        break;
                    }
                }
                ChainAttrs::Use(val) => {
                    if last_off == offset {
                        stack.push(("Use", last_off));
                        break;
                    }
                }
                ChainAttrs::Type(val) => {
                    if last_off == offset {
                        stack.push(("Type", last_off));
                        break;
                    }
                }
                ChainAttrs::Counters(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                ChainAttrs::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                ChainAttrs::Id(val) => {
                    if last_off == offset {
                        stack.push(("Id", last_off));
                        break;
                    }
                }
                ChainAttrs::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("ChainAttrs", cur));
        }
        (stack, missing)
    }
}
#[doc = "Original name: \"counter-attrs\""]
#[derive(Clone)]
pub enum CounterAttrs<'a> {
    Bytes(u64),
    Packets(u64),
    Pad(&'a [u8]),
}
impl<'a> Iterable<'a, CounterAttrs<'a>> {
    pub fn get_bytes(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CounterAttrs::Bytes(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CounterAttrs", "Bytes"))
    }
    pub fn get_packets(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CounterAttrs::Packets(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CounterAttrs", "Packets"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CounterAttrs::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CounterAttrs", "Pad"))
    }
}
impl<'a> CounterAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, CounterAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Bytes",
            2u16 => "Packets",
            3u16 => "Pad",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, CounterAttrs<'a>> {
    type Item = Result<CounterAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => CounterAttrs::Bytes({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => CounterAttrs::Packets({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => CounterAttrs::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "CounterAttrs",
            r#type.and_then(|t| CounterAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, CounterAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("CounterAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                CounterAttrs::Bytes(val) => fmt.field("Bytes", &val),
                CounterAttrs::Packets(val) => fmt.field("Packets", &val),
                CounterAttrs::Pad(val) => fmt.field("Pad", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, CounterAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("CounterAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| CounterAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                CounterAttrs::Bytes(val) => {
                    if last_off == offset {
                        stack.push(("Bytes", last_off));
                        break;
                    }
                }
                CounterAttrs::Packets(val) => {
                    if last_off == offset {
                        stack.push(("Packets", last_off));
                        break;
                    }
                }
                CounterAttrs::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("CounterAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"nft-hook-attrs\""]
#[derive(Clone)]
pub enum NftHookAttrs<'a> {
    Num(u32),
    Priority(i32),
    #[doc = "net device name"]
    Dev(&'a CStr),
    #[doc = "list of net devices"]
    Devs(Iterable<'a, HookDevAttrs<'a>>),
}
impl<'a> Iterable<'a, NftHookAttrs<'a>> {
    pub fn get_num(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let NftHookAttrs::Num(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("NftHookAttrs", "Num"))
    }
    pub fn get_priority(&self) -> Result<i32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let NftHookAttrs::Priority(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("NftHookAttrs", "Priority"))
    }
    #[doc = "net device name"]
    pub fn get_dev(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let NftHookAttrs::Dev(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("NftHookAttrs", "Dev"))
    }
    #[doc = "list of net devices"]
    pub fn get_devs(&self) -> Result<Iterable<'a, HookDevAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let NftHookAttrs::Devs(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("NftHookAttrs", "Devs"))
    }
}
impl<'a> NftHookAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, NftHookAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Num",
            2u16 => "Priority",
            3u16 => "Dev",
            4u16 => "Devs",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, NftHookAttrs<'a>> {
    type Item = Result<NftHookAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => NftHookAttrs::Num({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => NftHookAttrs::Priority({
                    let res = parse_be_i32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => NftHookAttrs::Dev({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => NftHookAttrs::Devs({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "NftHookAttrs",
            r#type.and_then(|t| NftHookAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, NftHookAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("NftHookAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                NftHookAttrs::Num(val) => fmt.field("Num", &val),
                NftHookAttrs::Priority(val) => fmt.field("Priority", &val),
                NftHookAttrs::Dev(val) => fmt.field("Dev", &val),
                NftHookAttrs::Devs(val) => fmt.field("Devs", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, NftHookAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("NftHookAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| NftHookAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                NftHookAttrs::Num(val) => {
                    if last_off == offset {
                        stack.push(("Num", last_off));
                        break;
                    }
                }
                NftHookAttrs::Priority(val) => {
                    if last_off == offset {
                        stack.push(("Priority", last_off));
                        break;
                    }
                }
                NftHookAttrs::Dev(val) => {
                    if last_off == offset {
                        stack.push(("Dev", last_off));
                        break;
                    }
                }
                NftHookAttrs::Devs(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("NftHookAttrs", cur));
        }
        (stack, missing)
    }
}
#[doc = "Original name: \"hook-dev-attrs\""]
#[derive(Clone)]
pub enum HookDevAttrs<'a> {
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    Name(&'a CStr),
}
impl<'a> Iterable<'a, HookDevAttrs<'a>> {
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn get_name(&self) -> MultiAttrIterable<Self, HookDevAttrs<'a>, &'a CStr> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let HookDevAttrs::Name(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
}
impl<'a> HookDevAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, HookDevAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Name",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, HookDevAttrs<'a>> {
    type Item = Result<HookDevAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => HookDevAttrs::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "HookDevAttrs",
            r#type.and_then(|t| HookDevAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, HookDevAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("HookDevAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                HookDevAttrs::Name(val) => fmt.field("Name", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, HookDevAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("HookDevAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| HookDevAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                HookDevAttrs::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("HookDevAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"nft-counter-attrs\""]
#[derive(Clone)]
pub enum NftCounterAttrs {
    Bytes(u64),
    Packets(u64),
}
impl<'a> Iterable<'a, NftCounterAttrs> {
    pub fn get_bytes(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let NftCounterAttrs::Bytes(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("NftCounterAttrs", "Bytes"))
    }
    pub fn get_packets(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let NftCounterAttrs::Packets(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("NftCounterAttrs", "Packets"))
    }
}
impl NftCounterAttrs {
    pub fn new(buf: &'_ [u8]) -> Iterable<'_, NftCounterAttrs> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Bytes",
            2u16 => "Packets",
            _ => return None,
        };
        Some(res)
    }
}
impl Iterator for Iterable<'_, NftCounterAttrs> {
    type Item = Result<NftCounterAttrs, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => NftCounterAttrs::Bytes({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => NftCounterAttrs::Packets({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "NftCounterAttrs",
            r#type.and_then(|t| NftCounterAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl std::fmt::Debug for Iterable<'_, NftCounterAttrs> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("NftCounterAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                NftCounterAttrs::Bytes(val) => fmt.field("Bytes", &val),
                NftCounterAttrs::Packets(val) => fmt.field("Packets", &val),
            };
        }
        fmt.finish()
    }
}
impl Iterable<'_, NftCounterAttrs> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("NftCounterAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| NftCounterAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                NftCounterAttrs::Bytes(val) => {
                    if last_off == offset {
                        stack.push(("Bytes", last_off));
                        break;
                    }
                }
                NftCounterAttrs::Packets(val) => {
                    if last_off == offset {
                        stack.push(("Packets", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("NftCounterAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"rule-attrs\""]
#[derive(Clone)]
pub enum RuleAttrs<'a> {
    #[doc = "name of the table containing the rule"]
    Table(&'a CStr),
    #[doc = "name of the chain containing the rule"]
    Chain(&'a CStr),
    #[doc = "numeric handle of the rule"]
    Handle(u64),
    #[doc = "list of expressions"]
    Expressions(Iterable<'a, ExprListAttrs<'a>>),
    #[doc = "compatibility specifications of the rule"]
    Compat(Iterable<'a, RuleCompatAttrs>),
    #[doc = "numeric handle of the previous rule"]
    Position(u64),
    #[doc = "user data"]
    Userdata(&'a [u8]),
    #[doc = "uniquely identifies a rule in a transaction"]
    Id(u32),
    #[doc = "transaction unique identifier of the previous rule"]
    PositionId(u32),
    #[doc = "add the rule to chain by ID, alternative to chain name"]
    ChainId(u32),
}
impl<'a> Iterable<'a, RuleAttrs<'a>> {
    #[doc = "name of the table containing the rule"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let RuleAttrs::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("RuleAttrs", "Table"))
    }
    #[doc = "name of the chain containing the rule"]
    pub fn get_chain(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let RuleAttrs::Chain(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("RuleAttrs", "Chain"))
    }
    #[doc = "numeric handle of the rule"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let RuleAttrs::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("RuleAttrs", "Handle"))
    }
    #[doc = "list of expressions"]
    pub fn get_expressions(&self) -> Result<Iterable<'a, ExprListAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let RuleAttrs::Expressions(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("RuleAttrs", "Expressions"))
    }
    #[doc = "compatibility specifications of the rule"]
    pub fn get_compat(&self) -> Result<Iterable<'a, RuleCompatAttrs>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let RuleAttrs::Compat(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("RuleAttrs", "Compat"))
    }
    #[doc = "numeric handle of the previous rule"]
    pub fn get_position(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let RuleAttrs::Position(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("RuleAttrs", "Position"))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let RuleAttrs::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("RuleAttrs", "Userdata"))
    }
    #[doc = "uniquely identifies a rule in a transaction"]
    pub fn get_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let RuleAttrs::Id(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("RuleAttrs", "Id"))
    }
    #[doc = "transaction unique identifier of the previous rule"]
    pub fn get_position_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let RuleAttrs::PositionId(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("RuleAttrs", "PositionId"))
    }
    #[doc = "add the rule to chain by ID, alternative to chain name"]
    pub fn get_chain_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let RuleAttrs::ChainId(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("RuleAttrs", "ChainId"))
    }
}
impl<'a> RuleAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, RuleAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Table",
            2u16 => "Chain",
            3u16 => "Handle",
            4u16 => "Expressions",
            5u16 => "Compat",
            6u16 => "Position",
            7u16 => "Userdata",
            8u16 => "Id",
            9u16 => "PositionId",
            10u16 => "ChainId",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, RuleAttrs<'a>> {
    type Item = Result<RuleAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => RuleAttrs::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => RuleAttrs::Chain({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => RuleAttrs::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => RuleAttrs::Expressions({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => RuleAttrs::Compat({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => RuleAttrs::Position({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => RuleAttrs::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => RuleAttrs::Id({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => RuleAttrs::PositionId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => RuleAttrs::ChainId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "RuleAttrs",
            r#type.and_then(|t| RuleAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, RuleAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("RuleAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                RuleAttrs::Table(val) => fmt.field("Table", &val),
                RuleAttrs::Chain(val) => fmt.field("Chain", &val),
                RuleAttrs::Handle(val) => fmt.field("Handle", &val),
                RuleAttrs::Expressions(val) => fmt.field("Expressions", &val),
                RuleAttrs::Compat(val) => fmt.field("Compat", &val),
                RuleAttrs::Position(val) => fmt.field("Position", &val),
                RuleAttrs::Userdata(val) => fmt.field("Userdata", &val),
                RuleAttrs::Id(val) => fmt.field("Id", &val),
                RuleAttrs::PositionId(val) => fmt.field("PositionId", &val),
                RuleAttrs::ChainId(val) => fmt.field("ChainId", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, RuleAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("RuleAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| RuleAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                RuleAttrs::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                RuleAttrs::Chain(val) => {
                    if last_off == offset {
                        stack.push(("Chain", last_off));
                        break;
                    }
                }
                RuleAttrs::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                RuleAttrs::Expressions(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                RuleAttrs::Compat(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                RuleAttrs::Position(val) => {
                    if last_off == offset {
                        stack.push(("Position", last_off));
                        break;
                    }
                }
                RuleAttrs::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                RuleAttrs::Id(val) => {
                    if last_off == offset {
                        stack.push(("Id", last_off));
                        break;
                    }
                }
                RuleAttrs::PositionId(val) => {
                    if last_off == offset {
                        stack.push(("PositionId", last_off));
                        break;
                    }
                }
                RuleAttrs::ChainId(val) => {
                    if last_off == offset {
                        stack.push(("ChainId", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("RuleAttrs", cur));
        }
        (stack, missing)
    }
}
#[doc = "Original name: \"expr-list-attrs\""]
#[derive(Clone)]
pub enum ExprListAttrs<'a> {
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    Elem(Iterable<'a, ExprAttrs<'a>>),
}
impl<'a> Iterable<'a, ExprListAttrs<'a>> {
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn get_elem(
        &self,
    ) -> MultiAttrIterable<Self, ExprListAttrs<'a>, Iterable<'a, ExprAttrs<'a>>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let ExprListAttrs::Elem(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
}
impl<'a> ExprListAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, ExprListAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Elem",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, ExprListAttrs<'a>> {
    type Item = Result<ExprListAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => ExprListAttrs::Elem({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "ExprListAttrs",
            r#type.and_then(|t| ExprListAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, ExprListAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("ExprListAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                ExprListAttrs::Elem(val) => fmt.field("Elem", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, ExprListAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("ExprListAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| ExprListAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                ExprListAttrs::Elem(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("ExprListAttrs", cur));
        }
        (stack, missing)
    }
}
#[doc = "Original name: \"expr-attrs\""]
#[derive(Clone)]
pub enum ExprAttrs<'a> {
    #[doc = "name of the expression type"]
    Name(&'a CStr),
    #[doc = "type specific data"]
    Data(ExprOps<'a>),
}
impl<'a> Iterable<'a, ExprAttrs<'a>> {
    #[doc = "name of the expression type"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprAttrs::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprAttrs", "Name"))
    }
    #[doc = "type specific data"]
    pub fn get_data(&self) -> Result<ExprOps<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprAttrs::Data(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprAttrs", "Data"))
    }
}
#[doc = "Original name: \"expr-ops\""]
#[derive(Debug, Clone)]
pub enum ExprOps<'a> {
    Bitwise(Iterable<'a, ExprBitwiseAttrs<'a>>),
    Cmp(Iterable<'a, ExprCmpAttrs<'a>>),
    Counter(Iterable<'a, ExprCounterAttrs<'a>>),
    Ct(Iterable<'a, ExprCtAttrs>),
    Fib(Iterable<'a, ExprFibAttrs>),
    FlowOffload(Iterable<'a, ExprFlowOffloadAttrs<'a>>),
    Immediate(Iterable<'a, ExprImmediateAttrs<'a>>),
    Lookup(Iterable<'a, ExprLookupAttrs<'a>>),
    Meta(Iterable<'a, ExprMetaAttrs>),
    Nat(Iterable<'a, ExprNatAttrs>),
    Objref(Iterable<'a, ExprObjrefAttrs<'a>>),
    Payload(Iterable<'a, ExprPayloadAttrs>),
    Quota(Iterable<'a, QuotaAttrs<'a>>),
    Reject(Iterable<'a, ExprRejectAttrs>),
    Target(Iterable<'a, ExprTargetAttrs<'a>>),
    Tproxy(Iterable<'a, ExprTproxyAttrs>),
    Match(Iterable<'a, CompatMatchAttrs<'a>>),
    Range(Iterable<'a, RangeAttrs<'a>>),
    Numgen(Iterable<'a, NumgenAttrs>),
    Log(Iterable<'a, LogAttrs<'a>>),
}
impl<'a> ExprOps<'a> {
    fn select_with_loc(selector: &'a CStr, buf: &'a [u8], loc: usize) -> Option<Self> {
        match selector.to_bytes() {
            b"bitwise" => Some(ExprOps::Bitwise(Iterable::with_loc(buf, loc))),
            b"cmp" => Some(ExprOps::Cmp(Iterable::with_loc(buf, loc))),
            b"counter" => Some(ExprOps::Counter(Iterable::with_loc(buf, loc))),
            b"ct" => Some(ExprOps::Ct(Iterable::with_loc(buf, loc))),
            b"fib" => Some(ExprOps::Fib(Iterable::with_loc(buf, loc))),
            b"flow_offload" => Some(ExprOps::FlowOffload(Iterable::with_loc(buf, loc))),
            b"immediate" => Some(ExprOps::Immediate(Iterable::with_loc(buf, loc))),
            b"lookup" => Some(ExprOps::Lookup(Iterable::with_loc(buf, loc))),
            b"meta" => Some(ExprOps::Meta(Iterable::with_loc(buf, loc))),
            b"nat" => Some(ExprOps::Nat(Iterable::with_loc(buf, loc))),
            b"objref" => Some(ExprOps::Objref(Iterable::with_loc(buf, loc))),
            b"payload" => Some(ExprOps::Payload(Iterable::with_loc(buf, loc))),
            b"quota" => Some(ExprOps::Quota(Iterable::with_loc(buf, loc))),
            b"reject" => Some(ExprOps::Reject(Iterable::with_loc(buf, loc))),
            b"target" => Some(ExprOps::Target(Iterable::with_loc(buf, loc))),
            b"tproxy" => Some(ExprOps::Tproxy(Iterable::with_loc(buf, loc))),
            b"match" => Some(ExprOps::Match(Iterable::with_loc(buf, loc))),
            b"range" => Some(ExprOps::Range(Iterable::with_loc(buf, loc))),
            b"numgen" => Some(ExprOps::Numgen(Iterable::with_loc(buf, loc))),
            b"log" => Some(ExprOps::Log(Iterable::with_loc(buf, loc))),
            _ => None,
        }
    }
}
impl<'a> ExprAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, ExprAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Name",
            2u16 => "Data",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, ExprAttrs<'a>> {
    type Item = Result<ExprAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => ExprAttrs::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => ExprAttrs::Data({
                    let res = {
                        let Ok(selector) = self.get_name() else { break };
                        ExprOps::select_with_loc(selector, next, self.orig_loc)
                    };
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "ExprAttrs",
            r#type.and_then(|t| ExprAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, ExprAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("ExprAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                ExprAttrs::Name(val) => fmt.field("Name", &val),
                ExprAttrs::Data(val) => fmt.field("Data", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, ExprAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("ExprAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| ExprAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                ExprAttrs::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                ExprAttrs::Data(val) => {
                    if last_off == offset {
                        stack.push(("Data", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("ExprAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"rule-compat-attrs\""]
#[derive(Clone)]
pub enum RuleCompatAttrs {
    #[doc = "numeric value of the handled protocol"]
    Proto(u32),
    #[doc = "bitmask of flags"]
    Flags(u32),
}
impl<'a> Iterable<'a, RuleCompatAttrs> {
    #[doc = "numeric value of the handled protocol"]
    pub fn get_proto(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let RuleCompatAttrs::Proto(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("RuleCompatAttrs", "Proto"))
    }
    #[doc = "bitmask of flags"]
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let RuleCompatAttrs::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("RuleCompatAttrs", "Flags"))
    }
}
impl RuleCompatAttrs {
    pub fn new(buf: &'_ [u8]) -> Iterable<'_, RuleCompatAttrs> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Proto",
            2u16 => "Flags",
            _ => return None,
        };
        Some(res)
    }
}
impl Iterator for Iterable<'_, RuleCompatAttrs> {
    type Item = Result<RuleCompatAttrs, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => RuleCompatAttrs::Proto({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => RuleCompatAttrs::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "RuleCompatAttrs",
            r#type.and_then(|t| RuleCompatAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl std::fmt::Debug for Iterable<'_, RuleCompatAttrs> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("RuleCompatAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                RuleCompatAttrs::Proto(val) => fmt.field("Proto", &val),
                RuleCompatAttrs::Flags(val) => fmt.field("Flags", &val),
            };
        }
        fmt.finish()
    }
}
impl Iterable<'_, RuleCompatAttrs> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("RuleCompatAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| RuleCompatAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                RuleCompatAttrs::Proto(val) => {
                    if last_off == offset {
                        stack.push(("Proto", last_off));
                        break;
                    }
                }
                RuleCompatAttrs::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("RuleCompatAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"set-attrs\""]
#[derive(Clone)]
pub enum SetAttrs<'a> {
    #[doc = "table name"]
    Table(&'a CStr),
    #[doc = "set name"]
    Name(&'a CStr),
    #[doc = "bitmask of enum nft_set_flags\nAssociated type: \"SetFlags\" (enum)"]
    Flags(u32),
    #[doc = "key data type, informational purpose only"]
    KeyType(u32),
    #[doc = "key data length"]
    KeyLen(u32),
    #[doc = "mapping data type"]
    DataType(u32),
    #[doc = "mapping data length"]
    DataLen(u32),
    #[doc = "selection policy"]
    Policy(u32),
    #[doc = "set description"]
    Desc(Iterable<'a, SetDescAttrs<'a>>),
    #[doc = "uniquely identifies a set in a transaction"]
    Id(u32),
    #[doc = "default timeout value"]
    Timeout(u64),
    #[doc = "garbage collection interval"]
    GcInterval(u32),
    #[doc = "user data"]
    Userdata(&'a [u8]),
    Pad(&'a [u8]),
    #[doc = "stateful object type"]
    ObjType(u32),
    #[doc = "set handle"]
    Handle(u64),
    #[doc = "set expression\nAttribute may repeat multiple times (treat it as array)"]
    Expr(Iterable<'a, ExprAttrs<'a>>),
    #[doc = "list of expressions"]
    Expressions(Iterable<'a, SetListAttrs<'a>>),
}
impl<'a> Iterable<'a, SetAttrs<'a>> {
    #[doc = "table name"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetAttrs::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("SetAttrs", "Table"))
    }
    #[doc = "set name"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetAttrs::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("SetAttrs", "Name"))
    }
    #[doc = "bitmask of enum nft_set_flags\nAssociated type: \"SetFlags\" (enum)"]
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetAttrs::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("SetAttrs", "Flags"))
    }
    #[doc = "key data type, informational purpose only"]
    pub fn get_key_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetAttrs::KeyType(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("SetAttrs", "KeyType"))
    }
    #[doc = "key data length"]
    pub fn get_key_len(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetAttrs::KeyLen(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("SetAttrs", "KeyLen"))
    }
    #[doc = "mapping data type"]
    pub fn get_data_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetAttrs::DataType(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("SetAttrs", "DataType"))
    }
    #[doc = "mapping data length"]
    pub fn get_data_len(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetAttrs::DataLen(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("SetAttrs", "DataLen"))
    }
    #[doc = "selection policy"]
    pub fn get_policy(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetAttrs::Policy(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("SetAttrs", "Policy"))
    }
    #[doc = "set description"]
    pub fn get_desc(&self) -> Result<Iterable<'a, SetDescAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetAttrs::Desc(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("SetAttrs", "Desc"))
    }
    #[doc = "uniquely identifies a set in a transaction"]
    pub fn get_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetAttrs::Id(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("SetAttrs", "Id"))
    }
    #[doc = "default timeout value"]
    pub fn get_timeout(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetAttrs::Timeout(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("SetAttrs", "Timeout"))
    }
    #[doc = "garbage collection interval"]
    pub fn get_gc_interval(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetAttrs::GcInterval(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("SetAttrs", "GcInterval"))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetAttrs::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("SetAttrs", "Userdata"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetAttrs::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("SetAttrs", "Pad"))
    }
    #[doc = "stateful object type"]
    pub fn get_obj_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetAttrs::ObjType(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("SetAttrs", "ObjType"))
    }
    #[doc = "set handle"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetAttrs::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("SetAttrs", "Handle"))
    }
    #[doc = "set expression\nAttribute may repeat multiple times (treat it as array)"]
    pub fn get_expr(&self) -> MultiAttrIterable<Self, SetAttrs<'a>, Iterable<'a, ExprAttrs<'a>>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let SetAttrs::Expr(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
    #[doc = "list of expressions"]
    pub fn get_expressions(&self) -> Result<Iterable<'a, SetListAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetAttrs::Expressions(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("SetAttrs", "Expressions"))
    }
}
impl<'a> SetAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, SetAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Table",
            2u16 => "Name",
            3u16 => "Flags",
            4u16 => "KeyType",
            5u16 => "KeyLen",
            6u16 => "DataType",
            7u16 => "DataLen",
            8u16 => "Policy",
            9u16 => "Desc",
            10u16 => "Id",
            11u16 => "Timeout",
            12u16 => "GcInterval",
            13u16 => "Userdata",
            14u16 => "Pad",
            15u16 => "ObjType",
            16u16 => "Handle",
            17u16 => "Expr",
            18u16 => "Expressions",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, SetAttrs<'a>> {
    type Item = Result<SetAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => SetAttrs::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => SetAttrs::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => SetAttrs::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => SetAttrs::KeyType({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => SetAttrs::KeyLen({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => SetAttrs::DataType({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => SetAttrs::DataLen({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => SetAttrs::Policy({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => SetAttrs::Desc({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => SetAttrs::Id({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => SetAttrs::Timeout({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                12u16 => SetAttrs::GcInterval({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                13u16 => SetAttrs::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                14u16 => SetAttrs::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                15u16 => SetAttrs::ObjType({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                16u16 => SetAttrs::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                17u16 => SetAttrs::Expr({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                18u16 => SetAttrs::Expressions({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "SetAttrs",
            r#type.and_then(|t| SetAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, SetAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("SetAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                SetAttrs::Table(val) => fmt.field("Table", &val),
                SetAttrs::Name(val) => fmt.field("Name", &val),
                SetAttrs::Flags(val) => {
                    fmt.field("Flags", &FormatFlags(val.into(), SetFlags::from_value))
                }
                SetAttrs::KeyType(val) => fmt.field("KeyType", &val),
                SetAttrs::KeyLen(val) => fmt.field("KeyLen", &val),
                SetAttrs::DataType(val) => fmt.field("DataType", &val),
                SetAttrs::DataLen(val) => fmt.field("DataLen", &val),
                SetAttrs::Policy(val) => fmt.field("Policy", &val),
                SetAttrs::Desc(val) => fmt.field("Desc", &val),
                SetAttrs::Id(val) => fmt.field("Id", &val),
                SetAttrs::Timeout(val) => fmt.field("Timeout", &val),
                SetAttrs::GcInterval(val) => fmt.field("GcInterval", &val),
                SetAttrs::Userdata(val) => fmt.field("Userdata", &val),
                SetAttrs::Pad(val) => fmt.field("Pad", &val),
                SetAttrs::ObjType(val) => fmt.field("ObjType", &val),
                SetAttrs::Handle(val) => fmt.field("Handle", &val),
                SetAttrs::Expr(val) => fmt.field("Expr", &val),
                SetAttrs::Expressions(val) => fmt.field("Expressions", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, SetAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("SetAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| SetAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                SetAttrs::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                SetAttrs::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                SetAttrs::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                SetAttrs::KeyType(val) => {
                    if last_off == offset {
                        stack.push(("KeyType", last_off));
                        break;
                    }
                }
                SetAttrs::KeyLen(val) => {
                    if last_off == offset {
                        stack.push(("KeyLen", last_off));
                        break;
                    }
                }
                SetAttrs::DataType(val) => {
                    if last_off == offset {
                        stack.push(("DataType", last_off));
                        break;
                    }
                }
                SetAttrs::DataLen(val) => {
                    if last_off == offset {
                        stack.push(("DataLen", last_off));
                        break;
                    }
                }
                SetAttrs::Policy(val) => {
                    if last_off == offset {
                        stack.push(("Policy", last_off));
                        break;
                    }
                }
                SetAttrs::Desc(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                SetAttrs::Id(val) => {
                    if last_off == offset {
                        stack.push(("Id", last_off));
                        break;
                    }
                }
                SetAttrs::Timeout(val) => {
                    if last_off == offset {
                        stack.push(("Timeout", last_off));
                        break;
                    }
                }
                SetAttrs::GcInterval(val) => {
                    if last_off == offset {
                        stack.push(("GcInterval", last_off));
                        break;
                    }
                }
                SetAttrs::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                SetAttrs::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                SetAttrs::ObjType(val) => {
                    if last_off == offset {
                        stack.push(("ObjType", last_off));
                        break;
                    }
                }
                SetAttrs::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                SetAttrs::Expr(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                SetAttrs::Expressions(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("SetAttrs", cur));
        }
        (stack, missing)
    }
}
#[doc = "Original name: \"set-desc-attrs\""]
#[derive(Clone)]
pub enum SetDescAttrs<'a> {
    #[doc = "number of elements in set"]
    Size(u32),
    #[doc = "description of field concatenation\nAttribute may repeat multiple times (treat it as array)"]
    Concat(Iterable<'a, SetDescConcatAttrs<'a>>),
}
impl<'a> Iterable<'a, SetDescAttrs<'a>> {
    #[doc = "number of elements in set"]
    pub fn get_size(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetDescAttrs::Size(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("SetDescAttrs", "Size"))
    }
    #[doc = "description of field concatenation\nAttribute may repeat multiple times (treat it as array)"]
    pub fn get_concat(
        &self,
    ) -> MultiAttrIterable<Self, SetDescAttrs<'a>, Iterable<'a, SetDescConcatAttrs<'a>>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let SetDescAttrs::Concat(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
}
impl<'a> SetDescAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, SetDescAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Size",
            2u16 => "Concat",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, SetDescAttrs<'a>> {
    type Item = Result<SetDescAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => SetDescAttrs::Size({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => SetDescAttrs::Concat({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "SetDescAttrs",
            r#type.and_then(|t| SetDescAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, SetDescAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("SetDescAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                SetDescAttrs::Size(val) => fmt.field("Size", &val),
                SetDescAttrs::Concat(val) => fmt.field("Concat", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, SetDescAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("SetDescAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| SetDescAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                SetDescAttrs::Size(val) => {
                    if last_off == offset {
                        stack.push(("Size", last_off));
                        break;
                    }
                }
                SetDescAttrs::Concat(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("SetDescAttrs", cur));
        }
        (stack, missing)
    }
}
#[doc = "Original name: \"set-desc-concat-attrs\""]
#[derive(Clone)]
pub enum SetDescConcatAttrs<'a> {
    Elem(Iterable<'a, SetFieldAttrs>),
}
impl<'a> Iterable<'a, SetDescConcatAttrs<'a>> {
    pub fn get_elem(&self) -> Result<Iterable<'a, SetFieldAttrs>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetDescConcatAttrs::Elem(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("SetDescConcatAttrs", "Elem"))
    }
}
impl<'a> SetDescConcatAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, SetDescConcatAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Elem",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, SetDescConcatAttrs<'a>> {
    type Item = Result<SetDescConcatAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => SetDescConcatAttrs::Elem({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "SetDescConcatAttrs",
            r#type.and_then(|t| SetDescConcatAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, SetDescConcatAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("SetDescConcatAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                SetDescConcatAttrs::Elem(val) => fmt.field("Elem", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, SetDescConcatAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("SetDescConcatAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| SetDescConcatAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                SetDescConcatAttrs::Elem(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("SetDescConcatAttrs", cur));
        }
        (stack, missing)
    }
}
#[doc = "Original name: \"set-field-attrs\""]
#[derive(Clone)]
pub enum SetFieldAttrs {
    Len(u32),
}
impl<'a> Iterable<'a, SetFieldAttrs> {
    pub fn get_len(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetFieldAttrs::Len(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("SetFieldAttrs", "Len"))
    }
}
impl SetFieldAttrs {
    pub fn new(buf: &'_ [u8]) -> Iterable<'_, SetFieldAttrs> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Len",
            _ => return None,
        };
        Some(res)
    }
}
impl Iterator for Iterable<'_, SetFieldAttrs> {
    type Item = Result<SetFieldAttrs, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => SetFieldAttrs::Len({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "SetFieldAttrs",
            r#type.and_then(|t| SetFieldAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl std::fmt::Debug for Iterable<'_, SetFieldAttrs> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("SetFieldAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                SetFieldAttrs::Len(val) => fmt.field("Len", &val),
            };
        }
        fmt.finish()
    }
}
impl Iterable<'_, SetFieldAttrs> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("SetFieldAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| SetFieldAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                SetFieldAttrs::Len(val) => {
                    if last_off == offset {
                        stack.push(("Len", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("SetFieldAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"set-list-attrs\""]
#[derive(Clone)]
pub enum SetListAttrs<'a> {
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    Elem(Iterable<'a, ExprAttrs<'a>>),
}
impl<'a> Iterable<'a, SetListAttrs<'a>> {
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn get_elem(
        &self,
    ) -> MultiAttrIterable<Self, SetListAttrs<'a>, Iterable<'a, ExprAttrs<'a>>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let SetListAttrs::Elem(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
}
impl<'a> SetListAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, SetListAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Elem",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, SetListAttrs<'a>> {
    type Item = Result<SetListAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => SetListAttrs::Elem({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "SetListAttrs",
            r#type.and_then(|t| SetListAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, SetListAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("SetListAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                SetListAttrs::Elem(val) => fmt.field("Elem", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, SetListAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("SetListAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| SetListAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                SetListAttrs::Elem(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("SetListAttrs", cur));
        }
        (stack, missing)
    }
}
#[doc = "Original name: \"setelem-attrs\""]
#[derive(Clone)]
pub enum SetelemAttrs<'a> {
    #[doc = "key value"]
    Key(Iterable<'a, DataAttrs<'a>>),
    #[doc = "data value of mapping"]
    Data(Iterable<'a, DataAttrs<'a>>),
    #[doc = "bitmask of nft_set_elem_flags"]
    Flags(&'a [u8]),
    #[doc = "timeout value"]
    Timeout(u64),
    #[doc = "expiration time"]
    Expiration(u64),
    #[doc = "user data"]
    Userdata(&'a [u8]),
    #[doc = "expression"]
    Expr(Iterable<'a, ExprAttrs<'a>>),
    #[doc = "stateful object reference"]
    Objref(&'a CStr),
    #[doc = "closing key value"]
    KeyEnd(Iterable<'a, DataAttrs<'a>>),
    #[doc = "list of expressions"]
    Expressions(Iterable<'a, ExprListAttrs<'a>>),
}
impl<'a> Iterable<'a, SetelemAttrs<'a>> {
    #[doc = "key value"]
    pub fn get_key(&self) -> Result<Iterable<'a, DataAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetelemAttrs::Key(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("SetelemAttrs", "Key"))
    }
    #[doc = "data value of mapping"]
    pub fn get_data(&self) -> Result<Iterable<'a, DataAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetelemAttrs::Data(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("SetelemAttrs", "Data"))
    }
    #[doc = "bitmask of nft_set_elem_flags"]
    pub fn get_flags(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetelemAttrs::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("SetelemAttrs", "Flags"))
    }
    #[doc = "timeout value"]
    pub fn get_timeout(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetelemAttrs::Timeout(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("SetelemAttrs", "Timeout"))
    }
    #[doc = "expiration time"]
    pub fn get_expiration(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetelemAttrs::Expiration(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("SetelemAttrs", "Expiration"))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetelemAttrs::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("SetelemAttrs", "Userdata"))
    }
    #[doc = "expression"]
    pub fn get_expr(&self) -> Result<Iterable<'a, ExprAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetelemAttrs::Expr(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("SetelemAttrs", "Expr"))
    }
    #[doc = "stateful object reference"]
    pub fn get_objref(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetelemAttrs::Objref(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("SetelemAttrs", "Objref"))
    }
    #[doc = "closing key value"]
    pub fn get_key_end(&self) -> Result<Iterable<'a, DataAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetelemAttrs::KeyEnd(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("SetelemAttrs", "KeyEnd"))
    }
    #[doc = "list of expressions"]
    pub fn get_expressions(&self) -> Result<Iterable<'a, ExprListAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetelemAttrs::Expressions(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("SetelemAttrs", "Expressions"))
    }
}
impl<'a> SetelemAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, SetelemAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Key",
            2u16 => "Data",
            3u16 => "Flags",
            4u16 => "Timeout",
            5u16 => "Expiration",
            6u16 => "Userdata",
            7u16 => "Expr",
            8u16 => "Objref",
            9u16 => "KeyEnd",
            10u16 => "Expressions",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, SetelemAttrs<'a>> {
    type Item = Result<SetelemAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => SetelemAttrs::Key({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => SetelemAttrs::Data({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => SetelemAttrs::Flags({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => SetelemAttrs::Timeout({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => SetelemAttrs::Expiration({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => SetelemAttrs::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => SetelemAttrs::Expr({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => SetelemAttrs::Objref({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => SetelemAttrs::KeyEnd({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => SetelemAttrs::Expressions({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "SetelemAttrs",
            r#type.and_then(|t| SetelemAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, SetelemAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("SetelemAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                SetelemAttrs::Key(val) => fmt.field("Key", &val),
                SetelemAttrs::Data(val) => fmt.field("Data", &val),
                SetelemAttrs::Flags(val) => fmt.field("Flags", &val),
                SetelemAttrs::Timeout(val) => fmt.field("Timeout", &val),
                SetelemAttrs::Expiration(val) => fmt.field("Expiration", &val),
                SetelemAttrs::Userdata(val) => fmt.field("Userdata", &val),
                SetelemAttrs::Expr(val) => fmt.field("Expr", &val),
                SetelemAttrs::Objref(val) => fmt.field("Objref", &val),
                SetelemAttrs::KeyEnd(val) => fmt.field("KeyEnd", &val),
                SetelemAttrs::Expressions(val) => fmt.field("Expressions", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, SetelemAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("SetelemAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| SetelemAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                SetelemAttrs::Key(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                SetelemAttrs::Data(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                SetelemAttrs::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                SetelemAttrs::Timeout(val) => {
                    if last_off == offset {
                        stack.push(("Timeout", last_off));
                        break;
                    }
                }
                SetelemAttrs::Expiration(val) => {
                    if last_off == offset {
                        stack.push(("Expiration", last_off));
                        break;
                    }
                }
                SetelemAttrs::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                SetelemAttrs::Expr(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                SetelemAttrs::Objref(val) => {
                    if last_off == offset {
                        stack.push(("Objref", last_off));
                        break;
                    }
                }
                SetelemAttrs::KeyEnd(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                SetelemAttrs::Expressions(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("SetelemAttrs", cur));
        }
        (stack, missing)
    }
}
#[doc = "Original name: \"setelem-list-elem-attrs\""]
#[derive(Clone)]
pub enum SetelemListElemAttrs<'a> {
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    Elem(Iterable<'a, SetelemAttrs<'a>>),
}
impl<'a> Iterable<'a, SetelemListElemAttrs<'a>> {
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn get_elem(
        &self,
    ) -> MultiAttrIterable<Self, SetelemListElemAttrs<'a>, Iterable<'a, SetelemAttrs<'a>>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let SetelemListElemAttrs::Elem(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
}
impl<'a> SetelemListElemAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, SetelemListElemAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Elem",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, SetelemListElemAttrs<'a>> {
    type Item = Result<SetelemListElemAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => SetelemListElemAttrs::Elem({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "SetelemListElemAttrs",
            r#type.and_then(|t| SetelemListElemAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, SetelemListElemAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("SetelemListElemAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                SetelemListElemAttrs::Elem(val) => fmt.field("Elem", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, SetelemListElemAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("SetelemListElemAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| SetelemListElemAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                SetelemListElemAttrs::Elem(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("SetelemListElemAttrs", cur));
        }
        (stack, missing)
    }
}
#[doc = "Original name: \"setelem-list-attrs\""]
#[derive(Clone)]
pub enum SetelemListAttrs<'a> {
    Table(&'a CStr),
    Set(&'a CStr),
    Elements(Iterable<'a, SetelemListElemAttrs<'a>>),
    SetId(u32),
}
impl<'a> Iterable<'a, SetelemListAttrs<'a>> {
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetelemListAttrs::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("SetelemListAttrs", "Table"))
    }
    pub fn get_set(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetelemListAttrs::Set(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("SetelemListAttrs", "Set"))
    }
    pub fn get_elements(&self) -> Result<Iterable<'a, SetelemListElemAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetelemListAttrs::Elements(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("SetelemListAttrs", "Elements"))
    }
    pub fn get_set_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetelemListAttrs::SetId(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("SetelemListAttrs", "SetId"))
    }
}
impl<'a> SetelemListAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, SetelemListAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Table",
            2u16 => "Set",
            3u16 => "Elements",
            4u16 => "SetId",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, SetelemListAttrs<'a>> {
    type Item = Result<SetelemListAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => SetelemListAttrs::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => SetelemListAttrs::Set({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => SetelemListAttrs::Elements({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => SetelemListAttrs::SetId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "SetelemListAttrs",
            r#type.and_then(|t| SetelemListAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, SetelemListAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("SetelemListAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                SetelemListAttrs::Table(val) => fmt.field("Table", &val),
                SetelemListAttrs::Set(val) => fmt.field("Set", &val),
                SetelemListAttrs::Elements(val) => fmt.field("Elements", &val),
                SetelemListAttrs::SetId(val) => fmt.field("SetId", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, SetelemListAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("SetelemListAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| SetelemListAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                SetelemListAttrs::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                SetelemListAttrs::Set(val) => {
                    if last_off == offset {
                        stack.push(("Set", last_off));
                        break;
                    }
                }
                SetelemListAttrs::Elements(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                SetelemListAttrs::SetId(val) => {
                    if last_off == offset {
                        stack.push(("SetId", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("SetelemListAttrs", cur));
        }
        (stack, missing)
    }
}
#[doc = "Original name: \"gen-attrs\""]
#[derive(Clone)]
pub enum GenAttrs<'a> {
    #[doc = "ruleset generation id"]
    Id(u32),
    ProcPid(u32),
    ProcName(&'a CStr),
}
impl<'a> Iterable<'a, GenAttrs<'a>> {
    #[doc = "ruleset generation id"]
    pub fn get_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let GenAttrs::Id(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("GenAttrs", "Id"))
    }
    pub fn get_proc_pid(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let GenAttrs::ProcPid(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("GenAttrs", "ProcPid"))
    }
    pub fn get_proc_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let GenAttrs::ProcName(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("GenAttrs", "ProcName"))
    }
}
impl<'a> GenAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, GenAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Id",
            2u16 => "ProcPid",
            3u16 => "ProcName",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, GenAttrs<'a>> {
    type Item = Result<GenAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => GenAttrs::Id({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => GenAttrs::ProcPid({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => GenAttrs::ProcName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "GenAttrs",
            r#type.and_then(|t| GenAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, GenAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("GenAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                GenAttrs::Id(val) => fmt.field("Id", &val),
                GenAttrs::ProcPid(val) => fmt.field("ProcPid", &val),
                GenAttrs::ProcName(val) => fmt.field("ProcName", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, GenAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("GenAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| GenAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                GenAttrs::Id(val) => {
                    if last_off == offset {
                        stack.push(("Id", last_off));
                        break;
                    }
                }
                GenAttrs::ProcPid(val) => {
                    if last_off == offset {
                        stack.push(("ProcPid", last_off));
                        break;
                    }
                }
                GenAttrs::ProcName(val) => {
                    if last_off == offset {
                        stack.push(("ProcName", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("GenAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"obj-attrs\""]
#[derive(Clone)]
pub enum ObjAttrs<'a> {
    #[doc = "name of the table containing the expression"]
    Table(&'a CStr),
    #[doc = "name of this expression type"]
    Name(&'a CStr),
    #[doc = "stateful object type\nAssociated type: \"ObjectType\" (enum)"]
    Type(u32),
    #[doc = "stateful object data"]
    Data(ObjData<'a>),
    #[doc = "number of references to this expression"]
    Use(u32),
    #[doc = "object handle"]
    Handle(u64),
    Pad(&'a [u8]),
    #[doc = "user data"]
    Userdata(&'a [u8]),
}
impl<'a> Iterable<'a, ObjAttrs<'a>> {
    #[doc = "name of the table containing the expression"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ObjAttrs::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ObjAttrs", "Table"))
    }
    #[doc = "name of this expression type"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ObjAttrs::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ObjAttrs", "Name"))
    }
    #[doc = "stateful object type\nAssociated type: \"ObjectType\" (enum)"]
    pub fn get_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ObjAttrs::Type(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ObjAttrs", "Type"))
    }
    #[doc = "stateful object data"]
    pub fn get_data(&self) -> Result<ObjData<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ObjAttrs::Data(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ObjAttrs", "Data"))
    }
    #[doc = "number of references to this expression"]
    pub fn get_use(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ObjAttrs::Use(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ObjAttrs", "Use"))
    }
    #[doc = "object handle"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ObjAttrs::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ObjAttrs", "Handle"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ObjAttrs::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ObjAttrs", "Pad"))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ObjAttrs::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ObjAttrs", "Userdata"))
    }
}
#[doc = "Original name: \"obj-data\""]
#[derive(Debug, Clone)]
pub enum ObjData<'a> {
    Counter(Iterable<'a, CounterAttrs<'a>>),
    Quota(Iterable<'a, QuotaAttrs<'a>>),
}
impl<'a> ObjData<'a> {
    fn select_with_loc(selector: u32, buf: &'a [u8], loc: usize) -> Option<Self> {
        match selector {
            val if val == ObjectType::Counter as u32 => {
                Some(ObjData::Counter(Iterable::with_loc(buf, loc)))
            }
            val if val == ObjectType::Quota as u32 => {
                Some(ObjData::Quota(Iterable::with_loc(buf, loc)))
            }
            _ => None,
        }
    }
}
impl<'a> ObjAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, ObjAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Table",
            2u16 => "Name",
            3u16 => "Type",
            4u16 => "Data",
            5u16 => "Use",
            6u16 => "Handle",
            7u16 => "Pad",
            8u16 => "Userdata",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, ObjAttrs<'a>> {
    type Item = Result<ObjAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => ObjAttrs::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => ObjAttrs::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => ObjAttrs::Type({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => ObjAttrs::Data({
                    let res = {
                        let Ok(selector) = self.get_type() else { break };
                        ObjData::select_with_loc(selector, next, self.orig_loc)
                    };
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => ObjAttrs::Use({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => ObjAttrs::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => ObjAttrs::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => ObjAttrs::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "ObjAttrs",
            r#type.and_then(|t| ObjAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, ObjAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("ObjAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                ObjAttrs::Table(val) => fmt.field("Table", &val),
                ObjAttrs::Name(val) => fmt.field("Name", &val),
                ObjAttrs::Type(val) => {
                    fmt.field("Type", &FormatEnum(val.into(), ObjectType::from_value))
                }
                ObjAttrs::Data(val) => fmt.field("Data", &val),
                ObjAttrs::Use(val) => fmt.field("Use", &val),
                ObjAttrs::Handle(val) => fmt.field("Handle", &val),
                ObjAttrs::Pad(val) => fmt.field("Pad", &val),
                ObjAttrs::Userdata(val) => fmt.field("Userdata", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, ObjAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("ObjAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| ObjAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                ObjAttrs::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                ObjAttrs::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                ObjAttrs::Type(val) => {
                    if last_off == offset {
                        stack.push(("Type", last_off));
                        break;
                    }
                }
                ObjAttrs::Data(val) => {
                    if last_off == offset {
                        stack.push(("Data", last_off));
                        break;
                    }
                }
                ObjAttrs::Use(val) => {
                    if last_off == offset {
                        stack.push(("Use", last_off));
                        break;
                    }
                }
                ObjAttrs::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                ObjAttrs::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                ObjAttrs::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("ObjAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"quota-attrs\""]
#[derive(Clone)]
pub enum QuotaAttrs<'a> {
    Bytes(u64),
    #[doc = "Associated type: \"QuotaFlags\" (enum)"]
    Flags(u32),
    Pad(&'a [u8]),
    Consumed(u64),
}
impl<'a> Iterable<'a, QuotaAttrs<'a>> {
    pub fn get_bytes(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let QuotaAttrs::Bytes(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("QuotaAttrs", "Bytes"))
    }
    #[doc = "Associated type: \"QuotaFlags\" (enum)"]
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let QuotaAttrs::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("QuotaAttrs", "Flags"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let QuotaAttrs::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("QuotaAttrs", "Pad"))
    }
    pub fn get_consumed(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let QuotaAttrs::Consumed(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("QuotaAttrs", "Consumed"))
    }
}
impl<'a> QuotaAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, QuotaAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Bytes",
            2u16 => "Flags",
            3u16 => "Pad",
            4u16 => "Consumed",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, QuotaAttrs<'a>> {
    type Item = Result<QuotaAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => QuotaAttrs::Bytes({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => QuotaAttrs::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => QuotaAttrs::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => QuotaAttrs::Consumed({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "QuotaAttrs",
            r#type.and_then(|t| QuotaAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, QuotaAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("QuotaAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                QuotaAttrs::Bytes(val) => fmt.field("Bytes", &val),
                QuotaAttrs::Flags(val) => {
                    fmt.field("Flags", &FormatFlags(val.into(), QuotaFlags::from_value))
                }
                QuotaAttrs::Pad(val) => fmt.field("Pad", &val),
                QuotaAttrs::Consumed(val) => fmt.field("Consumed", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, QuotaAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("QuotaAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| QuotaAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                QuotaAttrs::Bytes(val) => {
                    if last_off == offset {
                        stack.push(("Bytes", last_off));
                        break;
                    }
                }
                QuotaAttrs::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                QuotaAttrs::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                QuotaAttrs::Consumed(val) => {
                    if last_off == offset {
                        stack.push(("Consumed", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("QuotaAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"flowtable-attrs\""]
#[derive(Clone)]
pub enum FlowtableAttrs<'a> {
    Table(&'a CStr),
    Name(&'a CStr),
    Hook(Iterable<'a, FlowtableHookAttrs<'a>>),
    Use(u32),
    Handle(u64),
    Pad(&'a [u8]),
    Flags(u32),
}
impl<'a> Iterable<'a, FlowtableAttrs<'a>> {
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowtableAttrs::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowtableAttrs", "Table"))
    }
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowtableAttrs::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowtableAttrs", "Name"))
    }
    pub fn get_hook(&self) -> Result<Iterable<'a, FlowtableHookAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowtableAttrs::Hook(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowtableAttrs", "Hook"))
    }
    pub fn get_use(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowtableAttrs::Use(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowtableAttrs", "Use"))
    }
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowtableAttrs::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowtableAttrs", "Handle"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowtableAttrs::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowtableAttrs", "Pad"))
    }
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowtableAttrs::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowtableAttrs", "Flags"))
    }
}
impl<'a> FlowtableAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, FlowtableAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Table",
            2u16 => "Name",
            3u16 => "Hook",
            4u16 => "Use",
            5u16 => "Handle",
            6u16 => "Pad",
            7u16 => "Flags",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, FlowtableAttrs<'a>> {
    type Item = Result<FlowtableAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => FlowtableAttrs::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => FlowtableAttrs::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => FlowtableAttrs::Hook({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => FlowtableAttrs::Use({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => FlowtableAttrs::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => FlowtableAttrs::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => FlowtableAttrs::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "FlowtableAttrs",
            r#type.and_then(|t| FlowtableAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, FlowtableAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("FlowtableAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                FlowtableAttrs::Table(val) => fmt.field("Table", &val),
                FlowtableAttrs::Name(val) => fmt.field("Name", &val),
                FlowtableAttrs::Hook(val) => fmt.field("Hook", &val),
                FlowtableAttrs::Use(val) => fmt.field("Use", &val),
                FlowtableAttrs::Handle(val) => fmt.field("Handle", &val),
                FlowtableAttrs::Pad(val) => fmt.field("Pad", &val),
                FlowtableAttrs::Flags(val) => fmt.field("Flags", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, FlowtableAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("FlowtableAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| FlowtableAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                FlowtableAttrs::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                FlowtableAttrs::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                FlowtableAttrs::Hook(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                FlowtableAttrs::Use(val) => {
                    if last_off == offset {
                        stack.push(("Use", last_off));
                        break;
                    }
                }
                FlowtableAttrs::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                FlowtableAttrs::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                FlowtableAttrs::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("FlowtableAttrs", cur));
        }
        (stack, missing)
    }
}
#[doc = "Original name: \"flowtable-hook-attrs\""]
#[derive(Clone)]
pub enum FlowtableHookAttrs<'a> {
    Num(u32),
    Priority(u32),
    Devs(Iterable<'a, HookDevAttrs<'a>>),
}
impl<'a> Iterable<'a, FlowtableHookAttrs<'a>> {
    pub fn get_num(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowtableHookAttrs::Num(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowtableHookAttrs", "Num"))
    }
    pub fn get_priority(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowtableHookAttrs::Priority(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowtableHookAttrs", "Priority"))
    }
    pub fn get_devs(&self) -> Result<Iterable<'a, HookDevAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowtableHookAttrs::Devs(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowtableHookAttrs", "Devs"))
    }
}
impl<'a> FlowtableHookAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, FlowtableHookAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Num",
            2u16 => "Priority",
            3u16 => "Devs",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, FlowtableHookAttrs<'a>> {
    type Item = Result<FlowtableHookAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => FlowtableHookAttrs::Num({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => FlowtableHookAttrs::Priority({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => FlowtableHookAttrs::Devs({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "FlowtableHookAttrs",
            r#type.and_then(|t| FlowtableHookAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, FlowtableHookAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("FlowtableHookAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                FlowtableHookAttrs::Num(val) => fmt.field("Num", &val),
                FlowtableHookAttrs::Priority(val) => fmt.field("Priority", &val),
                FlowtableHookAttrs::Devs(val) => fmt.field("Devs", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, FlowtableHookAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("FlowtableHookAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| FlowtableHookAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                FlowtableHookAttrs::Num(val) => {
                    if last_off == offset {
                        stack.push(("Num", last_off));
                        break;
                    }
                }
                FlowtableHookAttrs::Priority(val) => {
                    if last_off == offset {
                        stack.push(("Priority", last_off));
                        break;
                    }
                }
                FlowtableHookAttrs::Devs(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("FlowtableHookAttrs", cur));
        }
        (stack, missing)
    }
}
#[doc = "Original name: \"expr-bitwise-attrs\""]
#[derive(Clone)]
pub enum ExprBitwiseAttrs<'a> {
    Sreg(u32),
    Dreg(u32),
    Len(u32),
    Mask(Iterable<'a, DataAttrs<'a>>),
    Xor(Iterable<'a, DataAttrs<'a>>),
    #[doc = "Associated type: \"BitwiseOps\" (enum)"]
    Op(u32),
    Data(Iterable<'a, DataAttrs<'a>>),
}
impl<'a> Iterable<'a, ExprBitwiseAttrs<'a>> {
    pub fn get_sreg(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprBitwiseAttrs::Sreg(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprBitwiseAttrs", "Sreg"))
    }
    pub fn get_dreg(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprBitwiseAttrs::Dreg(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprBitwiseAttrs", "Dreg"))
    }
    pub fn get_len(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprBitwiseAttrs::Len(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprBitwiseAttrs", "Len"))
    }
    pub fn get_mask(&self) -> Result<Iterable<'a, DataAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprBitwiseAttrs::Mask(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprBitwiseAttrs", "Mask"))
    }
    pub fn get_xor(&self) -> Result<Iterable<'a, DataAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprBitwiseAttrs::Xor(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprBitwiseAttrs", "Xor"))
    }
    #[doc = "Associated type: \"BitwiseOps\" (enum)"]
    pub fn get_op(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprBitwiseAttrs::Op(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprBitwiseAttrs", "Op"))
    }
    pub fn get_data(&self) -> Result<Iterable<'a, DataAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprBitwiseAttrs::Data(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprBitwiseAttrs", "Data"))
    }
}
impl<'a> ExprBitwiseAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, ExprBitwiseAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Sreg",
            2u16 => "Dreg",
            3u16 => "Len",
            4u16 => "Mask",
            5u16 => "Xor",
            6u16 => "Op",
            7u16 => "Data",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, ExprBitwiseAttrs<'a>> {
    type Item = Result<ExprBitwiseAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => ExprBitwiseAttrs::Sreg({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => ExprBitwiseAttrs::Dreg({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => ExprBitwiseAttrs::Len({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => ExprBitwiseAttrs::Mask({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => ExprBitwiseAttrs::Xor({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => ExprBitwiseAttrs::Op({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => ExprBitwiseAttrs::Data({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "ExprBitwiseAttrs",
            r#type.and_then(|t| ExprBitwiseAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, ExprBitwiseAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("ExprBitwiseAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                ExprBitwiseAttrs::Sreg(val) => fmt.field("Sreg", &val),
                ExprBitwiseAttrs::Dreg(val) => fmt.field("Dreg", &val),
                ExprBitwiseAttrs::Len(val) => fmt.field("Len", &val),
                ExprBitwiseAttrs::Mask(val) => fmt.field("Mask", &val),
                ExprBitwiseAttrs::Xor(val) => fmt.field("Xor", &val),
                ExprBitwiseAttrs::Op(val) => {
                    fmt.field("Op", &FormatEnum(val.into(), BitwiseOps::from_value))
                }
                ExprBitwiseAttrs::Data(val) => fmt.field("Data", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, ExprBitwiseAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("ExprBitwiseAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| ExprBitwiseAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                ExprBitwiseAttrs::Sreg(val) => {
                    if last_off == offset {
                        stack.push(("Sreg", last_off));
                        break;
                    }
                }
                ExprBitwiseAttrs::Dreg(val) => {
                    if last_off == offset {
                        stack.push(("Dreg", last_off));
                        break;
                    }
                }
                ExprBitwiseAttrs::Len(val) => {
                    if last_off == offset {
                        stack.push(("Len", last_off));
                        break;
                    }
                }
                ExprBitwiseAttrs::Mask(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                ExprBitwiseAttrs::Xor(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                ExprBitwiseAttrs::Op(val) => {
                    if last_off == offset {
                        stack.push(("Op", last_off));
                        break;
                    }
                }
                ExprBitwiseAttrs::Data(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("ExprBitwiseAttrs", cur));
        }
        (stack, missing)
    }
}
#[doc = "Original name: \"expr-cmp-attrs\""]
#[derive(Clone)]
pub enum ExprCmpAttrs<'a> {
    Sreg(u32),
    #[doc = "Associated type: \"CmpOps\" (enum)"]
    Op(u32),
    Data(Iterable<'a, DataAttrs<'a>>),
}
impl<'a> Iterable<'a, ExprCmpAttrs<'a>> {
    pub fn get_sreg(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprCmpAttrs::Sreg(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprCmpAttrs", "Sreg"))
    }
    #[doc = "Associated type: \"CmpOps\" (enum)"]
    pub fn get_op(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprCmpAttrs::Op(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprCmpAttrs", "Op"))
    }
    pub fn get_data(&self) -> Result<Iterable<'a, DataAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprCmpAttrs::Data(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprCmpAttrs", "Data"))
    }
}
impl<'a> ExprCmpAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, ExprCmpAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Sreg",
            2u16 => "Op",
            3u16 => "Data",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, ExprCmpAttrs<'a>> {
    type Item = Result<ExprCmpAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => ExprCmpAttrs::Sreg({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => ExprCmpAttrs::Op({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => ExprCmpAttrs::Data({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "ExprCmpAttrs",
            r#type.and_then(|t| ExprCmpAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, ExprCmpAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("ExprCmpAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                ExprCmpAttrs::Sreg(val) => fmt.field("Sreg", &val),
                ExprCmpAttrs::Op(val) => {
                    fmt.field("Op", &FormatEnum(val.into(), CmpOps::from_value))
                }
                ExprCmpAttrs::Data(val) => fmt.field("Data", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, ExprCmpAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("ExprCmpAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| ExprCmpAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                ExprCmpAttrs::Sreg(val) => {
                    if last_off == offset {
                        stack.push(("Sreg", last_off));
                        break;
                    }
                }
                ExprCmpAttrs::Op(val) => {
                    if last_off == offset {
                        stack.push(("Op", last_off));
                        break;
                    }
                }
                ExprCmpAttrs::Data(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("ExprCmpAttrs", cur));
        }
        (stack, missing)
    }
}
#[doc = "Original name: \"data-attrs\""]
#[derive(Clone)]
pub enum DataAttrs<'a> {
    Value(&'a [u8]),
    Verdict(Iterable<'a, VerdictAttrs<'a>>),
}
impl<'a> Iterable<'a, DataAttrs<'a>> {
    pub fn get_value(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DataAttrs::Value(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("DataAttrs", "Value"))
    }
    pub fn get_verdict(&self) -> Result<Iterable<'a, VerdictAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DataAttrs::Verdict(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("DataAttrs", "Verdict"))
    }
}
impl<'a> DataAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, DataAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Value",
            2u16 => "Verdict",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, DataAttrs<'a>> {
    type Item = Result<DataAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => DataAttrs::Value({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => DataAttrs::Verdict({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "DataAttrs",
            r#type.and_then(|t| DataAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, DataAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("DataAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                DataAttrs::Value(val) => fmt.field("Value", &val),
                DataAttrs::Verdict(val) => fmt.field("Verdict", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, DataAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("DataAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| DataAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                DataAttrs::Value(val) => {
                    if last_off == offset {
                        stack.push(("Value", last_off));
                        break;
                    }
                }
                DataAttrs::Verdict(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("DataAttrs", cur));
        }
        (stack, missing)
    }
}
#[doc = "Original name: \"verdict-attrs\""]
#[derive(Clone)]
pub enum VerdictAttrs<'a> {
    #[doc = "nf_tables verdict\nAssociated type: \"VerdictCode\" (enum)"]
    Code(u32),
    #[doc = "jump target chain name"]
    Chain(&'a CStr),
    #[doc = "jump target chain ID"]
    ChainId(u32),
}
impl<'a> Iterable<'a, VerdictAttrs<'a>> {
    #[doc = "nf_tables verdict\nAssociated type: \"VerdictCode\" (enum)"]
    pub fn get_code(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let VerdictAttrs::Code(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("VerdictAttrs", "Code"))
    }
    #[doc = "jump target chain name"]
    pub fn get_chain(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let VerdictAttrs::Chain(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("VerdictAttrs", "Chain"))
    }
    #[doc = "jump target chain ID"]
    pub fn get_chain_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let VerdictAttrs::ChainId(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("VerdictAttrs", "ChainId"))
    }
}
impl<'a> VerdictAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, VerdictAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Code",
            2u16 => "Chain",
            3u16 => "ChainId",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, VerdictAttrs<'a>> {
    type Item = Result<VerdictAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => VerdictAttrs::Code({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => VerdictAttrs::Chain({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => VerdictAttrs::ChainId({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "VerdictAttrs",
            r#type.and_then(|t| VerdictAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, VerdictAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("VerdictAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                VerdictAttrs::Code(val) => {
                    fmt.field("Code", &FormatEnum(val.into(), VerdictCode::from_value))
                }
                VerdictAttrs::Chain(val) => fmt.field("Chain", &val),
                VerdictAttrs::ChainId(val) => fmt.field("ChainId", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, VerdictAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("VerdictAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| VerdictAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                VerdictAttrs::Code(val) => {
                    if last_off == offset {
                        stack.push(("Code", last_off));
                        break;
                    }
                }
                VerdictAttrs::Chain(val) => {
                    if last_off == offset {
                        stack.push(("Chain", last_off));
                        break;
                    }
                }
                VerdictAttrs::ChainId(val) => {
                    if last_off == offset {
                        stack.push(("ChainId", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("VerdictAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"expr-counter-attrs\""]
#[derive(Clone)]
pub enum ExprCounterAttrs<'a> {
    #[doc = "Number of bytes"]
    Bytes(u64),
    #[doc = "Number of packets"]
    Packets(u64),
    Pad(&'a [u8]),
}
impl<'a> Iterable<'a, ExprCounterAttrs<'a>> {
    #[doc = "Number of bytes"]
    pub fn get_bytes(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprCounterAttrs::Bytes(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprCounterAttrs", "Bytes"))
    }
    #[doc = "Number of packets"]
    pub fn get_packets(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprCounterAttrs::Packets(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprCounterAttrs", "Packets"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprCounterAttrs::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprCounterAttrs", "Pad"))
    }
}
impl<'a> ExprCounterAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, ExprCounterAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Bytes",
            2u16 => "Packets",
            3u16 => "Pad",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, ExprCounterAttrs<'a>> {
    type Item = Result<ExprCounterAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => ExprCounterAttrs::Bytes({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => ExprCounterAttrs::Packets({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => ExprCounterAttrs::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "ExprCounterAttrs",
            r#type.and_then(|t| ExprCounterAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, ExprCounterAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("ExprCounterAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                ExprCounterAttrs::Bytes(val) => fmt.field("Bytes", &val),
                ExprCounterAttrs::Packets(val) => fmt.field("Packets", &val),
                ExprCounterAttrs::Pad(val) => fmt.field("Pad", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, ExprCounterAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("ExprCounterAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| ExprCounterAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                ExprCounterAttrs::Bytes(val) => {
                    if last_off == offset {
                        stack.push(("Bytes", last_off));
                        break;
                    }
                }
                ExprCounterAttrs::Packets(val) => {
                    if last_off == offset {
                        stack.push(("Packets", last_off));
                        break;
                    }
                }
                ExprCounterAttrs::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("ExprCounterAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"expr-fib-attrs\""]
#[derive(Clone)]
pub enum ExprFibAttrs {
    Dreg(u32),
    #[doc = "Associated type: \"FibResult\" (enum)"]
    Result(u32),
    #[doc = "Associated type: \"FibFlags\" (enum)"]
    Flags(u32),
}
impl<'a> Iterable<'a, ExprFibAttrs> {
    pub fn get_dreg(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprFibAttrs::Dreg(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprFibAttrs", "Dreg"))
    }
    #[doc = "Associated type: \"FibResult\" (enum)"]
    pub fn get_result(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprFibAttrs::Result(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprFibAttrs", "Result"))
    }
    #[doc = "Associated type: \"FibFlags\" (enum)"]
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprFibAttrs::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprFibAttrs", "Flags"))
    }
}
impl ExprFibAttrs {
    pub fn new(buf: &'_ [u8]) -> Iterable<'_, ExprFibAttrs> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Dreg",
            2u16 => "Result",
            3u16 => "Flags",
            _ => return None,
        };
        Some(res)
    }
}
impl Iterator for Iterable<'_, ExprFibAttrs> {
    type Item = Result<ExprFibAttrs, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => ExprFibAttrs::Dreg({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => ExprFibAttrs::Result({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => ExprFibAttrs::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "ExprFibAttrs",
            r#type.and_then(|t| ExprFibAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl std::fmt::Debug for Iterable<'_, ExprFibAttrs> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("ExprFibAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                ExprFibAttrs::Dreg(val) => fmt.field("Dreg", &val),
                ExprFibAttrs::Result(val) => {
                    fmt.field("Result", &FormatEnum(val.into(), FibResult::from_value))
                }
                ExprFibAttrs::Flags(val) => {
                    fmt.field("Flags", &FormatFlags(val.into(), FibFlags::from_value))
                }
            };
        }
        fmt.finish()
    }
}
impl Iterable<'_, ExprFibAttrs> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("ExprFibAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| ExprFibAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                ExprFibAttrs::Dreg(val) => {
                    if last_off == offset {
                        stack.push(("Dreg", last_off));
                        break;
                    }
                }
                ExprFibAttrs::Result(val) => {
                    if last_off == offset {
                        stack.push(("Result", last_off));
                        break;
                    }
                }
                ExprFibAttrs::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("ExprFibAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"expr-ct-attrs\""]
#[derive(Clone)]
pub enum ExprCtAttrs {
    Dreg(u32),
    #[doc = "Associated type: \"CtKeys\" (enum)"]
    Key(u32),
    #[doc = "Associated type: \"CtDirection\" (enum)"]
    Direction(u8),
    Sreg(u32),
}
impl<'a> Iterable<'a, ExprCtAttrs> {
    pub fn get_dreg(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprCtAttrs::Dreg(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprCtAttrs", "Dreg"))
    }
    #[doc = "Associated type: \"CtKeys\" (enum)"]
    pub fn get_key(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprCtAttrs::Key(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprCtAttrs", "Key"))
    }
    #[doc = "Associated type: \"CtDirection\" (enum)"]
    pub fn get_direction(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprCtAttrs::Direction(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprCtAttrs", "Direction"))
    }
    pub fn get_sreg(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprCtAttrs::Sreg(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprCtAttrs", "Sreg"))
    }
}
impl ExprCtAttrs {
    pub fn new(buf: &'_ [u8]) -> Iterable<'_, ExprCtAttrs> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Dreg",
            2u16 => "Key",
            3u16 => "Direction",
            4u16 => "Sreg",
            _ => return None,
        };
        Some(res)
    }
}
impl Iterator for Iterable<'_, ExprCtAttrs> {
    type Item = Result<ExprCtAttrs, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => ExprCtAttrs::Dreg({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => ExprCtAttrs::Key({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => ExprCtAttrs::Direction({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => ExprCtAttrs::Sreg({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "ExprCtAttrs",
            r#type.and_then(|t| ExprCtAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl std::fmt::Debug for Iterable<'_, ExprCtAttrs> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("ExprCtAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                ExprCtAttrs::Dreg(val) => fmt.field("Dreg", &val),
                ExprCtAttrs::Key(val) => {
                    fmt.field("Key", &FormatEnum(val.into(), CtKeys::from_value))
                }
                ExprCtAttrs::Direction(val) => fmt.field(
                    "Direction",
                    &FormatEnum(val.into(), CtDirection::from_value),
                ),
                ExprCtAttrs::Sreg(val) => fmt.field("Sreg", &val),
            };
        }
        fmt.finish()
    }
}
impl Iterable<'_, ExprCtAttrs> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("ExprCtAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| ExprCtAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                ExprCtAttrs::Dreg(val) => {
                    if last_off == offset {
                        stack.push(("Dreg", last_off));
                        break;
                    }
                }
                ExprCtAttrs::Key(val) => {
                    if last_off == offset {
                        stack.push(("Key", last_off));
                        break;
                    }
                }
                ExprCtAttrs::Direction(val) => {
                    if last_off == offset {
                        stack.push(("Direction", last_off));
                        break;
                    }
                }
                ExprCtAttrs::Sreg(val) => {
                    if last_off == offset {
                        stack.push(("Sreg", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("ExprCtAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"expr-flow-offload-attrs\""]
#[derive(Clone)]
pub enum ExprFlowOffloadAttrs<'a> {
    #[doc = "Flow offload table name"]
    Name(&'a CStr),
}
impl<'a> Iterable<'a, ExprFlowOffloadAttrs<'a>> {
    #[doc = "Flow offload table name"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprFlowOffloadAttrs::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprFlowOffloadAttrs", "Name"))
    }
}
impl<'a> ExprFlowOffloadAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, ExprFlowOffloadAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Name",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, ExprFlowOffloadAttrs<'a>> {
    type Item = Result<ExprFlowOffloadAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => ExprFlowOffloadAttrs::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "ExprFlowOffloadAttrs",
            r#type.and_then(|t| ExprFlowOffloadAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, ExprFlowOffloadAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("ExprFlowOffloadAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                ExprFlowOffloadAttrs::Name(val) => fmt.field("Name", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, ExprFlowOffloadAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("ExprFlowOffloadAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| ExprFlowOffloadAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                ExprFlowOffloadAttrs::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("ExprFlowOffloadAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"expr-immediate-attrs\""]
#[derive(Clone)]
pub enum ExprImmediateAttrs<'a> {
    Dreg(u32),
    Data(Iterable<'a, DataAttrs<'a>>),
}
impl<'a> Iterable<'a, ExprImmediateAttrs<'a>> {
    pub fn get_dreg(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprImmediateAttrs::Dreg(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprImmediateAttrs", "Dreg"))
    }
    pub fn get_data(&self) -> Result<Iterable<'a, DataAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprImmediateAttrs::Data(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprImmediateAttrs", "Data"))
    }
}
impl<'a> ExprImmediateAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, ExprImmediateAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Dreg",
            2u16 => "Data",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, ExprImmediateAttrs<'a>> {
    type Item = Result<ExprImmediateAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => ExprImmediateAttrs::Dreg({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => ExprImmediateAttrs::Data({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "ExprImmediateAttrs",
            r#type.and_then(|t| ExprImmediateAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, ExprImmediateAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("ExprImmediateAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                ExprImmediateAttrs::Dreg(val) => fmt.field("Dreg", &val),
                ExprImmediateAttrs::Data(val) => fmt.field("Data", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, ExprImmediateAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("ExprImmediateAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| ExprImmediateAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                ExprImmediateAttrs::Dreg(val) => {
                    if last_off == offset {
                        stack.push(("Dreg", last_off));
                        break;
                    }
                }
                ExprImmediateAttrs::Data(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("ExprImmediateAttrs", cur));
        }
        (stack, missing)
    }
}
#[doc = "Original name: \"expr-lookup-attrs\""]
#[derive(Clone)]
pub enum ExprLookupAttrs<'a> {
    #[doc = "Name of set to use"]
    Set(&'a CStr),
    #[doc = "ID of set to use"]
    SetId(u32),
    Sreg(u32),
    Dreg(u32),
    #[doc = "Associated type: \"LookupFlags\" (enum)"]
    Flags(u32),
}
impl<'a> Iterable<'a, ExprLookupAttrs<'a>> {
    #[doc = "Name of set to use"]
    pub fn get_set(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprLookupAttrs::Set(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprLookupAttrs", "Set"))
    }
    #[doc = "ID of set to use"]
    pub fn get_set_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprLookupAttrs::SetId(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprLookupAttrs", "SetId"))
    }
    pub fn get_sreg(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprLookupAttrs::Sreg(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprLookupAttrs", "Sreg"))
    }
    pub fn get_dreg(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprLookupAttrs::Dreg(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprLookupAttrs", "Dreg"))
    }
    #[doc = "Associated type: \"LookupFlags\" (enum)"]
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprLookupAttrs::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprLookupAttrs", "Flags"))
    }
}
impl<'a> ExprLookupAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, ExprLookupAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Set",
            2u16 => "SetId",
            3u16 => "Sreg",
            4u16 => "Dreg",
            5u16 => "Flags",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, ExprLookupAttrs<'a>> {
    type Item = Result<ExprLookupAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => ExprLookupAttrs::Set({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => ExprLookupAttrs::SetId({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => ExprLookupAttrs::Sreg({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => ExprLookupAttrs::Dreg({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => ExprLookupAttrs::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "ExprLookupAttrs",
            r#type.and_then(|t| ExprLookupAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, ExprLookupAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("ExprLookupAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                ExprLookupAttrs::Set(val) => fmt.field("Set", &val),
                ExprLookupAttrs::SetId(val) => fmt.field("SetId", &val),
                ExprLookupAttrs::Sreg(val) => fmt.field("Sreg", &val),
                ExprLookupAttrs::Dreg(val) => fmt.field("Dreg", &val),
                ExprLookupAttrs::Flags(val) => {
                    fmt.field("Flags", &FormatFlags(val.into(), LookupFlags::from_value))
                }
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, ExprLookupAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("ExprLookupAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| ExprLookupAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                ExprLookupAttrs::Set(val) => {
                    if last_off == offset {
                        stack.push(("Set", last_off));
                        break;
                    }
                }
                ExprLookupAttrs::SetId(val) => {
                    if last_off == offset {
                        stack.push(("SetId", last_off));
                        break;
                    }
                }
                ExprLookupAttrs::Sreg(val) => {
                    if last_off == offset {
                        stack.push(("Sreg", last_off));
                        break;
                    }
                }
                ExprLookupAttrs::Dreg(val) => {
                    if last_off == offset {
                        stack.push(("Dreg", last_off));
                        break;
                    }
                }
                ExprLookupAttrs::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("ExprLookupAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"expr-meta-attrs\""]
#[derive(Clone)]
pub enum ExprMetaAttrs {
    Dreg(u32),
    #[doc = "Associated type: \"MetaKeys\" (enum)"]
    Key(u32),
    Sreg(u32),
}
impl<'a> Iterable<'a, ExprMetaAttrs> {
    pub fn get_dreg(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprMetaAttrs::Dreg(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprMetaAttrs", "Dreg"))
    }
    #[doc = "Associated type: \"MetaKeys\" (enum)"]
    pub fn get_key(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprMetaAttrs::Key(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprMetaAttrs", "Key"))
    }
    pub fn get_sreg(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprMetaAttrs::Sreg(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprMetaAttrs", "Sreg"))
    }
}
impl ExprMetaAttrs {
    pub fn new(buf: &'_ [u8]) -> Iterable<'_, ExprMetaAttrs> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Dreg",
            2u16 => "Key",
            3u16 => "Sreg",
            _ => return None,
        };
        Some(res)
    }
}
impl Iterator for Iterable<'_, ExprMetaAttrs> {
    type Item = Result<ExprMetaAttrs, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => ExprMetaAttrs::Dreg({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => ExprMetaAttrs::Key({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => ExprMetaAttrs::Sreg({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "ExprMetaAttrs",
            r#type.and_then(|t| ExprMetaAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl std::fmt::Debug for Iterable<'_, ExprMetaAttrs> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("ExprMetaAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                ExprMetaAttrs::Dreg(val) => fmt.field("Dreg", &val),
                ExprMetaAttrs::Key(val) => {
                    fmt.field("Key", &FormatEnum(val.into(), MetaKeys::from_value))
                }
                ExprMetaAttrs::Sreg(val) => fmt.field("Sreg", &val),
            };
        }
        fmt.finish()
    }
}
impl Iterable<'_, ExprMetaAttrs> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("ExprMetaAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| ExprMetaAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                ExprMetaAttrs::Dreg(val) => {
                    if last_off == offset {
                        stack.push(("Dreg", last_off));
                        break;
                    }
                }
                ExprMetaAttrs::Key(val) => {
                    if last_off == offset {
                        stack.push(("Key", last_off));
                        break;
                    }
                }
                ExprMetaAttrs::Sreg(val) => {
                    if last_off == offset {
                        stack.push(("Sreg", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("ExprMetaAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"expr-nat-attrs\""]
#[derive(Clone)]
pub enum ExprNatAttrs {
    Type(u32),
    Family(u32),
    RegAddrMin(u32),
    RegAddrMax(u32),
    RegProtoMin(u32),
    RegProtoMax(u32),
    #[doc = "Associated type: \"NatRangeFlags\" (1 bit per enumeration)"]
    Flags(u32),
}
impl<'a> Iterable<'a, ExprNatAttrs> {
    pub fn get_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprNatAttrs::Type(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprNatAttrs", "Type"))
    }
    pub fn get_family(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprNatAttrs::Family(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprNatAttrs", "Family"))
    }
    pub fn get_reg_addr_min(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprNatAttrs::RegAddrMin(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprNatAttrs", "RegAddrMin"))
    }
    pub fn get_reg_addr_max(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprNatAttrs::RegAddrMax(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprNatAttrs", "RegAddrMax"))
    }
    pub fn get_reg_proto_min(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprNatAttrs::RegProtoMin(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprNatAttrs", "RegProtoMin"))
    }
    pub fn get_reg_proto_max(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprNatAttrs::RegProtoMax(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprNatAttrs", "RegProtoMax"))
    }
    #[doc = "Associated type: \"NatRangeFlags\" (1 bit per enumeration)"]
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprNatAttrs::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprNatAttrs", "Flags"))
    }
}
impl ExprNatAttrs {
    pub fn new(buf: &'_ [u8]) -> Iterable<'_, ExprNatAttrs> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Type",
            2u16 => "Family",
            3u16 => "RegAddrMin",
            4u16 => "RegAddrMax",
            5u16 => "RegProtoMin",
            6u16 => "RegProtoMax",
            7u16 => "Flags",
            _ => return None,
        };
        Some(res)
    }
}
impl Iterator for Iterable<'_, ExprNatAttrs> {
    type Item = Result<ExprNatAttrs, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => ExprNatAttrs::Type({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => ExprNatAttrs::Family({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => ExprNatAttrs::RegAddrMin({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => ExprNatAttrs::RegAddrMax({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => ExprNatAttrs::RegProtoMin({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => ExprNatAttrs::RegProtoMax({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => ExprNatAttrs::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "ExprNatAttrs",
            r#type.and_then(|t| ExprNatAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl std::fmt::Debug for Iterable<'_, ExprNatAttrs> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("ExprNatAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                ExprNatAttrs::Type(val) => fmt.field("Type", &val),
                ExprNatAttrs::Family(val) => fmt.field("Family", &val),
                ExprNatAttrs::RegAddrMin(val) => fmt.field("RegAddrMin", &val),
                ExprNatAttrs::RegAddrMax(val) => fmt.field("RegAddrMax", &val),
                ExprNatAttrs::RegProtoMin(val) => fmt.field("RegProtoMin", &val),
                ExprNatAttrs::RegProtoMax(val) => fmt.field("RegProtoMax", &val),
                ExprNatAttrs::Flags(val) => {
                    fmt.field("Flags", &FormatFlags(val.into(), NatRangeFlags::from_value))
                }
            };
        }
        fmt.finish()
    }
}
impl Iterable<'_, ExprNatAttrs> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("ExprNatAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| ExprNatAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                ExprNatAttrs::Type(val) => {
                    if last_off == offset {
                        stack.push(("Type", last_off));
                        break;
                    }
                }
                ExprNatAttrs::Family(val) => {
                    if last_off == offset {
                        stack.push(("Family", last_off));
                        break;
                    }
                }
                ExprNatAttrs::RegAddrMin(val) => {
                    if last_off == offset {
                        stack.push(("RegAddrMin", last_off));
                        break;
                    }
                }
                ExprNatAttrs::RegAddrMax(val) => {
                    if last_off == offset {
                        stack.push(("RegAddrMax", last_off));
                        break;
                    }
                }
                ExprNatAttrs::RegProtoMin(val) => {
                    if last_off == offset {
                        stack.push(("RegProtoMin", last_off));
                        break;
                    }
                }
                ExprNatAttrs::RegProtoMax(val) => {
                    if last_off == offset {
                        stack.push(("RegProtoMax", last_off));
                        break;
                    }
                }
                ExprNatAttrs::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("ExprNatAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"expr-payload-attrs\""]
#[derive(Clone)]
pub enum ExprPayloadAttrs {
    #[doc = "destination register to load data into\nAssociated type: \"Registers\" (enum)"]
    Dreg(u32),
    #[doc = "payload base\nAssociated type: \"PayloadBase\" (enum)"]
    Base(u32),
    #[doc = "payload offset relative to base"]
    Offset(u32),
    #[doc = "payload length"]
    Len(u32),
    #[doc = "source register to load data from\nAssociated type: \"Registers\" (enum)"]
    Sreg(u32),
    #[doc = "checksum type"]
    CsumType(u32),
    #[doc = "checksum offset relative to base"]
    CsumOffset(u32),
    #[doc = "checksum flags"]
    CsumFlags(u32),
}
impl<'a> Iterable<'a, ExprPayloadAttrs> {
    #[doc = "destination register to load data into\nAssociated type: \"Registers\" (enum)"]
    pub fn get_dreg(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprPayloadAttrs::Dreg(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprPayloadAttrs", "Dreg"))
    }
    #[doc = "payload base\nAssociated type: \"PayloadBase\" (enum)"]
    pub fn get_base(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprPayloadAttrs::Base(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprPayloadAttrs", "Base"))
    }
    #[doc = "payload offset relative to base"]
    pub fn get_offset(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprPayloadAttrs::Offset(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprPayloadAttrs", "Offset"))
    }
    #[doc = "payload length"]
    pub fn get_len(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprPayloadAttrs::Len(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprPayloadAttrs", "Len"))
    }
    #[doc = "source register to load data from\nAssociated type: \"Registers\" (enum)"]
    pub fn get_sreg(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprPayloadAttrs::Sreg(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprPayloadAttrs", "Sreg"))
    }
    #[doc = "checksum type"]
    pub fn get_csum_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprPayloadAttrs::CsumType(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprPayloadAttrs", "CsumType"))
    }
    #[doc = "checksum offset relative to base"]
    pub fn get_csum_offset(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprPayloadAttrs::CsumOffset(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprPayloadAttrs", "CsumOffset"))
    }
    #[doc = "checksum flags"]
    pub fn get_csum_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprPayloadAttrs::CsumFlags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprPayloadAttrs", "CsumFlags"))
    }
}
impl ExprPayloadAttrs {
    pub fn new(buf: &'_ [u8]) -> Iterable<'_, ExprPayloadAttrs> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Dreg",
            2u16 => "Base",
            3u16 => "Offset",
            4u16 => "Len",
            5u16 => "Sreg",
            6u16 => "CsumType",
            7u16 => "CsumOffset",
            8u16 => "CsumFlags",
            _ => return None,
        };
        Some(res)
    }
}
impl Iterator for Iterable<'_, ExprPayloadAttrs> {
    type Item = Result<ExprPayloadAttrs, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => ExprPayloadAttrs::Dreg({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => ExprPayloadAttrs::Base({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => ExprPayloadAttrs::Offset({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => ExprPayloadAttrs::Len({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => ExprPayloadAttrs::Sreg({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => ExprPayloadAttrs::CsumType({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => ExprPayloadAttrs::CsumOffset({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => ExprPayloadAttrs::CsumFlags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "ExprPayloadAttrs",
            r#type.and_then(|t| ExprPayloadAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl std::fmt::Debug for Iterable<'_, ExprPayloadAttrs> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("ExprPayloadAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                ExprPayloadAttrs::Dreg(val) => {
                    fmt.field("Dreg", &FormatEnum(val.into(), Registers::from_value))
                }
                ExprPayloadAttrs::Base(val) => {
                    fmt.field("Base", &FormatEnum(val.into(), PayloadBase::from_value))
                }
                ExprPayloadAttrs::Offset(val) => fmt.field("Offset", &val),
                ExprPayloadAttrs::Len(val) => fmt.field("Len", &val),
                ExprPayloadAttrs::Sreg(val) => {
                    fmt.field("Sreg", &FormatEnum(val.into(), Registers::from_value))
                }
                ExprPayloadAttrs::CsumType(val) => fmt.field("CsumType", &val),
                ExprPayloadAttrs::CsumOffset(val) => fmt.field("CsumOffset", &val),
                ExprPayloadAttrs::CsumFlags(val) => fmt.field("CsumFlags", &val),
            };
        }
        fmt.finish()
    }
}
impl Iterable<'_, ExprPayloadAttrs> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("ExprPayloadAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| ExprPayloadAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                ExprPayloadAttrs::Dreg(val) => {
                    if last_off == offset {
                        stack.push(("Dreg", last_off));
                        break;
                    }
                }
                ExprPayloadAttrs::Base(val) => {
                    if last_off == offset {
                        stack.push(("Base", last_off));
                        break;
                    }
                }
                ExprPayloadAttrs::Offset(val) => {
                    if last_off == offset {
                        stack.push(("Offset", last_off));
                        break;
                    }
                }
                ExprPayloadAttrs::Len(val) => {
                    if last_off == offset {
                        stack.push(("Len", last_off));
                        break;
                    }
                }
                ExprPayloadAttrs::Sreg(val) => {
                    if last_off == offset {
                        stack.push(("Sreg", last_off));
                        break;
                    }
                }
                ExprPayloadAttrs::CsumType(val) => {
                    if last_off == offset {
                        stack.push(("CsumType", last_off));
                        break;
                    }
                }
                ExprPayloadAttrs::CsumOffset(val) => {
                    if last_off == offset {
                        stack.push(("CsumOffset", last_off));
                        break;
                    }
                }
                ExprPayloadAttrs::CsumFlags(val) => {
                    if last_off == offset {
                        stack.push(("CsumFlags", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("ExprPayloadAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"expr-reject-attrs\""]
#[derive(Clone)]
pub enum ExprRejectAttrs {
    #[doc = "Associated type: \"RejectTypes\" (enum)"]
    Type(u32),
    IcmpCode(u8),
}
impl<'a> Iterable<'a, ExprRejectAttrs> {
    #[doc = "Associated type: \"RejectTypes\" (enum)"]
    pub fn get_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprRejectAttrs::Type(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprRejectAttrs", "Type"))
    }
    pub fn get_icmp_code(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprRejectAttrs::IcmpCode(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprRejectAttrs", "IcmpCode"))
    }
}
impl ExprRejectAttrs {
    pub fn new(buf: &'_ [u8]) -> Iterable<'_, ExprRejectAttrs> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Type",
            2u16 => "IcmpCode",
            _ => return None,
        };
        Some(res)
    }
}
impl Iterator for Iterable<'_, ExprRejectAttrs> {
    type Item = Result<ExprRejectAttrs, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => ExprRejectAttrs::Type({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => ExprRejectAttrs::IcmpCode({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "ExprRejectAttrs",
            r#type.and_then(|t| ExprRejectAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl std::fmt::Debug for Iterable<'_, ExprRejectAttrs> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("ExprRejectAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                ExprRejectAttrs::Type(val) => {
                    fmt.field("Type", &FormatEnum(val.into(), RejectTypes::from_value))
                }
                ExprRejectAttrs::IcmpCode(val) => fmt.field("IcmpCode", &val),
            };
        }
        fmt.finish()
    }
}
impl Iterable<'_, ExprRejectAttrs> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("ExprRejectAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| ExprRejectAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                ExprRejectAttrs::Type(val) => {
                    if last_off == offset {
                        stack.push(("Type", last_off));
                        break;
                    }
                }
                ExprRejectAttrs::IcmpCode(val) => {
                    if last_off == offset {
                        stack.push(("IcmpCode", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("ExprRejectAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"expr-target-attrs\""]
#[derive(Clone)]
pub enum ExprTargetAttrs<'a> {
    Name(&'a CStr),
    Rev(u32),
    Info(&'a [u8]),
}
impl<'a> Iterable<'a, ExprTargetAttrs<'a>> {
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprTargetAttrs::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprTargetAttrs", "Name"))
    }
    pub fn get_rev(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprTargetAttrs::Rev(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprTargetAttrs", "Rev"))
    }
    pub fn get_info(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprTargetAttrs::Info(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprTargetAttrs", "Info"))
    }
}
impl<'a> ExprTargetAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, ExprTargetAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Name",
            2u16 => "Rev",
            3u16 => "Info",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, ExprTargetAttrs<'a>> {
    type Item = Result<ExprTargetAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => ExprTargetAttrs::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => ExprTargetAttrs::Rev({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => ExprTargetAttrs::Info({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "ExprTargetAttrs",
            r#type.and_then(|t| ExprTargetAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, ExprTargetAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("ExprTargetAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                ExprTargetAttrs::Name(val) => fmt.field("Name", &val),
                ExprTargetAttrs::Rev(val) => fmt.field("Rev", &val),
                ExprTargetAttrs::Info(val) => fmt.field("Info", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, ExprTargetAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("ExprTargetAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| ExprTargetAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                ExprTargetAttrs::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                ExprTargetAttrs::Rev(val) => {
                    if last_off == offset {
                        stack.push(("Rev", last_off));
                        break;
                    }
                }
                ExprTargetAttrs::Info(val) => {
                    if last_off == offset {
                        stack.push(("Info", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("ExprTargetAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"expr-tproxy-attrs\""]
#[derive(Clone)]
pub enum ExprTproxyAttrs {
    Family(u32),
    RegAddr(u32),
    RegPort(u32),
}
impl<'a> Iterable<'a, ExprTproxyAttrs> {
    pub fn get_family(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprTproxyAttrs::Family(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprTproxyAttrs", "Family"))
    }
    pub fn get_reg_addr(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprTproxyAttrs::RegAddr(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprTproxyAttrs", "RegAddr"))
    }
    pub fn get_reg_port(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprTproxyAttrs::RegPort(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprTproxyAttrs", "RegPort"))
    }
}
impl ExprTproxyAttrs {
    pub fn new(buf: &'_ [u8]) -> Iterable<'_, ExprTproxyAttrs> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Family",
            2u16 => "RegAddr",
            3u16 => "RegPort",
            _ => return None,
        };
        Some(res)
    }
}
impl Iterator for Iterable<'_, ExprTproxyAttrs> {
    type Item = Result<ExprTproxyAttrs, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => ExprTproxyAttrs::Family({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => ExprTproxyAttrs::RegAddr({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => ExprTproxyAttrs::RegPort({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "ExprTproxyAttrs",
            r#type.and_then(|t| ExprTproxyAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl std::fmt::Debug for Iterable<'_, ExprTproxyAttrs> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("ExprTproxyAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                ExprTproxyAttrs::Family(val) => fmt.field("Family", &val),
                ExprTproxyAttrs::RegAddr(val) => fmt.field("RegAddr", &val),
                ExprTproxyAttrs::RegPort(val) => fmt.field("RegPort", &val),
            };
        }
        fmt.finish()
    }
}
impl Iterable<'_, ExprTproxyAttrs> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("ExprTproxyAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| ExprTproxyAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                ExprTproxyAttrs::Family(val) => {
                    if last_off == offset {
                        stack.push(("Family", last_off));
                        break;
                    }
                }
                ExprTproxyAttrs::RegAddr(val) => {
                    if last_off == offset {
                        stack.push(("RegAddr", last_off));
                        break;
                    }
                }
                ExprTproxyAttrs::RegPort(val) => {
                    if last_off == offset {
                        stack.push(("RegPort", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("ExprTproxyAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"expr-objref-attrs\""]
#[derive(Clone)]
pub enum ExprObjrefAttrs<'a> {
    ImmType(u32),
    #[doc = "object name"]
    ImmName(&'a CStr),
    SetSreg(u32),
    #[doc = "name of object map"]
    SetName(&'a CStr),
    #[doc = "id of object map"]
    SetId(u32),
}
impl<'a> Iterable<'a, ExprObjrefAttrs<'a>> {
    pub fn get_imm_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprObjrefAttrs::ImmType(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprObjrefAttrs", "ImmType"))
    }
    #[doc = "object name"]
    pub fn get_imm_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprObjrefAttrs::ImmName(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprObjrefAttrs", "ImmName"))
    }
    pub fn get_set_sreg(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprObjrefAttrs::SetSreg(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprObjrefAttrs", "SetSreg"))
    }
    #[doc = "name of object map"]
    pub fn get_set_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprObjrefAttrs::SetName(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprObjrefAttrs", "SetName"))
    }
    #[doc = "id of object map"]
    pub fn get_set_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprObjrefAttrs::SetId(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ExprObjrefAttrs", "SetId"))
    }
}
impl<'a> ExprObjrefAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, ExprObjrefAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "ImmType",
            2u16 => "ImmName",
            3u16 => "SetSreg",
            4u16 => "SetName",
            5u16 => "SetId",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, ExprObjrefAttrs<'a>> {
    type Item = Result<ExprObjrefAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => ExprObjrefAttrs::ImmType({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => ExprObjrefAttrs::ImmName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => ExprObjrefAttrs::SetSreg({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => ExprObjrefAttrs::SetName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => ExprObjrefAttrs::SetId({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "ExprObjrefAttrs",
            r#type.and_then(|t| ExprObjrefAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, ExprObjrefAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("ExprObjrefAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                ExprObjrefAttrs::ImmType(val) => fmt.field("ImmType", &val),
                ExprObjrefAttrs::ImmName(val) => fmt.field("ImmName", &val),
                ExprObjrefAttrs::SetSreg(val) => fmt.field("SetSreg", &val),
                ExprObjrefAttrs::SetName(val) => fmt.field("SetName", &val),
                ExprObjrefAttrs::SetId(val) => fmt.field("SetId", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, ExprObjrefAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("ExprObjrefAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| ExprObjrefAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                ExprObjrefAttrs::ImmType(val) => {
                    if last_off == offset {
                        stack.push(("ImmType", last_off));
                        break;
                    }
                }
                ExprObjrefAttrs::ImmName(val) => {
                    if last_off == offset {
                        stack.push(("ImmName", last_off));
                        break;
                    }
                }
                ExprObjrefAttrs::SetSreg(val) => {
                    if last_off == offset {
                        stack.push(("SetSreg", last_off));
                        break;
                    }
                }
                ExprObjrefAttrs::SetName(val) => {
                    if last_off == offset {
                        stack.push(("SetName", last_off));
                        break;
                    }
                }
                ExprObjrefAttrs::SetId(val) => {
                    if last_off == offset {
                        stack.push(("SetId", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("ExprObjrefAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"compat-target-attrs\""]
#[derive(Clone)]
pub enum CompatTargetAttrs<'a> {
    Name(&'a CStr),
    Rev(u32),
    Info(&'a [u8]),
}
impl<'a> Iterable<'a, CompatTargetAttrs<'a>> {
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CompatTargetAttrs::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CompatTargetAttrs", "Name"))
    }
    pub fn get_rev(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CompatTargetAttrs::Rev(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CompatTargetAttrs", "Rev"))
    }
    pub fn get_info(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CompatTargetAttrs::Info(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CompatTargetAttrs", "Info"))
    }
}
impl<'a> CompatTargetAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, CompatTargetAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Name",
            2u16 => "Rev",
            3u16 => "Info",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, CompatTargetAttrs<'a>> {
    type Item = Result<CompatTargetAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => CompatTargetAttrs::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => CompatTargetAttrs::Rev({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => CompatTargetAttrs::Info({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "CompatTargetAttrs",
            r#type.and_then(|t| CompatTargetAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, CompatTargetAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("CompatTargetAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                CompatTargetAttrs::Name(val) => fmt.field("Name", &val),
                CompatTargetAttrs::Rev(val) => fmt.field("Rev", &val),
                CompatTargetAttrs::Info(val) => fmt.field("Info", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, CompatTargetAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("CompatTargetAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| CompatTargetAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                CompatTargetAttrs::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                CompatTargetAttrs::Rev(val) => {
                    if last_off == offset {
                        stack.push(("Rev", last_off));
                        break;
                    }
                }
                CompatTargetAttrs::Info(val) => {
                    if last_off == offset {
                        stack.push(("Info", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("CompatTargetAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"compat-match-attrs\""]
#[derive(Clone)]
pub enum CompatMatchAttrs<'a> {
    Name(&'a CStr),
    Rev(u32),
    Info(&'a [u8]),
}
impl<'a> Iterable<'a, CompatMatchAttrs<'a>> {
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CompatMatchAttrs::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CompatMatchAttrs", "Name"))
    }
    pub fn get_rev(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CompatMatchAttrs::Rev(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CompatMatchAttrs", "Rev"))
    }
    pub fn get_info(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CompatMatchAttrs::Info(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CompatMatchAttrs", "Info"))
    }
}
impl<'a> CompatMatchAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, CompatMatchAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Name",
            2u16 => "Rev",
            3u16 => "Info",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, CompatMatchAttrs<'a>> {
    type Item = Result<CompatMatchAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => CompatMatchAttrs::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => CompatMatchAttrs::Rev({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => CompatMatchAttrs::Info({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "CompatMatchAttrs",
            r#type.and_then(|t| CompatMatchAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, CompatMatchAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("CompatMatchAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                CompatMatchAttrs::Name(val) => fmt.field("Name", &val),
                CompatMatchAttrs::Rev(val) => fmt.field("Rev", &val),
                CompatMatchAttrs::Info(val) => fmt.field("Info", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, CompatMatchAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("CompatMatchAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| CompatMatchAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                CompatMatchAttrs::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                CompatMatchAttrs::Rev(val) => {
                    if last_off == offset {
                        stack.push(("Rev", last_off));
                        break;
                    }
                }
                CompatMatchAttrs::Info(val) => {
                    if last_off == offset {
                        stack.push(("Info", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("CompatMatchAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"compat-attrs\""]
#[derive(Clone)]
pub enum CompatAttrs<'a> {
    Name(&'a CStr),
    Rev(u32),
    Type(u32),
}
impl<'a> Iterable<'a, CompatAttrs<'a>> {
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CompatAttrs::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CompatAttrs", "Name"))
    }
    pub fn get_rev(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CompatAttrs::Rev(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CompatAttrs", "Rev"))
    }
    pub fn get_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CompatAttrs::Type(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CompatAttrs", "Type"))
    }
}
impl<'a> CompatAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, CompatAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Name",
            2u16 => "Rev",
            3u16 => "Type",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, CompatAttrs<'a>> {
    type Item = Result<CompatAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => CompatAttrs::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => CompatAttrs::Rev({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => CompatAttrs::Type({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "CompatAttrs",
            r#type.and_then(|t| CompatAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, CompatAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("CompatAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                CompatAttrs::Name(val) => fmt.field("Name", &val),
                CompatAttrs::Rev(val) => fmt.field("Rev", &val),
                CompatAttrs::Type(val) => fmt.field("Type", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, CompatAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("CompatAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| CompatAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                CompatAttrs::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                CompatAttrs::Rev(val) => {
                    if last_off == offset {
                        stack.push(("Rev", last_off));
                        break;
                    }
                }
                CompatAttrs::Type(val) => {
                    if last_off == offset {
                        stack.push(("Type", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("CompatAttrs", cur));
        }
        (stack, None)
    }
}
pub struct PushLogAttrs<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushLogAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushLogAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "netlink group to send messages to"]
    pub fn push_group(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 1u16, 2 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "prefix to prepend to log messages"]
    pub fn push_prefix(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "prefix to prepend to log messages"]
    pub fn push_prefix_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "length of payload to include in netlink message"]
    pub fn push_snaplen(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "queue threshold"]
    pub fn push_qthreshold(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 4u16, 2 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "log level\nAssociated type: \"LogLevel\" (enum)"]
    pub fn push_level(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "logging flags\nAssociated type: \"LogFlags\" (enum)"]
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushLogAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushNumgenAttrs<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushNumgenAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushNumgenAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "destination register\nAssociated type: \"Registers\" (enum)"]
    pub fn push_dreg(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "maximum counter value"]
    pub fn push_modulus(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "operation type\nAssociated type: \"NumgenTypes\" (enum)"]
    pub fn push_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "offset to be added to the counter"]
    pub fn push_offset(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushNumgenAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushRangeAttrs<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushRangeAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushRangeAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "source register of data to compare\nAssociated type: \"Registers\" (enum)"]
    pub fn push_sreg(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "cmp operation\nAssociated type: \"RangeOps\" (enum)"]
    pub fn push_op(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "data range from"]
    pub fn nested_from_data(mut self) -> PushDataAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 3u16);
        PushDataAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "data range to"]
    pub fn nested_to_data(mut self) -> PushDataAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushDataAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushRangeAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushBatchAttrs<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushBatchAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushBatchAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_genid(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushBatchAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushTableAttrs<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushTableAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushTableAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "bitmask of flags\nAssociated type: \"TableFlags\" (1 bit per enumeration)"]
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "number of chains in this table"]
    pub fn push_use(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "numeric handle of the table"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 4u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 5u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushTableAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushChainAttrs<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushChainAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushChainAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the chain"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the chain"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "numeric handle of the chain"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 2u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "name of the chain"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            3u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the chain"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 3u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "hook specification for basechains"]
    pub fn nested_hook(mut self) -> PushNftHookAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushNftHookAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "numeric policy of the chain"]
    pub fn push_policy(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "number of references to this chain"]
    pub fn push_use(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "type name of the chain"]
    pub fn push_type(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            7u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "type name of the chain"]
    pub fn push_type_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 7u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "counter specification of the chain"]
    pub fn nested_counters(mut self) -> PushNftCounterAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 8u16);
        PushNftCounterAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "chain flags\nAssociated type: \"ChainFlags\" (1 bit per enumeration)"]
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 9u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "uniquely identifies a chain in a transaction"]
    pub fn push_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 10u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 11u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushChainAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushCounterAttrs<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushCounterAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushCounterAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bytes(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 1u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_packets(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 2u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 3u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushCounterAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushNftHookAttrs<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushNftHookAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushNftHookAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_num(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_priority(mut self, value: i32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "net device name"]
    pub fn push_dev(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            3u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "net device name"]
    pub fn push_dev_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 3u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "list of net devices"]
    pub fn nested_devs(mut self) -> PushHookDevAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushHookDevAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushNftHookAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushHookDevAttrs<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushHookDevAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushHookDevAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushHookDevAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushNftCounterAttrs<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushNftCounterAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushNftCounterAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bytes(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 1u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_packets(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 2u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushNftCounterAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushRuleAttrs<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushRuleAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushRuleAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the rule"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the rule"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "name of the chain containing the rule"]
    pub fn push_chain(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the chain containing the rule"]
    pub fn push_chain_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "numeric handle of the rule"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 3u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "list of expressions"]
    pub fn nested_expressions(mut self) -> PushExprListAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushExprListAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "compatibility specifications of the rule"]
    pub fn nested_compat(mut self) -> PushRuleCompatAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 5u16);
        PushRuleCompatAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "numeric handle of the previous rule"]
    pub fn push_position(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 6u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 7u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    #[doc = "uniquely identifies a rule in a transaction"]
    pub fn push_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 8u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "transaction unique identifier of the previous rule"]
    pub fn push_position_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 9u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "add the rule to chain by ID, alternative to chain name"]
    pub fn push_chain_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 10u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushRuleAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushExprListAttrs<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushExprListAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushExprListAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn nested_elem(mut self) -> PushExprAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 1u16);
        PushExprAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushExprListAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushExprAttrs<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushExprAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushExprAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the expression type"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the expression type"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "type specific data"]
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn sub_nested_data_bitwise(mut self) -> PushExprBitwiseAttrs<Self> {
        self = self.push_name(c"bitwise");
        let header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        PushExprBitwiseAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn sub_nested_data_cmp(mut self) -> PushExprCmpAttrs<Self> {
        self = self.push_name(c"cmp");
        let header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        PushExprCmpAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn sub_nested_data_counter(mut self) -> PushExprCounterAttrs<Self> {
        self = self.push_name(c"counter");
        let header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        PushExprCounterAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn sub_nested_data_ct(mut self) -> PushExprCtAttrs<Self> {
        self = self.push_name(c"ct");
        let header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        PushExprCtAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn sub_nested_data_fib(mut self) -> PushExprFibAttrs<Self> {
        self = self.push_name(c"fib");
        let header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        PushExprFibAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn sub_nested_data_flow_offload(mut self) -> PushExprFlowOffloadAttrs<Self> {
        self = self.push_name(c"flow_offload");
        let header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        PushExprFlowOffloadAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn sub_nested_data_immediate(mut self) -> PushExprImmediateAttrs<Self> {
        self = self.push_name(c"immediate");
        let header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        PushExprImmediateAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn sub_nested_data_lookup(mut self) -> PushExprLookupAttrs<Self> {
        self = self.push_name(c"lookup");
        let header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        PushExprLookupAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn sub_nested_data_meta(mut self) -> PushExprMetaAttrs<Self> {
        self = self.push_name(c"meta");
        let header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        PushExprMetaAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn sub_nested_data_nat(mut self) -> PushExprNatAttrs<Self> {
        self = self.push_name(c"nat");
        let header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        PushExprNatAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn sub_nested_data_objref(mut self) -> PushExprObjrefAttrs<Self> {
        self = self.push_name(c"objref");
        let header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        PushExprObjrefAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn sub_nested_data_payload(mut self) -> PushExprPayloadAttrs<Self> {
        self = self.push_name(c"payload");
        let header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        PushExprPayloadAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn sub_nested_data_quota(mut self) -> PushQuotaAttrs<Self> {
        self = self.push_name(c"quota");
        let header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        PushQuotaAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn sub_nested_data_reject(mut self) -> PushExprRejectAttrs<Self> {
        self = self.push_name(c"reject");
        let header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        PushExprRejectAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn sub_nested_data_target(mut self) -> PushExprTargetAttrs<Self> {
        self = self.push_name(c"target");
        let header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        PushExprTargetAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn sub_nested_data_tproxy(mut self) -> PushExprTproxyAttrs<Self> {
        self = self.push_name(c"tproxy");
        let header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        PushExprTproxyAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn sub_nested_data_match(mut self) -> PushCompatMatchAttrs<Self> {
        self = self.push_name(c"match");
        let header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        PushCompatMatchAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn sub_nested_data_range(mut self) -> PushRangeAttrs<Self> {
        self = self.push_name(c"range");
        let header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        PushRangeAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn sub_nested_data_numgen(mut self) -> PushNumgenAttrs<Self> {
        self = self.push_name(c"numgen");
        let header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        PushNumgenAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn sub_nested_data_log(mut self) -> PushLogAttrs<Self> {
        self = self.push_name(c"log");
        let header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        PushLogAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushExprAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushRuleCompatAttrs<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushRuleCompatAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushRuleCompatAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "numeric value of the handled protocol"]
    pub fn push_proto(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "bitmask of flags"]
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushRuleCompatAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushSetAttrs<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushSetAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushSetAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "table name"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "table name"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "set name"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "set name"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "bitmask of enum nft_set_flags\nAssociated type: \"SetFlags\" (enum)"]
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "key data type, informational purpose only"]
    pub fn push_key_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "key data length"]
    pub fn push_key_len(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "mapping data type"]
    pub fn push_data_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "mapping data length"]
    pub fn push_data_len(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 7u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "selection policy"]
    pub fn push_policy(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 8u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "set description"]
    pub fn nested_desc(mut self) -> PushSetDescAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 9u16);
        PushSetDescAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "uniquely identifies a set in a transaction"]
    pub fn push_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 10u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "default timeout value"]
    pub fn push_timeout(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 11u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "garbage collection interval"]
    pub fn push_gc_interval(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 12u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 13u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 14u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    #[doc = "stateful object type"]
    pub fn push_obj_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 15u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "set handle"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 16u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "set expression\nAttribute may repeat multiple times (treat it as array)"]
    pub fn nested_expr(mut self) -> PushExprAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 17u16);
        PushExprAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "list of expressions"]
    pub fn nested_expressions(mut self) -> PushSetListAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 18u16);
        PushSetListAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushSetAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushSetDescAttrs<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushSetDescAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushSetDescAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "number of elements in set"]
    pub fn push_size(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "description of field concatenation\nAttribute may repeat multiple times (treat it as array)"]
    pub fn nested_concat(mut self) -> PushSetDescConcatAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        PushSetDescConcatAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushSetDescAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushSetDescConcatAttrs<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushSetDescConcatAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushSetDescConcatAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn nested_elem(mut self) -> PushSetFieldAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 1u16);
        PushSetFieldAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushSetDescConcatAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushSetFieldAttrs<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushSetFieldAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushSetFieldAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_len(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushSetFieldAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushSetListAttrs<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushSetListAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushSetListAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn nested_elem(mut self) -> PushExprAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 1u16);
        PushExprAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushSetListAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushSetelemAttrs<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushSetelemAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushSetelemAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "key value"]
    pub fn nested_key(mut self) -> PushDataAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 1u16);
        PushDataAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "data value of mapping"]
    pub fn nested_data(mut self) -> PushDataAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        PushDataAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "bitmask of nft_set_elem_flags"]
    pub fn push_flags(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 3u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    #[doc = "timeout value"]
    pub fn push_timeout(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 4u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "expiration time"]
    pub fn push_expiration(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 5u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 6u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    #[doc = "expression"]
    pub fn nested_expr(mut self) -> PushExprAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 7u16);
        PushExprAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "stateful object reference"]
    pub fn push_objref(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            8u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "stateful object reference"]
    pub fn push_objref_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 8u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "closing key value"]
    pub fn nested_key_end(mut self) -> PushDataAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 9u16);
        PushDataAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "list of expressions"]
    pub fn nested_expressions(mut self) -> PushExprListAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 10u16);
        PushExprListAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushSetelemAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushSetelemListElemAttrs<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushSetelemListElemAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushSetelemListElemAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn nested_elem(mut self) -> PushSetelemAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 1u16);
        PushSetelemAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushSetelemListElemAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushSetelemListAttrs<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushSetelemListAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushSetelemListAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_set(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_set_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn nested_elements(mut self) -> PushSetelemListElemAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 3u16);
        PushSetelemListElemAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_set_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushSetelemListAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushGenAttrs<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushGenAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushGenAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "ruleset generation id"]
    pub fn push_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_proc_pid(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_proc_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            3u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_proc_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 3u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushGenAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushObjAttrs<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushObjAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushObjAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the expression"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the expression"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "name of this expression type"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of this expression type"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "stateful object type\nAssociated type: \"ObjectType\" (enum)"]
    pub fn push_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "stateful object data"]
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn sub_nested_data_counter(mut self) -> PushCounterAttrs<Self> {
        self = self.push_type(ObjectType::Counter as u32);
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushCounterAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn sub_nested_data_quota(mut self) -> PushQuotaAttrs<Self> {
        self = self.push_type(ObjectType::Quota as u32);
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushQuotaAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "number of references to this expression"]
    pub fn push_use(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "object handle"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 6u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 7u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 8u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushObjAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushQuotaAttrs<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushQuotaAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushQuotaAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bytes(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 1u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "Associated type: \"QuotaFlags\" (enum)"]
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 3u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_consumed(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 4u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushQuotaAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushFlowtableAttrs<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushFlowtableAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushFlowtableAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn nested_hook(mut self) -> PushFlowtableHookAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 3u16);
        PushFlowtableHookAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_use(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 5u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 6u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 7u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushFlowtableAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushFlowtableHookAttrs<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushFlowtableHookAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushFlowtableHookAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_num(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_priority(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn nested_devs(mut self) -> PushHookDevAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 3u16);
        PushHookDevAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushFlowtableHookAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushExprBitwiseAttrs<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushExprBitwiseAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushExprBitwiseAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_sreg(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_dreg(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_len(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn nested_mask(mut self) -> PushDataAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushDataAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn nested_xor(mut self) -> PushDataAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 5u16);
        PushDataAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "Associated type: \"BitwiseOps\" (enum)"]
    pub fn push_op(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn nested_data(mut self) -> PushDataAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 7u16);
        PushDataAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushExprBitwiseAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushExprCmpAttrs<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushExprCmpAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushExprCmpAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_sreg(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "Associated type: \"CmpOps\" (enum)"]
    pub fn push_op(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn nested_data(mut self) -> PushDataAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 3u16);
        PushDataAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushExprCmpAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushDataAttrs<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushDataAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushDataAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_value(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn nested_verdict(mut self) -> PushVerdictAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        PushVerdictAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushDataAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushVerdictAttrs<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushVerdictAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushVerdictAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "nf_tables verdict\nAssociated type: \"VerdictCode\" (enum)"]
    pub fn push_code(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "jump target chain name"]
    pub fn push_chain(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "jump target chain name"]
    pub fn push_chain_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "jump target chain ID"]
    pub fn push_chain_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushVerdictAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushExprCounterAttrs<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushExprCounterAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushExprCounterAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "Number of bytes"]
    pub fn push_bytes(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 1u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "Number of packets"]
    pub fn push_packets(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 2u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 3u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushExprCounterAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushExprFibAttrs<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushExprFibAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushExprFibAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_dreg(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "Associated type: \"FibResult\" (enum)"]
    pub fn push_result(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "Associated type: \"FibFlags\" (enum)"]
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushExprFibAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushExprCtAttrs<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushExprCtAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushExprCtAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_dreg(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "Associated type: \"CtKeys\" (enum)"]
    pub fn push_key(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "Associated type: \"CtDirection\" (enum)"]
    pub fn push_direction(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 3u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_sreg(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushExprCtAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushExprFlowOffloadAttrs<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushExprFlowOffloadAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushExprFlowOffloadAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "Flow offload table name"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "Flow offload table name"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushExprFlowOffloadAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushExprImmediateAttrs<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushExprImmediateAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushExprImmediateAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_dreg(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn nested_data(mut self) -> PushDataAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        PushDataAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushExprImmediateAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushExprLookupAttrs<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushExprLookupAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushExprLookupAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "Name of set to use"]
    pub fn push_set(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "Name of set to use"]
    pub fn push_set_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "ID of set to use"]
    pub fn push_set_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_sreg(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_dreg(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "Associated type: \"LookupFlags\" (enum)"]
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushExprLookupAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushExprMetaAttrs<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushExprMetaAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushExprMetaAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_dreg(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "Associated type: \"MetaKeys\" (enum)"]
    pub fn push_key(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_sreg(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushExprMetaAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushExprNatAttrs<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushExprNatAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushExprNatAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_family(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_reg_addr_min(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_reg_addr_max(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_reg_proto_min(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_reg_proto_max(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "Associated type: \"NatRangeFlags\" (1 bit per enumeration)"]
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 7u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushExprNatAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushExprPayloadAttrs<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushExprPayloadAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushExprPayloadAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "destination register to load data into\nAssociated type: \"Registers\" (enum)"]
    pub fn push_dreg(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "payload base\nAssociated type: \"PayloadBase\" (enum)"]
    pub fn push_base(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "payload offset relative to base"]
    pub fn push_offset(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "payload length"]
    pub fn push_len(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "source register to load data from\nAssociated type: \"Registers\" (enum)"]
    pub fn push_sreg(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "checksum type"]
    pub fn push_csum_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "checksum offset relative to base"]
    pub fn push_csum_offset(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 7u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "checksum flags"]
    pub fn push_csum_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 8u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushExprPayloadAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushExprRejectAttrs<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushExprRejectAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushExprRejectAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "Associated type: \"RejectTypes\" (enum)"]
    pub fn push_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_icmp_code(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 2u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushExprRejectAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushExprTargetAttrs<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushExprTargetAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushExprTargetAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_rev(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_info(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 3u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushExprTargetAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushExprTproxyAttrs<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushExprTproxyAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushExprTproxyAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_family(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_reg_addr(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_reg_port(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushExprTproxyAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushExprObjrefAttrs<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushExprObjrefAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushExprObjrefAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_imm_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "object name"]
    pub fn push_imm_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "object name"]
    pub fn push_imm_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_set_sreg(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "name of object map"]
    pub fn push_set_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            4u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of object map"]
    pub fn push_set_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 4u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "id of object map"]
    pub fn push_set_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushExprObjrefAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushCompatTargetAttrs<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushCompatTargetAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushCompatTargetAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_rev(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_info(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 3u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushCompatTargetAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushCompatMatchAttrs<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushCompatMatchAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushCompatMatchAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_rev(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_info(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 3u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushCompatMatchAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushCompatAttrs<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushCompatAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushCompatAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_rev(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushCompatAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Original name: \"nfgenmsg\""]
#[derive(Clone)]
pub struct PushNfgenmsg {
    buf: [u8; 4usize],
}
impl PushNfgenmsg {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        4usize
    }
    pub fn nfgen_family(&self) -> u8 {
        parse_u8(&self.buf[0usize..1usize]).unwrap()
    }
    pub fn set_nfgen_family(&mut self, value: u8) {
        self.buf[0usize..1usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn version(&self) -> u8 {
        parse_u8(&self.buf[1usize..2usize]).unwrap()
    }
    pub fn set_version(&mut self, value: u8) {
        self.buf[1usize..2usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn res_id(&self) -> u16 {
        parse_be_u16(&self.buf[2usize..4usize]).unwrap()
    }
    pub fn set_res_id(&mut self, value: u16) {
        self.buf[2usize..4usize].copy_from_slice(&value.to_be_bytes())
    }
}
impl std::fmt::Debug for PushNfgenmsg {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("Nfgenmsg")
            .field("nfgen_family", &self.nfgen_family())
            .field("version", &self.version())
            .field("res_id", &self.res_id())
            .finish()
    }
}
pub struct PushOpCompatGetDumpRequest<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpCompatGetDumpRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpCompatGetDumpRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_rev(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpCompatGetDumpRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Original name: \"op-compat-get-dump-request\""]
#[derive(Clone)]
pub enum OpCompatGetDumpRequest<'a> {
    Name(&'a CStr),
    Rev(u32),
    Type(u32),
}
impl<'a> Iterable<'a, OpCompatGetDumpRequest<'a>> {
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpCompatGetDumpRequest::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpCompatGetDumpRequest", "Name"))
    }
    pub fn get_rev(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpCompatGetDumpRequest::Rev(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpCompatGetDumpRequest", "Rev"))
    }
    pub fn get_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpCompatGetDumpRequest::Type(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpCompatGetDumpRequest", "Type"))
    }
}
impl<'a> OpCompatGetDumpRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpCompatGetDumpRequest<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        CompatAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpCompatGetDumpRequest<'a>> {
    type Item = Result<OpCompatGetDumpRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpCompatGetDumpRequest::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpCompatGetDumpRequest::Rev({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpCompatGetDumpRequest::Type({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpCompatGetDumpRequest",
            r#type.and_then(|t| OpCompatGetDumpRequest::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpCompatGetDumpRequest<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpCompatGetDumpRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpCompatGetDumpRequest::Name(val) => fmt.field("Name", &val),
                OpCompatGetDumpRequest::Rev(val) => fmt.field("Rev", &val),
                OpCompatGetDumpRequest::Type(val) => fmt.field("Type", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpCompatGetDumpRequest<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpCompatGetDumpRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpCompatGetDumpRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpCompatGetDumpRequest::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpCompatGetDumpRequest::Rev(val) => {
                    if last_off == offset {
                        stack.push(("Rev", last_off));
                        break;
                    }
                }
                OpCompatGetDumpRequest::Type(val) => {
                    if last_off == offset {
                        stack.push(("Type", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpCompatGetDumpRequest", cur));
        }
        (stack, None)
    }
}
pub struct PushOpCompatGetDumpReply<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpCompatGetDumpReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpCompatGetDumpReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_rev(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpCompatGetDumpReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Original name: \"op-compat-get-dump-reply\""]
#[derive(Clone)]
pub enum OpCompatGetDumpReply<'a> {
    Name(&'a CStr),
    Rev(u32),
    Type(u32),
}
impl<'a> Iterable<'a, OpCompatGetDumpReply<'a>> {
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpCompatGetDumpReply::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpCompatGetDumpReply", "Name"))
    }
    pub fn get_rev(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpCompatGetDumpReply::Rev(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpCompatGetDumpReply", "Rev"))
    }
    pub fn get_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpCompatGetDumpReply::Type(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpCompatGetDumpReply", "Type"))
    }
}
impl<'a> OpCompatGetDumpReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpCompatGetDumpReply<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        CompatAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpCompatGetDumpReply<'a>> {
    type Item = Result<OpCompatGetDumpReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpCompatGetDumpReply::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpCompatGetDumpReply::Rev({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpCompatGetDumpReply::Type({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpCompatGetDumpReply",
            r#type.and_then(|t| OpCompatGetDumpReply::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpCompatGetDumpReply<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpCompatGetDumpReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpCompatGetDumpReply::Name(val) => fmt.field("Name", &val),
                OpCompatGetDumpReply::Rev(val) => fmt.field("Rev", &val),
                OpCompatGetDumpReply::Type(val) => fmt.field("Type", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpCompatGetDumpReply<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpCompatGetDumpReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpCompatGetDumpReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpCompatGetDumpReply::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpCompatGetDumpReply::Rev(val) => {
                    if last_off == offset {
                        stack.push(("Rev", last_off));
                        break;
                    }
                }
                OpCompatGetDumpReply::Type(val) => {
                    if last_off == offset {
                        stack.push(("Type", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpCompatGetDumpReply", cur));
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpCompatGetDumpRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpCompatGetDumpRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpCompatGetDumpRequest::write_header(&mut request.buf_mut(), header);
        Self {
            request: request.set_dump(),
        }
    }
    pub fn encode(&mut self) -> PushOpCompatGetDumpRequest<&mut Vec<u8>> {
        PushOpCompatGetDumpRequest::new_without_header(self.request.buf_mut())
    }
}
impl NetlinkRequest for RequestOpCompatGetDumpRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, Iterable<'buf, OpCompatGetDumpReply<'buf>>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2816u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpCompatGetDumpReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpCompatGetDumpRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
pub struct PushOpCompatGetDoRequest<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpCompatGetDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpCompatGetDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_rev(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpCompatGetDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Original name: \"op-compat-get-do-request\""]
#[derive(Clone)]
pub enum OpCompatGetDoRequest<'a> {
    Name(&'a CStr),
    Rev(u32),
    Type(u32),
}
impl<'a> Iterable<'a, OpCompatGetDoRequest<'a>> {
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpCompatGetDoRequest::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpCompatGetDoRequest", "Name"))
    }
    pub fn get_rev(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpCompatGetDoRequest::Rev(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpCompatGetDoRequest", "Rev"))
    }
    pub fn get_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpCompatGetDoRequest::Type(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpCompatGetDoRequest", "Type"))
    }
}
impl<'a> OpCompatGetDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpCompatGetDoRequest<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        CompatAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpCompatGetDoRequest<'a>> {
    type Item = Result<OpCompatGetDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpCompatGetDoRequest::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpCompatGetDoRequest::Rev({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpCompatGetDoRequest::Type({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpCompatGetDoRequest",
            r#type.and_then(|t| OpCompatGetDoRequest::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpCompatGetDoRequest<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpCompatGetDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpCompatGetDoRequest::Name(val) => fmt.field("Name", &val),
                OpCompatGetDoRequest::Rev(val) => fmt.field("Rev", &val),
                OpCompatGetDoRequest::Type(val) => fmt.field("Type", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpCompatGetDoRequest<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpCompatGetDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpCompatGetDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpCompatGetDoRequest::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpCompatGetDoRequest::Rev(val) => {
                    if last_off == offset {
                        stack.push(("Rev", last_off));
                        break;
                    }
                }
                OpCompatGetDoRequest::Type(val) => {
                    if last_off == offset {
                        stack.push(("Type", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpCompatGetDoRequest", cur));
        }
        (stack, None)
    }
}
pub struct PushOpCompatGetDoReply<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpCompatGetDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpCompatGetDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_rev(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpCompatGetDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Original name: \"op-compat-get-do-reply\""]
#[derive(Clone)]
pub enum OpCompatGetDoReply<'a> {
    Name(&'a CStr),
    Rev(u32),
    Type(u32),
}
impl<'a> Iterable<'a, OpCompatGetDoReply<'a>> {
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpCompatGetDoReply::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpCompatGetDoReply", "Name"))
    }
    pub fn get_rev(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpCompatGetDoReply::Rev(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpCompatGetDoReply", "Rev"))
    }
    pub fn get_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpCompatGetDoReply::Type(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpCompatGetDoReply", "Type"))
    }
}
impl<'a> OpCompatGetDoReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpCompatGetDoReply<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        CompatAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpCompatGetDoReply<'a>> {
    type Item = Result<OpCompatGetDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpCompatGetDoReply::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpCompatGetDoReply::Rev({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpCompatGetDoReply::Type({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpCompatGetDoReply",
            r#type.and_then(|t| OpCompatGetDoReply::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpCompatGetDoReply<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpCompatGetDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpCompatGetDoReply::Name(val) => fmt.field("Name", &val),
                OpCompatGetDoReply::Rev(val) => fmt.field("Rev", &val),
                OpCompatGetDoReply::Type(val) => fmt.field("Type", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpCompatGetDoReply<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpCompatGetDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpCompatGetDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpCompatGetDoReply::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpCompatGetDoReply::Rev(val) => {
                    if last_off == offset {
                        stack.push(("Rev", last_off));
                        break;
                    }
                }
                OpCompatGetDoReply::Type(val) => {
                    if last_off == offset {
                        stack.push(("Type", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpCompatGetDoReply", cur));
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpCompatGetDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpCompatGetDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpCompatGetDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpCompatGetDoRequest<&mut Vec<u8>> {
        PushOpCompatGetDoRequest::new_without_header(self.request.buf_mut())
    }
}
impl NetlinkRequest for RequestOpCompatGetDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, Iterable<'buf, OpCompatGetDoReply<'buf>>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2816u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpCompatGetDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpCompatGetDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Start a batch of operations"]
pub struct PushOpBatchBeginDoRequest<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpBatchBeginDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpBatchBeginDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_genid(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpBatchBeginDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Start a batch of operations"]
#[doc = "Original name: \"op-batch-begin-do-request\""]
#[derive(Clone)]
pub enum OpBatchBeginDoRequest {
    Genid(u32),
}
impl<'a> Iterable<'a, OpBatchBeginDoRequest> {
    pub fn get_genid(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpBatchBeginDoRequest::Genid(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpBatchBeginDoRequest", "Genid"))
    }
}
impl OpBatchBeginDoRequest {
    pub fn new(buf: &'_ [u8]) -> (PushNfgenmsg, Iterable<'_, OpBatchBeginDoRequest>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        BatchAttrs::attr_from_type(r#type)
    }
}
impl Iterator for Iterable<'_, OpBatchBeginDoRequest> {
    type Item = Result<OpBatchBeginDoRequest, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpBatchBeginDoRequest::Genid({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpBatchBeginDoRequest",
            r#type.and_then(|t| OpBatchBeginDoRequest::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl std::fmt::Debug for Iterable<'_, OpBatchBeginDoRequest> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpBatchBeginDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpBatchBeginDoRequest::Genid(val) => fmt.field("Genid", &val),
            };
        }
        fmt.finish()
    }
}
impl Iterable<'_, OpBatchBeginDoRequest> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpBatchBeginDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpBatchBeginDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpBatchBeginDoRequest::Genid(val) => {
                    if last_off == offset {
                        stack.push(("Genid", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpBatchBeginDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Start a batch of operations"]
pub struct PushOpBatchBeginDoReply<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpBatchBeginDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpBatchBeginDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_genid(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpBatchBeginDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Start a batch of operations"]
#[doc = "Original name: \"op-batch-begin-do-reply\""]
#[derive(Clone)]
pub enum OpBatchBeginDoReply {
    Genid(u32),
}
impl<'a> Iterable<'a, OpBatchBeginDoReply> {
    pub fn get_genid(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpBatchBeginDoReply::Genid(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpBatchBeginDoReply", "Genid"))
    }
}
impl OpBatchBeginDoReply {
    pub fn new(buf: &'_ [u8]) -> (PushNfgenmsg, Iterable<'_, OpBatchBeginDoReply>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        BatchAttrs::attr_from_type(r#type)
    }
}
impl Iterator for Iterable<'_, OpBatchBeginDoReply> {
    type Item = Result<OpBatchBeginDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpBatchBeginDoReply::Genid({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpBatchBeginDoReply",
            r#type.and_then(|t| OpBatchBeginDoReply::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl std::fmt::Debug for Iterable<'_, OpBatchBeginDoReply> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpBatchBeginDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpBatchBeginDoReply::Genid(val) => fmt.field("Genid", &val),
            };
        }
        fmt.finish()
    }
}
impl Iterable<'_, OpBatchBeginDoReply> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpBatchBeginDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpBatchBeginDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpBatchBeginDoReply::Genid(val) => {
                    if last_off == offset {
                        stack.push(("Genid", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpBatchBeginDoReply", cur));
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpBatchBeginDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpBatchBeginDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpBatchBeginDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpBatchBeginDoRequest<&mut Vec<u8>> {
        PushOpBatchBeginDoRequest::new_without_header(self.request.buf_mut())
    }
}
impl NetlinkRequest for RequestOpBatchBeginDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, Iterable<'buf, OpBatchBeginDoReply>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 16u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpBatchBeginDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpBatchBeginDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Finish a batch of operations"]
pub struct PushOpBatchEndDoRequest<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpBatchEndDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpBatchEndDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_genid(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpBatchEndDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Finish a batch of operations"]
#[doc = "Original name: \"op-batch-end-do-request\""]
#[derive(Clone)]
pub enum OpBatchEndDoRequest {
    Genid(u32),
}
impl<'a> Iterable<'a, OpBatchEndDoRequest> {
    pub fn get_genid(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpBatchEndDoRequest::Genid(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpBatchEndDoRequest", "Genid"))
    }
}
impl OpBatchEndDoRequest {
    pub fn new(buf: &'_ [u8]) -> (PushNfgenmsg, Iterable<'_, OpBatchEndDoRequest>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        BatchAttrs::attr_from_type(r#type)
    }
}
impl Iterator for Iterable<'_, OpBatchEndDoRequest> {
    type Item = Result<OpBatchEndDoRequest, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpBatchEndDoRequest::Genid({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpBatchEndDoRequest",
            r#type.and_then(|t| OpBatchEndDoRequest::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl std::fmt::Debug for Iterable<'_, OpBatchEndDoRequest> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpBatchEndDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpBatchEndDoRequest::Genid(val) => fmt.field("Genid", &val),
            };
        }
        fmt.finish()
    }
}
impl Iterable<'_, OpBatchEndDoRequest> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpBatchEndDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpBatchEndDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpBatchEndDoRequest::Genid(val) => {
                    if last_off == offset {
                        stack.push(("Genid", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpBatchEndDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Finish a batch of operations"]
pub struct PushOpBatchEndDoReply<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpBatchEndDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpBatchEndDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_genid(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpBatchEndDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Finish a batch of operations"]
#[doc = "Original name: \"op-batch-end-do-reply\""]
#[derive(Clone)]
pub enum OpBatchEndDoReply {
    Genid(u32),
}
impl<'a> Iterable<'a, OpBatchEndDoReply> {
    pub fn get_genid(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpBatchEndDoReply::Genid(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpBatchEndDoReply", "Genid"))
    }
}
impl OpBatchEndDoReply {
    pub fn new(buf: &'_ [u8]) -> (PushNfgenmsg, Iterable<'_, OpBatchEndDoReply>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        BatchAttrs::attr_from_type(r#type)
    }
}
impl Iterator for Iterable<'_, OpBatchEndDoReply> {
    type Item = Result<OpBatchEndDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpBatchEndDoReply::Genid({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpBatchEndDoReply",
            r#type.and_then(|t| OpBatchEndDoReply::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl std::fmt::Debug for Iterable<'_, OpBatchEndDoReply> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpBatchEndDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpBatchEndDoReply::Genid(val) => fmt.field("Genid", &val),
            };
        }
        fmt.finish()
    }
}
impl Iterable<'_, OpBatchEndDoReply> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpBatchEndDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpBatchEndDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpBatchEndDoReply::Genid(val) => {
                    if last_off == offset {
                        stack.push(("Genid", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpBatchEndDoReply", cur));
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpBatchEndDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpBatchEndDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpBatchEndDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpBatchEndDoRequest<&mut Vec<u8>> {
        PushOpBatchEndDoRequest::new_without_header(self.request.buf_mut())
    }
}
impl NetlinkRequest for RequestOpBatchEndDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, Iterable<'buf, OpBatchEndDoReply>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 17u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpBatchEndDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpBatchEndDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Create a new table."]
pub struct PushOpNewtableDoRequest<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpNewtableDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpNewtableDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "bitmask of flags\nAssociated type: \"TableFlags\" (1 bit per enumeration)"]
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "number of chains in this table"]
    pub fn push_use(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "numeric handle of the table"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 4u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 5u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushOpNewtableDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Create a new table."]
#[doc = "Original name: \"op-newtable-do-request\""]
#[derive(Clone)]
pub enum OpNewtableDoRequest<'a> {
    #[doc = "name of the table"]
    Name(&'a CStr),
    #[doc = "bitmask of flags\nAssociated type: \"TableFlags\" (1 bit per enumeration)"]
    Flags(u32),
    #[doc = "number of chains in this table"]
    Use(u32),
    #[doc = "numeric handle of the table"]
    Handle(u64),
    #[doc = "user data"]
    Userdata(&'a [u8]),
}
impl<'a> Iterable<'a, OpNewtableDoRequest<'a>> {
    #[doc = "name of the table"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewtableDoRequest::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewtableDoRequest", "Name"))
    }
    #[doc = "bitmask of flags\nAssociated type: \"TableFlags\" (1 bit per enumeration)"]
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewtableDoRequest::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewtableDoRequest", "Flags"))
    }
    #[doc = "number of chains in this table"]
    pub fn get_use(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewtableDoRequest::Use(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewtableDoRequest", "Use"))
    }
    #[doc = "numeric handle of the table"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewtableDoRequest::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewtableDoRequest", "Handle"))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewtableDoRequest::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewtableDoRequest", "Userdata"))
    }
}
impl<'a> OpNewtableDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpNewtableDoRequest<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        TableAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpNewtableDoRequest<'a>> {
    type Item = Result<OpNewtableDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpNewtableDoRequest::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpNewtableDoRequest::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpNewtableDoRequest::Use({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpNewtableDoRequest::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpNewtableDoRequest::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpNewtableDoRequest",
            r#type.and_then(|t| OpNewtableDoRequest::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpNewtableDoRequest<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpNewtableDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpNewtableDoRequest::Name(val) => fmt.field("Name", &val),
                OpNewtableDoRequest::Flags(val) => {
                    fmt.field("Flags", &FormatFlags(val.into(), TableFlags::from_value))
                }
                OpNewtableDoRequest::Use(val) => fmt.field("Use", &val),
                OpNewtableDoRequest::Handle(val) => fmt.field("Handle", &val),
                OpNewtableDoRequest::Userdata(val) => fmt.field("Userdata", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpNewtableDoRequest<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpNewtableDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpNewtableDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpNewtableDoRequest::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpNewtableDoRequest::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                OpNewtableDoRequest::Use(val) => {
                    if last_off == offset {
                        stack.push(("Use", last_off));
                        break;
                    }
                }
                OpNewtableDoRequest::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpNewtableDoRequest::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpNewtableDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Create a new table."]
pub struct PushOpNewtableDoReply<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpNewtableDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpNewtableDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "bitmask of flags\nAssociated type: \"TableFlags\" (1 bit per enumeration)"]
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "number of chains in this table"]
    pub fn push_use(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "numeric handle of the table"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 4u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 5u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushOpNewtableDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Create a new table."]
#[doc = "Original name: \"op-newtable-do-reply\""]
#[derive(Clone)]
pub enum OpNewtableDoReply<'a> {
    #[doc = "name of the table"]
    Name(&'a CStr),
    #[doc = "bitmask of flags\nAssociated type: \"TableFlags\" (1 bit per enumeration)"]
    Flags(u32),
    #[doc = "number of chains in this table"]
    Use(u32),
    #[doc = "numeric handle of the table"]
    Handle(u64),
    #[doc = "user data"]
    Userdata(&'a [u8]),
}
impl<'a> Iterable<'a, OpNewtableDoReply<'a>> {
    #[doc = "name of the table"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewtableDoReply::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewtableDoReply", "Name"))
    }
    #[doc = "bitmask of flags\nAssociated type: \"TableFlags\" (1 bit per enumeration)"]
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewtableDoReply::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewtableDoReply", "Flags"))
    }
    #[doc = "number of chains in this table"]
    pub fn get_use(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewtableDoReply::Use(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewtableDoReply", "Use"))
    }
    #[doc = "numeric handle of the table"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewtableDoReply::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewtableDoReply", "Handle"))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewtableDoReply::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewtableDoReply", "Userdata"))
    }
}
impl<'a> OpNewtableDoReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpNewtableDoReply<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        TableAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpNewtableDoReply<'a>> {
    type Item = Result<OpNewtableDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpNewtableDoReply::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpNewtableDoReply::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpNewtableDoReply::Use({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpNewtableDoReply::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpNewtableDoReply::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpNewtableDoReply",
            r#type.and_then(|t| OpNewtableDoReply::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpNewtableDoReply<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpNewtableDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpNewtableDoReply::Name(val) => fmt.field("Name", &val),
                OpNewtableDoReply::Flags(val) => {
                    fmt.field("Flags", &FormatFlags(val.into(), TableFlags::from_value))
                }
                OpNewtableDoReply::Use(val) => fmt.field("Use", &val),
                OpNewtableDoReply::Handle(val) => fmt.field("Handle", &val),
                OpNewtableDoReply::Userdata(val) => fmt.field("Userdata", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpNewtableDoReply<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpNewtableDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpNewtableDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpNewtableDoReply::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpNewtableDoReply::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                OpNewtableDoReply::Use(val) => {
                    if last_off == offset {
                        stack.push(("Use", last_off));
                        break;
                    }
                }
                OpNewtableDoReply::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpNewtableDoReply::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpNewtableDoReply", cur));
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpNewtableDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpNewtableDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpNewtableDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpNewtableDoRequest<&mut Vec<u8>> {
        PushOpNewtableDoRequest::new_without_header(self.request.buf_mut())
    }
}
impl NetlinkRequest for RequestOpNewtableDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, Iterable<'buf, OpNewtableDoReply<'buf>>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2560u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpNewtableDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpNewtableDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Get / dump tables."]
pub struct PushOpGettableDumpRequest<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGettableDumpRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGettableDumpRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "bitmask of flags\nAssociated type: \"TableFlags\" (1 bit per enumeration)"]
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "number of chains in this table"]
    pub fn push_use(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "numeric handle of the table"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 4u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 5u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushOpGettableDumpRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump tables."]
#[doc = "Original name: \"op-gettable-dump-request\""]
#[derive(Clone)]
pub enum OpGettableDumpRequest<'a> {
    #[doc = "name of the table"]
    Name(&'a CStr),
    #[doc = "bitmask of flags\nAssociated type: \"TableFlags\" (1 bit per enumeration)"]
    Flags(u32),
    #[doc = "number of chains in this table"]
    Use(u32),
    #[doc = "numeric handle of the table"]
    Handle(u64),
    #[doc = "user data"]
    Userdata(&'a [u8]),
}
impl<'a> Iterable<'a, OpGettableDumpRequest<'a>> {
    #[doc = "name of the table"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettableDumpRequest::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGettableDumpRequest", "Name"))
    }
    #[doc = "bitmask of flags\nAssociated type: \"TableFlags\" (1 bit per enumeration)"]
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettableDumpRequest::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGettableDumpRequest", "Flags"))
    }
    #[doc = "number of chains in this table"]
    pub fn get_use(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettableDumpRequest::Use(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGettableDumpRequest", "Use"))
    }
    #[doc = "numeric handle of the table"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettableDumpRequest::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGettableDumpRequest", "Handle"))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettableDumpRequest::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGettableDumpRequest", "Userdata"))
    }
}
impl<'a> OpGettableDumpRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpGettableDumpRequest<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        TableAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpGettableDumpRequest<'a>> {
    type Item = Result<OpGettableDumpRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGettableDumpRequest::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGettableDumpRequest::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGettableDumpRequest::Use({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpGettableDumpRequest::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpGettableDumpRequest::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpGettableDumpRequest",
            r#type.and_then(|t| OpGettableDumpRequest::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpGettableDumpRequest<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGettableDumpRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGettableDumpRequest::Name(val) => fmt.field("Name", &val),
                OpGettableDumpRequest::Flags(val) => {
                    fmt.field("Flags", &FormatFlags(val.into(), TableFlags::from_value))
                }
                OpGettableDumpRequest::Use(val) => fmt.field("Use", &val),
                OpGettableDumpRequest::Handle(val) => fmt.field("Handle", &val),
                OpGettableDumpRequest::Userdata(val) => fmt.field("Userdata", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpGettableDumpRequest<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGettableDumpRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGettableDumpRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGettableDumpRequest::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpGettableDumpRequest::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                OpGettableDumpRequest::Use(val) => {
                    if last_off == offset {
                        stack.push(("Use", last_off));
                        break;
                    }
                }
                OpGettableDumpRequest::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpGettableDumpRequest::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGettableDumpRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get / dump tables."]
pub struct PushOpGettableDumpReply<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGettableDumpReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGettableDumpReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "bitmask of flags\nAssociated type: \"TableFlags\" (1 bit per enumeration)"]
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "number of chains in this table"]
    pub fn push_use(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "numeric handle of the table"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 4u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 5u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushOpGettableDumpReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump tables."]
#[doc = "Original name: \"op-gettable-dump-reply\""]
#[derive(Clone)]
pub enum OpGettableDumpReply<'a> {
    #[doc = "name of the table"]
    Name(&'a CStr),
    #[doc = "bitmask of flags\nAssociated type: \"TableFlags\" (1 bit per enumeration)"]
    Flags(u32),
    #[doc = "number of chains in this table"]
    Use(u32),
    #[doc = "numeric handle of the table"]
    Handle(u64),
    #[doc = "user data"]
    Userdata(&'a [u8]),
}
impl<'a> Iterable<'a, OpGettableDumpReply<'a>> {
    #[doc = "name of the table"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettableDumpReply::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGettableDumpReply", "Name"))
    }
    #[doc = "bitmask of flags\nAssociated type: \"TableFlags\" (1 bit per enumeration)"]
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettableDumpReply::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGettableDumpReply", "Flags"))
    }
    #[doc = "number of chains in this table"]
    pub fn get_use(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettableDumpReply::Use(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGettableDumpReply", "Use"))
    }
    #[doc = "numeric handle of the table"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettableDumpReply::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGettableDumpReply", "Handle"))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettableDumpReply::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGettableDumpReply", "Userdata"))
    }
}
impl<'a> OpGettableDumpReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpGettableDumpReply<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        TableAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpGettableDumpReply<'a>> {
    type Item = Result<OpGettableDumpReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGettableDumpReply::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGettableDumpReply::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGettableDumpReply::Use({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpGettableDumpReply::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpGettableDumpReply::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpGettableDumpReply",
            r#type.and_then(|t| OpGettableDumpReply::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpGettableDumpReply<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGettableDumpReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGettableDumpReply::Name(val) => fmt.field("Name", &val),
                OpGettableDumpReply::Flags(val) => {
                    fmt.field("Flags", &FormatFlags(val.into(), TableFlags::from_value))
                }
                OpGettableDumpReply::Use(val) => fmt.field("Use", &val),
                OpGettableDumpReply::Handle(val) => fmt.field("Handle", &val),
                OpGettableDumpReply::Userdata(val) => fmt.field("Userdata", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpGettableDumpReply<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGettableDumpReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGettableDumpReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGettableDumpReply::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpGettableDumpReply::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                OpGettableDumpReply::Use(val) => {
                    if last_off == offset {
                        stack.push(("Use", last_off));
                        break;
                    }
                }
                OpGettableDumpReply::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpGettableDumpReply::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGettableDumpReply", cur));
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpGettableDumpRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpGettableDumpRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpGettableDumpRequest::write_header(&mut request.buf_mut(), header);
        Self {
            request: request.set_dump(),
        }
    }
    pub fn encode(&mut self) -> PushOpGettableDumpRequest<&mut Vec<u8>> {
        PushOpGettableDumpRequest::new_without_header(self.request.buf_mut())
    }
}
impl NetlinkRequest for RequestOpGettableDumpRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, Iterable<'buf, OpGettableDumpReply<'buf>>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2561u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpGettableDumpReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpGettableDumpRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Get / dump tables."]
pub struct PushOpGettableDoRequest<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGettableDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGettableDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "bitmask of flags\nAssociated type: \"TableFlags\" (1 bit per enumeration)"]
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "number of chains in this table"]
    pub fn push_use(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "numeric handle of the table"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 4u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 5u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushOpGettableDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump tables."]
#[doc = "Original name: \"op-gettable-do-request\""]
#[derive(Clone)]
pub enum OpGettableDoRequest<'a> {
    #[doc = "name of the table"]
    Name(&'a CStr),
    #[doc = "bitmask of flags\nAssociated type: \"TableFlags\" (1 bit per enumeration)"]
    Flags(u32),
    #[doc = "number of chains in this table"]
    Use(u32),
    #[doc = "numeric handle of the table"]
    Handle(u64),
    #[doc = "user data"]
    Userdata(&'a [u8]),
}
impl<'a> Iterable<'a, OpGettableDoRequest<'a>> {
    #[doc = "name of the table"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettableDoRequest::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGettableDoRequest", "Name"))
    }
    #[doc = "bitmask of flags\nAssociated type: \"TableFlags\" (1 bit per enumeration)"]
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettableDoRequest::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGettableDoRequest", "Flags"))
    }
    #[doc = "number of chains in this table"]
    pub fn get_use(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettableDoRequest::Use(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGettableDoRequest", "Use"))
    }
    #[doc = "numeric handle of the table"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettableDoRequest::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGettableDoRequest", "Handle"))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettableDoRequest::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGettableDoRequest", "Userdata"))
    }
}
impl<'a> OpGettableDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpGettableDoRequest<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        TableAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpGettableDoRequest<'a>> {
    type Item = Result<OpGettableDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGettableDoRequest::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGettableDoRequest::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGettableDoRequest::Use({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpGettableDoRequest::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpGettableDoRequest::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpGettableDoRequest",
            r#type.and_then(|t| OpGettableDoRequest::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpGettableDoRequest<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGettableDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGettableDoRequest::Name(val) => fmt.field("Name", &val),
                OpGettableDoRequest::Flags(val) => {
                    fmt.field("Flags", &FormatFlags(val.into(), TableFlags::from_value))
                }
                OpGettableDoRequest::Use(val) => fmt.field("Use", &val),
                OpGettableDoRequest::Handle(val) => fmt.field("Handle", &val),
                OpGettableDoRequest::Userdata(val) => fmt.field("Userdata", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpGettableDoRequest<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGettableDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGettableDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGettableDoRequest::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpGettableDoRequest::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                OpGettableDoRequest::Use(val) => {
                    if last_off == offset {
                        stack.push(("Use", last_off));
                        break;
                    }
                }
                OpGettableDoRequest::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpGettableDoRequest::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGettableDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get / dump tables."]
pub struct PushOpGettableDoReply<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGettableDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGettableDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "bitmask of flags\nAssociated type: \"TableFlags\" (1 bit per enumeration)"]
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "number of chains in this table"]
    pub fn push_use(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "numeric handle of the table"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 4u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 5u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushOpGettableDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump tables."]
#[doc = "Original name: \"op-gettable-do-reply\""]
#[derive(Clone)]
pub enum OpGettableDoReply<'a> {
    #[doc = "name of the table"]
    Name(&'a CStr),
    #[doc = "bitmask of flags\nAssociated type: \"TableFlags\" (1 bit per enumeration)"]
    Flags(u32),
    #[doc = "number of chains in this table"]
    Use(u32),
    #[doc = "numeric handle of the table"]
    Handle(u64),
    #[doc = "user data"]
    Userdata(&'a [u8]),
}
impl<'a> Iterable<'a, OpGettableDoReply<'a>> {
    #[doc = "name of the table"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettableDoReply::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGettableDoReply", "Name"))
    }
    #[doc = "bitmask of flags\nAssociated type: \"TableFlags\" (1 bit per enumeration)"]
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettableDoReply::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGettableDoReply", "Flags"))
    }
    #[doc = "number of chains in this table"]
    pub fn get_use(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettableDoReply::Use(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGettableDoReply", "Use"))
    }
    #[doc = "numeric handle of the table"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettableDoReply::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGettableDoReply", "Handle"))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettableDoReply::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGettableDoReply", "Userdata"))
    }
}
impl<'a> OpGettableDoReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpGettableDoReply<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        TableAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpGettableDoReply<'a>> {
    type Item = Result<OpGettableDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGettableDoReply::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGettableDoReply::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGettableDoReply::Use({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpGettableDoReply::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpGettableDoReply::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpGettableDoReply",
            r#type.and_then(|t| OpGettableDoReply::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpGettableDoReply<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGettableDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGettableDoReply::Name(val) => fmt.field("Name", &val),
                OpGettableDoReply::Flags(val) => {
                    fmt.field("Flags", &FormatFlags(val.into(), TableFlags::from_value))
                }
                OpGettableDoReply::Use(val) => fmt.field("Use", &val),
                OpGettableDoReply::Handle(val) => fmt.field("Handle", &val),
                OpGettableDoReply::Userdata(val) => fmt.field("Userdata", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpGettableDoReply<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGettableDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGettableDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGettableDoReply::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpGettableDoReply::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                OpGettableDoReply::Use(val) => {
                    if last_off == offset {
                        stack.push(("Use", last_off));
                        break;
                    }
                }
                OpGettableDoReply::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpGettableDoReply::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGettableDoReply", cur));
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpGettableDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpGettableDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpGettableDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpGettableDoRequest<&mut Vec<u8>> {
        PushOpGettableDoRequest::new_without_header(self.request.buf_mut())
    }
}
impl NetlinkRequest for RequestOpGettableDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, Iterable<'buf, OpGettableDoReply<'buf>>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2561u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpGettableDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpGettableDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Delete an existing table."]
pub struct PushOpDeltableDoRequest<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDeltableDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDeltableDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "bitmask of flags\nAssociated type: \"TableFlags\" (1 bit per enumeration)"]
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "number of chains in this table"]
    pub fn push_use(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "numeric handle of the table"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 4u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 5u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushOpDeltableDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete an existing table."]
#[doc = "Original name: \"op-deltable-do-request\""]
#[derive(Clone)]
pub enum OpDeltableDoRequest<'a> {
    #[doc = "name of the table"]
    Name(&'a CStr),
    #[doc = "bitmask of flags\nAssociated type: \"TableFlags\" (1 bit per enumeration)"]
    Flags(u32),
    #[doc = "number of chains in this table"]
    Use(u32),
    #[doc = "numeric handle of the table"]
    Handle(u64),
    #[doc = "user data"]
    Userdata(&'a [u8]),
}
impl<'a> Iterable<'a, OpDeltableDoRequest<'a>> {
    #[doc = "name of the table"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDeltableDoRequest::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDeltableDoRequest", "Name"))
    }
    #[doc = "bitmask of flags\nAssociated type: \"TableFlags\" (1 bit per enumeration)"]
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDeltableDoRequest::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDeltableDoRequest", "Flags"))
    }
    #[doc = "number of chains in this table"]
    pub fn get_use(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDeltableDoRequest::Use(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDeltableDoRequest", "Use"))
    }
    #[doc = "numeric handle of the table"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDeltableDoRequest::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDeltableDoRequest", "Handle"))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDeltableDoRequest::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDeltableDoRequest", "Userdata"))
    }
}
impl<'a> OpDeltableDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpDeltableDoRequest<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        TableAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpDeltableDoRequest<'a>> {
    type Item = Result<OpDeltableDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpDeltableDoRequest::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpDeltableDoRequest::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpDeltableDoRequest::Use({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpDeltableDoRequest::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpDeltableDoRequest::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpDeltableDoRequest",
            r#type.and_then(|t| OpDeltableDoRequest::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpDeltableDoRequest<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDeltableDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpDeltableDoRequest::Name(val) => fmt.field("Name", &val),
                OpDeltableDoRequest::Flags(val) => {
                    fmt.field("Flags", &FormatFlags(val.into(), TableFlags::from_value))
                }
                OpDeltableDoRequest::Use(val) => fmt.field("Use", &val),
                OpDeltableDoRequest::Handle(val) => fmt.field("Handle", &val),
                OpDeltableDoRequest::Userdata(val) => fmt.field("Userdata", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpDeltableDoRequest<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpDeltableDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDeltableDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpDeltableDoRequest::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpDeltableDoRequest::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                OpDeltableDoRequest::Use(val) => {
                    if last_off == offset {
                        stack.push(("Use", last_off));
                        break;
                    }
                }
                OpDeltableDoRequest::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpDeltableDoRequest::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpDeltableDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Delete an existing table."]
pub struct PushOpDeltableDoReply<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDeltableDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDeltableDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "bitmask of flags\nAssociated type: \"TableFlags\" (1 bit per enumeration)"]
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "number of chains in this table"]
    pub fn push_use(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "numeric handle of the table"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 4u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 5u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushOpDeltableDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete an existing table."]
#[doc = "Original name: \"op-deltable-do-reply\""]
#[derive(Clone)]
pub enum OpDeltableDoReply<'a> {
    #[doc = "name of the table"]
    Name(&'a CStr),
    #[doc = "bitmask of flags\nAssociated type: \"TableFlags\" (1 bit per enumeration)"]
    Flags(u32),
    #[doc = "number of chains in this table"]
    Use(u32),
    #[doc = "numeric handle of the table"]
    Handle(u64),
    #[doc = "user data"]
    Userdata(&'a [u8]),
}
impl<'a> Iterable<'a, OpDeltableDoReply<'a>> {
    #[doc = "name of the table"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDeltableDoReply::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDeltableDoReply", "Name"))
    }
    #[doc = "bitmask of flags\nAssociated type: \"TableFlags\" (1 bit per enumeration)"]
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDeltableDoReply::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDeltableDoReply", "Flags"))
    }
    #[doc = "number of chains in this table"]
    pub fn get_use(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDeltableDoReply::Use(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDeltableDoReply", "Use"))
    }
    #[doc = "numeric handle of the table"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDeltableDoReply::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDeltableDoReply", "Handle"))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDeltableDoReply::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDeltableDoReply", "Userdata"))
    }
}
impl<'a> OpDeltableDoReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpDeltableDoReply<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        TableAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpDeltableDoReply<'a>> {
    type Item = Result<OpDeltableDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpDeltableDoReply::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpDeltableDoReply::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpDeltableDoReply::Use({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpDeltableDoReply::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpDeltableDoReply::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpDeltableDoReply",
            r#type.and_then(|t| OpDeltableDoReply::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpDeltableDoReply<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDeltableDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpDeltableDoReply::Name(val) => fmt.field("Name", &val),
                OpDeltableDoReply::Flags(val) => {
                    fmt.field("Flags", &FormatFlags(val.into(), TableFlags::from_value))
                }
                OpDeltableDoReply::Use(val) => fmt.field("Use", &val),
                OpDeltableDoReply::Handle(val) => fmt.field("Handle", &val),
                OpDeltableDoReply::Userdata(val) => fmt.field("Userdata", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpDeltableDoReply<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpDeltableDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDeltableDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpDeltableDoReply::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpDeltableDoReply::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                OpDeltableDoReply::Use(val) => {
                    if last_off == offset {
                        stack.push(("Use", last_off));
                        break;
                    }
                }
                OpDeltableDoReply::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpDeltableDoReply::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpDeltableDoReply", cur));
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpDeltableDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpDeltableDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpDeltableDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpDeltableDoRequest<&mut Vec<u8>> {
        PushOpDeltableDoRequest::new_without_header(self.request.buf_mut())
    }
}
impl NetlinkRequest for RequestOpDeltableDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, Iterable<'buf, OpDeltableDoReply<'buf>>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2562u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpDeltableDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpDeltableDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Delete an existing table with destroy semantics (ignoring ENOENT\nerrors).\n"]
pub struct PushOpDestroytableDoRequest<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDestroytableDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDestroytableDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "bitmask of flags\nAssociated type: \"TableFlags\" (1 bit per enumeration)"]
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "number of chains in this table"]
    pub fn push_use(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "numeric handle of the table"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 4u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 5u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushOpDestroytableDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete an existing table with destroy semantics (ignoring ENOENT\nerrors).\n"]
#[doc = "Original name: \"op-destroytable-do-request\""]
#[derive(Clone)]
pub enum OpDestroytableDoRequest<'a> {
    #[doc = "name of the table"]
    Name(&'a CStr),
    #[doc = "bitmask of flags\nAssociated type: \"TableFlags\" (1 bit per enumeration)"]
    Flags(u32),
    #[doc = "number of chains in this table"]
    Use(u32),
    #[doc = "numeric handle of the table"]
    Handle(u64),
    #[doc = "user data"]
    Userdata(&'a [u8]),
}
impl<'a> Iterable<'a, OpDestroytableDoRequest<'a>> {
    #[doc = "name of the table"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroytableDoRequest::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroytableDoRequest", "Name"))
    }
    #[doc = "bitmask of flags\nAssociated type: \"TableFlags\" (1 bit per enumeration)"]
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroytableDoRequest::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroytableDoRequest", "Flags"))
    }
    #[doc = "number of chains in this table"]
    pub fn get_use(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroytableDoRequest::Use(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroytableDoRequest", "Use"))
    }
    #[doc = "numeric handle of the table"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroytableDoRequest::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroytableDoRequest", "Handle"))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroytableDoRequest::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroytableDoRequest", "Userdata"))
    }
}
impl<'a> OpDestroytableDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpDestroytableDoRequest<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        TableAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpDestroytableDoRequest<'a>> {
    type Item = Result<OpDestroytableDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpDestroytableDoRequest::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpDestroytableDoRequest::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpDestroytableDoRequest::Use({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpDestroytableDoRequest::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpDestroytableDoRequest::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpDestroytableDoRequest",
            r#type.and_then(|t| OpDestroytableDoRequest::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpDestroytableDoRequest<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDestroytableDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpDestroytableDoRequest::Name(val) => fmt.field("Name", &val),
                OpDestroytableDoRequest::Flags(val) => {
                    fmt.field("Flags", &FormatFlags(val.into(), TableFlags::from_value))
                }
                OpDestroytableDoRequest::Use(val) => fmt.field("Use", &val),
                OpDestroytableDoRequest::Handle(val) => fmt.field("Handle", &val),
                OpDestroytableDoRequest::Userdata(val) => fmt.field("Userdata", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpDestroytableDoRequest<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpDestroytableDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDestroytableDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpDestroytableDoRequest::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpDestroytableDoRequest::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                OpDestroytableDoRequest::Use(val) => {
                    if last_off == offset {
                        stack.push(("Use", last_off));
                        break;
                    }
                }
                OpDestroytableDoRequest::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpDestroytableDoRequest::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpDestroytableDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Delete an existing table with destroy semantics (ignoring ENOENT\nerrors).\n"]
pub struct PushOpDestroytableDoReply<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDestroytableDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDestroytableDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "bitmask of flags\nAssociated type: \"TableFlags\" (1 bit per enumeration)"]
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "number of chains in this table"]
    pub fn push_use(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "numeric handle of the table"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 4u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 5u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushOpDestroytableDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete an existing table with destroy semantics (ignoring ENOENT\nerrors).\n"]
#[doc = "Original name: \"op-destroytable-do-reply\""]
#[derive(Clone)]
pub enum OpDestroytableDoReply<'a> {
    #[doc = "name of the table"]
    Name(&'a CStr),
    #[doc = "bitmask of flags\nAssociated type: \"TableFlags\" (1 bit per enumeration)"]
    Flags(u32),
    #[doc = "number of chains in this table"]
    Use(u32),
    #[doc = "numeric handle of the table"]
    Handle(u64),
    #[doc = "user data"]
    Userdata(&'a [u8]),
}
impl<'a> Iterable<'a, OpDestroytableDoReply<'a>> {
    #[doc = "name of the table"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroytableDoReply::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroytableDoReply", "Name"))
    }
    #[doc = "bitmask of flags\nAssociated type: \"TableFlags\" (1 bit per enumeration)"]
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroytableDoReply::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroytableDoReply", "Flags"))
    }
    #[doc = "number of chains in this table"]
    pub fn get_use(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroytableDoReply::Use(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroytableDoReply", "Use"))
    }
    #[doc = "numeric handle of the table"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroytableDoReply::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroytableDoReply", "Handle"))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroytableDoReply::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroytableDoReply", "Userdata"))
    }
}
impl<'a> OpDestroytableDoReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpDestroytableDoReply<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        TableAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpDestroytableDoReply<'a>> {
    type Item = Result<OpDestroytableDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpDestroytableDoReply::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpDestroytableDoReply::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpDestroytableDoReply::Use({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpDestroytableDoReply::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpDestroytableDoReply::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpDestroytableDoReply",
            r#type.and_then(|t| OpDestroytableDoReply::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpDestroytableDoReply<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDestroytableDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpDestroytableDoReply::Name(val) => fmt.field("Name", &val),
                OpDestroytableDoReply::Flags(val) => {
                    fmt.field("Flags", &FormatFlags(val.into(), TableFlags::from_value))
                }
                OpDestroytableDoReply::Use(val) => fmt.field("Use", &val),
                OpDestroytableDoReply::Handle(val) => fmt.field("Handle", &val),
                OpDestroytableDoReply::Userdata(val) => fmt.field("Userdata", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpDestroytableDoReply<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpDestroytableDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDestroytableDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpDestroytableDoReply::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpDestroytableDoReply::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                OpDestroytableDoReply::Use(val) => {
                    if last_off == offset {
                        stack.push(("Use", last_off));
                        break;
                    }
                }
                OpDestroytableDoReply::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpDestroytableDoReply::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpDestroytableDoReply", cur));
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpDestroytableDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpDestroytableDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpDestroytableDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpDestroytableDoRequest<&mut Vec<u8>> {
        PushOpDestroytableDoRequest::new_without_header(self.request.buf_mut())
    }
}
impl NetlinkRequest for RequestOpDestroytableDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, Iterable<'buf, OpDestroytableDoReply<'buf>>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2586u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpDestroytableDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpDestroytableDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Create a new chain."]
pub struct PushOpNewchainDoRequest<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpNewchainDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpNewchainDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the chain"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the chain"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "numeric handle of the chain"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 2u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "name of the chain"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            3u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the chain"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 3u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "hook specification for basechains"]
    pub fn nested_hook(mut self) -> PushNftHookAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushNftHookAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "numeric policy of the chain"]
    pub fn push_policy(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "number of references to this chain"]
    pub fn push_use(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "type name of the chain"]
    pub fn push_type(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            7u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "type name of the chain"]
    pub fn push_type_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 7u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "counter specification of the chain"]
    pub fn nested_counters(mut self) -> PushNftCounterAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 8u16);
        PushNftCounterAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "chain flags\nAssociated type: \"ChainFlags\" (1 bit per enumeration)"]
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 9u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "uniquely identifies a chain in a transaction"]
    pub fn push_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 10u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 11u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushOpNewchainDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Create a new chain."]
#[doc = "Original name: \"op-newchain-do-request\""]
#[derive(Clone)]
pub enum OpNewchainDoRequest<'a> {
    #[doc = "name of the table containing the chain"]
    Table(&'a CStr),
    #[doc = "numeric handle of the chain"]
    Handle(u64),
    #[doc = "name of the chain"]
    Name(&'a CStr),
    #[doc = "hook specification for basechains"]
    Hook(Iterable<'a, NftHookAttrs<'a>>),
    #[doc = "numeric policy of the chain"]
    Policy(u32),
    #[doc = "number of references to this chain"]
    Use(u32),
    #[doc = "type name of the chain"]
    Type(&'a CStr),
    #[doc = "counter specification of the chain"]
    Counters(Iterable<'a, NftCounterAttrs>),
    #[doc = "chain flags\nAssociated type: \"ChainFlags\" (1 bit per enumeration)"]
    Flags(u32),
    #[doc = "uniquely identifies a chain in a transaction"]
    Id(u32),
    #[doc = "user data"]
    Userdata(&'a [u8]),
}
impl<'a> Iterable<'a, OpNewchainDoRequest<'a>> {
    #[doc = "name of the table containing the chain"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewchainDoRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewchainDoRequest", "Table"))
    }
    #[doc = "numeric handle of the chain"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewchainDoRequest::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewchainDoRequest", "Handle"))
    }
    #[doc = "name of the chain"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewchainDoRequest::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewchainDoRequest", "Name"))
    }
    #[doc = "hook specification for basechains"]
    pub fn get_hook(&self) -> Result<Iterable<'a, NftHookAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewchainDoRequest::Hook(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewchainDoRequest", "Hook"))
    }
    #[doc = "numeric policy of the chain"]
    pub fn get_policy(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewchainDoRequest::Policy(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewchainDoRequest", "Policy"))
    }
    #[doc = "number of references to this chain"]
    pub fn get_use(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewchainDoRequest::Use(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewchainDoRequest", "Use"))
    }
    #[doc = "type name of the chain"]
    pub fn get_type(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewchainDoRequest::Type(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewchainDoRequest", "Type"))
    }
    #[doc = "counter specification of the chain"]
    pub fn get_counters(&self) -> Result<Iterable<'a, NftCounterAttrs>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewchainDoRequest::Counters(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewchainDoRequest", "Counters"))
    }
    #[doc = "chain flags\nAssociated type: \"ChainFlags\" (1 bit per enumeration)"]
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewchainDoRequest::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewchainDoRequest", "Flags"))
    }
    #[doc = "uniquely identifies a chain in a transaction"]
    pub fn get_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewchainDoRequest::Id(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewchainDoRequest", "Id"))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewchainDoRequest::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewchainDoRequest", "Userdata"))
    }
}
impl<'a> OpNewchainDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpNewchainDoRequest<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        ChainAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpNewchainDoRequest<'a>> {
    type Item = Result<OpNewchainDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpNewchainDoRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpNewchainDoRequest::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpNewchainDoRequest::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpNewchainDoRequest::Hook({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpNewchainDoRequest::Policy({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpNewchainDoRequest::Use({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpNewchainDoRequest::Type({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpNewchainDoRequest::Counters({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => OpNewchainDoRequest::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => OpNewchainDoRequest::Id({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => OpNewchainDoRequest::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpNewchainDoRequest",
            r#type.and_then(|t| OpNewchainDoRequest::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpNewchainDoRequest<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpNewchainDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpNewchainDoRequest::Table(val) => fmt.field("Table", &val),
                OpNewchainDoRequest::Handle(val) => fmt.field("Handle", &val),
                OpNewchainDoRequest::Name(val) => fmt.field("Name", &val),
                OpNewchainDoRequest::Hook(val) => fmt.field("Hook", &val),
                OpNewchainDoRequest::Policy(val) => fmt.field("Policy", &val),
                OpNewchainDoRequest::Use(val) => fmt.field("Use", &val),
                OpNewchainDoRequest::Type(val) => fmt.field("Type", &val),
                OpNewchainDoRequest::Counters(val) => fmt.field("Counters", &val),
                OpNewchainDoRequest::Flags(val) => {
                    fmt.field("Flags", &FormatFlags(val.into(), ChainFlags::from_value))
                }
                OpNewchainDoRequest::Id(val) => fmt.field("Id", &val),
                OpNewchainDoRequest::Userdata(val) => fmt.field("Userdata", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpNewchainDoRequest<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpNewchainDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpNewchainDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpNewchainDoRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpNewchainDoRequest::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpNewchainDoRequest::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpNewchainDoRequest::Hook(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpNewchainDoRequest::Policy(val) => {
                    if last_off == offset {
                        stack.push(("Policy", last_off));
                        break;
                    }
                }
                OpNewchainDoRequest::Use(val) => {
                    if last_off == offset {
                        stack.push(("Use", last_off));
                        break;
                    }
                }
                OpNewchainDoRequest::Type(val) => {
                    if last_off == offset {
                        stack.push(("Type", last_off));
                        break;
                    }
                }
                OpNewchainDoRequest::Counters(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpNewchainDoRequest::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                OpNewchainDoRequest::Id(val) => {
                    if last_off == offset {
                        stack.push(("Id", last_off));
                        break;
                    }
                }
                OpNewchainDoRequest::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpNewchainDoRequest", cur));
        }
        (stack, missing)
    }
}
#[doc = "Create a new chain."]
pub struct PushOpNewchainDoReply<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpNewchainDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpNewchainDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the chain"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the chain"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "numeric handle of the chain"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 2u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "name of the chain"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            3u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the chain"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 3u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "hook specification for basechains"]
    pub fn nested_hook(mut self) -> PushNftHookAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushNftHookAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "numeric policy of the chain"]
    pub fn push_policy(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "number of references to this chain"]
    pub fn push_use(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "type name of the chain"]
    pub fn push_type(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            7u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "type name of the chain"]
    pub fn push_type_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 7u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "counter specification of the chain"]
    pub fn nested_counters(mut self) -> PushNftCounterAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 8u16);
        PushNftCounterAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "chain flags\nAssociated type: \"ChainFlags\" (1 bit per enumeration)"]
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 9u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "uniquely identifies a chain in a transaction"]
    pub fn push_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 10u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 11u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushOpNewchainDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Create a new chain."]
#[doc = "Original name: \"op-newchain-do-reply\""]
#[derive(Clone)]
pub enum OpNewchainDoReply<'a> {
    #[doc = "name of the table containing the chain"]
    Table(&'a CStr),
    #[doc = "numeric handle of the chain"]
    Handle(u64),
    #[doc = "name of the chain"]
    Name(&'a CStr),
    #[doc = "hook specification for basechains"]
    Hook(Iterable<'a, NftHookAttrs<'a>>),
    #[doc = "numeric policy of the chain"]
    Policy(u32),
    #[doc = "number of references to this chain"]
    Use(u32),
    #[doc = "type name of the chain"]
    Type(&'a CStr),
    #[doc = "counter specification of the chain"]
    Counters(Iterable<'a, NftCounterAttrs>),
    #[doc = "chain flags\nAssociated type: \"ChainFlags\" (1 bit per enumeration)"]
    Flags(u32),
    #[doc = "uniquely identifies a chain in a transaction"]
    Id(u32),
    #[doc = "user data"]
    Userdata(&'a [u8]),
}
impl<'a> Iterable<'a, OpNewchainDoReply<'a>> {
    #[doc = "name of the table containing the chain"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewchainDoReply::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewchainDoReply", "Table"))
    }
    #[doc = "numeric handle of the chain"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewchainDoReply::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewchainDoReply", "Handle"))
    }
    #[doc = "name of the chain"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewchainDoReply::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewchainDoReply", "Name"))
    }
    #[doc = "hook specification for basechains"]
    pub fn get_hook(&self) -> Result<Iterable<'a, NftHookAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewchainDoReply::Hook(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewchainDoReply", "Hook"))
    }
    #[doc = "numeric policy of the chain"]
    pub fn get_policy(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewchainDoReply::Policy(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewchainDoReply", "Policy"))
    }
    #[doc = "number of references to this chain"]
    pub fn get_use(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewchainDoReply::Use(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewchainDoReply", "Use"))
    }
    #[doc = "type name of the chain"]
    pub fn get_type(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewchainDoReply::Type(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewchainDoReply", "Type"))
    }
    #[doc = "counter specification of the chain"]
    pub fn get_counters(&self) -> Result<Iterable<'a, NftCounterAttrs>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewchainDoReply::Counters(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewchainDoReply", "Counters"))
    }
    #[doc = "chain flags\nAssociated type: \"ChainFlags\" (1 bit per enumeration)"]
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewchainDoReply::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewchainDoReply", "Flags"))
    }
    #[doc = "uniquely identifies a chain in a transaction"]
    pub fn get_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewchainDoReply::Id(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewchainDoReply", "Id"))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewchainDoReply::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewchainDoReply", "Userdata"))
    }
}
impl<'a> OpNewchainDoReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpNewchainDoReply<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        ChainAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpNewchainDoReply<'a>> {
    type Item = Result<OpNewchainDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpNewchainDoReply::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpNewchainDoReply::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpNewchainDoReply::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpNewchainDoReply::Hook({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpNewchainDoReply::Policy({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpNewchainDoReply::Use({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpNewchainDoReply::Type({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpNewchainDoReply::Counters({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => OpNewchainDoReply::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => OpNewchainDoReply::Id({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => OpNewchainDoReply::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpNewchainDoReply",
            r#type.and_then(|t| OpNewchainDoReply::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpNewchainDoReply<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpNewchainDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpNewchainDoReply::Table(val) => fmt.field("Table", &val),
                OpNewchainDoReply::Handle(val) => fmt.field("Handle", &val),
                OpNewchainDoReply::Name(val) => fmt.field("Name", &val),
                OpNewchainDoReply::Hook(val) => fmt.field("Hook", &val),
                OpNewchainDoReply::Policy(val) => fmt.field("Policy", &val),
                OpNewchainDoReply::Use(val) => fmt.field("Use", &val),
                OpNewchainDoReply::Type(val) => fmt.field("Type", &val),
                OpNewchainDoReply::Counters(val) => fmt.field("Counters", &val),
                OpNewchainDoReply::Flags(val) => {
                    fmt.field("Flags", &FormatFlags(val.into(), ChainFlags::from_value))
                }
                OpNewchainDoReply::Id(val) => fmt.field("Id", &val),
                OpNewchainDoReply::Userdata(val) => fmt.field("Userdata", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpNewchainDoReply<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpNewchainDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpNewchainDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpNewchainDoReply::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpNewchainDoReply::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpNewchainDoReply::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpNewchainDoReply::Hook(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpNewchainDoReply::Policy(val) => {
                    if last_off == offset {
                        stack.push(("Policy", last_off));
                        break;
                    }
                }
                OpNewchainDoReply::Use(val) => {
                    if last_off == offset {
                        stack.push(("Use", last_off));
                        break;
                    }
                }
                OpNewchainDoReply::Type(val) => {
                    if last_off == offset {
                        stack.push(("Type", last_off));
                        break;
                    }
                }
                OpNewchainDoReply::Counters(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpNewchainDoReply::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                OpNewchainDoReply::Id(val) => {
                    if last_off == offset {
                        stack.push(("Id", last_off));
                        break;
                    }
                }
                OpNewchainDoReply::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpNewchainDoReply", cur));
        }
        (stack, missing)
    }
}
#[derive(Debug)]
pub struct RequestOpNewchainDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpNewchainDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpNewchainDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpNewchainDoRequest<&mut Vec<u8>> {
        PushOpNewchainDoRequest::new_without_header(self.request.buf_mut())
    }
}
impl NetlinkRequest for RequestOpNewchainDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, Iterable<'buf, OpNewchainDoReply<'buf>>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2563u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpNewchainDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpNewchainDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Get / dump chains."]
pub struct PushOpGetchainDumpRequest<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetchainDumpRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetchainDumpRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the chain"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the chain"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "numeric handle of the chain"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 2u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "name of the chain"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            3u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the chain"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 3u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "hook specification for basechains"]
    pub fn nested_hook(mut self) -> PushNftHookAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushNftHookAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "numeric policy of the chain"]
    pub fn push_policy(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "number of references to this chain"]
    pub fn push_use(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "type name of the chain"]
    pub fn push_type(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            7u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "type name of the chain"]
    pub fn push_type_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 7u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "counter specification of the chain"]
    pub fn nested_counters(mut self) -> PushNftCounterAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 8u16);
        PushNftCounterAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "chain flags\nAssociated type: \"ChainFlags\" (1 bit per enumeration)"]
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 9u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "uniquely identifies a chain in a transaction"]
    pub fn push_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 10u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 11u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetchainDumpRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump chains."]
#[doc = "Original name: \"op-getchain-dump-request\""]
#[derive(Clone)]
pub enum OpGetchainDumpRequest<'a> {
    #[doc = "name of the table containing the chain"]
    Table(&'a CStr),
    #[doc = "numeric handle of the chain"]
    Handle(u64),
    #[doc = "name of the chain"]
    Name(&'a CStr),
    #[doc = "hook specification for basechains"]
    Hook(Iterable<'a, NftHookAttrs<'a>>),
    #[doc = "numeric policy of the chain"]
    Policy(u32),
    #[doc = "number of references to this chain"]
    Use(u32),
    #[doc = "type name of the chain"]
    Type(&'a CStr),
    #[doc = "counter specification of the chain"]
    Counters(Iterable<'a, NftCounterAttrs>),
    #[doc = "chain flags\nAssociated type: \"ChainFlags\" (1 bit per enumeration)"]
    Flags(u32),
    #[doc = "uniquely identifies a chain in a transaction"]
    Id(u32),
    #[doc = "user data"]
    Userdata(&'a [u8]),
}
impl<'a> Iterable<'a, OpGetchainDumpRequest<'a>> {
    #[doc = "name of the table containing the chain"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDumpRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetchainDumpRequest", "Table"))
    }
    #[doc = "numeric handle of the chain"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDumpRequest::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetchainDumpRequest", "Handle"))
    }
    #[doc = "name of the chain"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDumpRequest::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetchainDumpRequest", "Name"))
    }
    #[doc = "hook specification for basechains"]
    pub fn get_hook(&self) -> Result<Iterable<'a, NftHookAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDumpRequest::Hook(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetchainDumpRequest", "Hook"))
    }
    #[doc = "numeric policy of the chain"]
    pub fn get_policy(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDumpRequest::Policy(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetchainDumpRequest", "Policy"))
    }
    #[doc = "number of references to this chain"]
    pub fn get_use(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDumpRequest::Use(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetchainDumpRequest", "Use"))
    }
    #[doc = "type name of the chain"]
    pub fn get_type(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDumpRequest::Type(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetchainDumpRequest", "Type"))
    }
    #[doc = "counter specification of the chain"]
    pub fn get_counters(&self) -> Result<Iterable<'a, NftCounterAttrs>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDumpRequest::Counters(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetchainDumpRequest", "Counters"))
    }
    #[doc = "chain flags\nAssociated type: \"ChainFlags\" (1 bit per enumeration)"]
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDumpRequest::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetchainDumpRequest", "Flags"))
    }
    #[doc = "uniquely identifies a chain in a transaction"]
    pub fn get_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDumpRequest::Id(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetchainDumpRequest", "Id"))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDumpRequest::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetchainDumpRequest", "Userdata"))
    }
}
impl<'a> OpGetchainDumpRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpGetchainDumpRequest<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        ChainAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpGetchainDumpRequest<'a>> {
    type Item = Result<OpGetchainDumpRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetchainDumpRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetchainDumpRequest::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetchainDumpRequest::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpGetchainDumpRequest::Hook({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpGetchainDumpRequest::Policy({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpGetchainDumpRequest::Use({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpGetchainDumpRequest::Type({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpGetchainDumpRequest::Counters({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => OpGetchainDumpRequest::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => OpGetchainDumpRequest::Id({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => OpGetchainDumpRequest::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpGetchainDumpRequest",
            r#type.and_then(|t| OpGetchainDumpRequest::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpGetchainDumpRequest<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetchainDumpRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetchainDumpRequest::Table(val) => fmt.field("Table", &val),
                OpGetchainDumpRequest::Handle(val) => fmt.field("Handle", &val),
                OpGetchainDumpRequest::Name(val) => fmt.field("Name", &val),
                OpGetchainDumpRequest::Hook(val) => fmt.field("Hook", &val),
                OpGetchainDumpRequest::Policy(val) => fmt.field("Policy", &val),
                OpGetchainDumpRequest::Use(val) => fmt.field("Use", &val),
                OpGetchainDumpRequest::Type(val) => fmt.field("Type", &val),
                OpGetchainDumpRequest::Counters(val) => fmt.field("Counters", &val),
                OpGetchainDumpRequest::Flags(val) => {
                    fmt.field("Flags", &FormatFlags(val.into(), ChainFlags::from_value))
                }
                OpGetchainDumpRequest::Id(val) => fmt.field("Id", &val),
                OpGetchainDumpRequest::Userdata(val) => fmt.field("Userdata", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpGetchainDumpRequest<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetchainDumpRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetchainDumpRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetchainDumpRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpGetchainDumpRequest::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpGetchainDumpRequest::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpGetchainDumpRequest::Hook(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetchainDumpRequest::Policy(val) => {
                    if last_off == offset {
                        stack.push(("Policy", last_off));
                        break;
                    }
                }
                OpGetchainDumpRequest::Use(val) => {
                    if last_off == offset {
                        stack.push(("Use", last_off));
                        break;
                    }
                }
                OpGetchainDumpRequest::Type(val) => {
                    if last_off == offset {
                        stack.push(("Type", last_off));
                        break;
                    }
                }
                OpGetchainDumpRequest::Counters(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetchainDumpRequest::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                OpGetchainDumpRequest::Id(val) => {
                    if last_off == offset {
                        stack.push(("Id", last_off));
                        break;
                    }
                }
                OpGetchainDumpRequest::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetchainDumpRequest", cur));
        }
        (stack, missing)
    }
}
#[doc = "Get / dump chains."]
pub struct PushOpGetchainDumpReply<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetchainDumpReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetchainDumpReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the chain"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the chain"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "numeric handle of the chain"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 2u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "name of the chain"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            3u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the chain"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 3u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "hook specification for basechains"]
    pub fn nested_hook(mut self) -> PushNftHookAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushNftHookAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "numeric policy of the chain"]
    pub fn push_policy(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "number of references to this chain"]
    pub fn push_use(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "type name of the chain"]
    pub fn push_type(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            7u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "type name of the chain"]
    pub fn push_type_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 7u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "counter specification of the chain"]
    pub fn nested_counters(mut self) -> PushNftCounterAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 8u16);
        PushNftCounterAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "chain flags\nAssociated type: \"ChainFlags\" (1 bit per enumeration)"]
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 9u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "uniquely identifies a chain in a transaction"]
    pub fn push_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 10u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 11u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetchainDumpReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump chains."]
#[doc = "Original name: \"op-getchain-dump-reply\""]
#[derive(Clone)]
pub enum OpGetchainDumpReply<'a> {
    #[doc = "name of the table containing the chain"]
    Table(&'a CStr),
    #[doc = "numeric handle of the chain"]
    Handle(u64),
    #[doc = "name of the chain"]
    Name(&'a CStr),
    #[doc = "hook specification for basechains"]
    Hook(Iterable<'a, NftHookAttrs<'a>>),
    #[doc = "numeric policy of the chain"]
    Policy(u32),
    #[doc = "number of references to this chain"]
    Use(u32),
    #[doc = "type name of the chain"]
    Type(&'a CStr),
    #[doc = "counter specification of the chain"]
    Counters(Iterable<'a, NftCounterAttrs>),
    #[doc = "chain flags\nAssociated type: \"ChainFlags\" (1 bit per enumeration)"]
    Flags(u32),
    #[doc = "uniquely identifies a chain in a transaction"]
    Id(u32),
    #[doc = "user data"]
    Userdata(&'a [u8]),
}
impl<'a> Iterable<'a, OpGetchainDumpReply<'a>> {
    #[doc = "name of the table containing the chain"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDumpReply::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetchainDumpReply", "Table"))
    }
    #[doc = "numeric handle of the chain"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDumpReply::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetchainDumpReply", "Handle"))
    }
    #[doc = "name of the chain"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDumpReply::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetchainDumpReply", "Name"))
    }
    #[doc = "hook specification for basechains"]
    pub fn get_hook(&self) -> Result<Iterable<'a, NftHookAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDumpReply::Hook(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetchainDumpReply", "Hook"))
    }
    #[doc = "numeric policy of the chain"]
    pub fn get_policy(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDumpReply::Policy(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetchainDumpReply", "Policy"))
    }
    #[doc = "number of references to this chain"]
    pub fn get_use(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDumpReply::Use(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetchainDumpReply", "Use"))
    }
    #[doc = "type name of the chain"]
    pub fn get_type(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDumpReply::Type(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetchainDumpReply", "Type"))
    }
    #[doc = "counter specification of the chain"]
    pub fn get_counters(&self) -> Result<Iterable<'a, NftCounterAttrs>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDumpReply::Counters(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetchainDumpReply", "Counters"))
    }
    #[doc = "chain flags\nAssociated type: \"ChainFlags\" (1 bit per enumeration)"]
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDumpReply::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetchainDumpReply", "Flags"))
    }
    #[doc = "uniquely identifies a chain in a transaction"]
    pub fn get_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDumpReply::Id(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetchainDumpReply", "Id"))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDumpReply::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetchainDumpReply", "Userdata"))
    }
}
impl<'a> OpGetchainDumpReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpGetchainDumpReply<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        ChainAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpGetchainDumpReply<'a>> {
    type Item = Result<OpGetchainDumpReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetchainDumpReply::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetchainDumpReply::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetchainDumpReply::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpGetchainDumpReply::Hook({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpGetchainDumpReply::Policy({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpGetchainDumpReply::Use({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpGetchainDumpReply::Type({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpGetchainDumpReply::Counters({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => OpGetchainDumpReply::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => OpGetchainDumpReply::Id({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => OpGetchainDumpReply::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpGetchainDumpReply",
            r#type.and_then(|t| OpGetchainDumpReply::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpGetchainDumpReply<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetchainDumpReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetchainDumpReply::Table(val) => fmt.field("Table", &val),
                OpGetchainDumpReply::Handle(val) => fmt.field("Handle", &val),
                OpGetchainDumpReply::Name(val) => fmt.field("Name", &val),
                OpGetchainDumpReply::Hook(val) => fmt.field("Hook", &val),
                OpGetchainDumpReply::Policy(val) => fmt.field("Policy", &val),
                OpGetchainDumpReply::Use(val) => fmt.field("Use", &val),
                OpGetchainDumpReply::Type(val) => fmt.field("Type", &val),
                OpGetchainDumpReply::Counters(val) => fmt.field("Counters", &val),
                OpGetchainDumpReply::Flags(val) => {
                    fmt.field("Flags", &FormatFlags(val.into(), ChainFlags::from_value))
                }
                OpGetchainDumpReply::Id(val) => fmt.field("Id", &val),
                OpGetchainDumpReply::Userdata(val) => fmt.field("Userdata", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpGetchainDumpReply<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetchainDumpReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetchainDumpReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetchainDumpReply::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpGetchainDumpReply::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpGetchainDumpReply::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpGetchainDumpReply::Hook(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetchainDumpReply::Policy(val) => {
                    if last_off == offset {
                        stack.push(("Policy", last_off));
                        break;
                    }
                }
                OpGetchainDumpReply::Use(val) => {
                    if last_off == offset {
                        stack.push(("Use", last_off));
                        break;
                    }
                }
                OpGetchainDumpReply::Type(val) => {
                    if last_off == offset {
                        stack.push(("Type", last_off));
                        break;
                    }
                }
                OpGetchainDumpReply::Counters(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetchainDumpReply::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                OpGetchainDumpReply::Id(val) => {
                    if last_off == offset {
                        stack.push(("Id", last_off));
                        break;
                    }
                }
                OpGetchainDumpReply::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetchainDumpReply", cur));
        }
        (stack, missing)
    }
}
#[derive(Debug)]
pub struct RequestOpGetchainDumpRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpGetchainDumpRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpGetchainDumpRequest::write_header(&mut request.buf_mut(), header);
        Self {
            request: request.set_dump(),
        }
    }
    pub fn encode(&mut self) -> PushOpGetchainDumpRequest<&mut Vec<u8>> {
        PushOpGetchainDumpRequest::new_without_header(self.request.buf_mut())
    }
}
impl NetlinkRequest for RequestOpGetchainDumpRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, Iterable<'buf, OpGetchainDumpReply<'buf>>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2564u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpGetchainDumpReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpGetchainDumpRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Get / dump chains."]
pub struct PushOpGetchainDoRequest<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetchainDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetchainDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the chain"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the chain"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "numeric handle of the chain"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 2u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "name of the chain"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            3u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the chain"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 3u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "hook specification for basechains"]
    pub fn nested_hook(mut self) -> PushNftHookAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushNftHookAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "numeric policy of the chain"]
    pub fn push_policy(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "number of references to this chain"]
    pub fn push_use(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "type name of the chain"]
    pub fn push_type(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            7u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "type name of the chain"]
    pub fn push_type_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 7u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "counter specification of the chain"]
    pub fn nested_counters(mut self) -> PushNftCounterAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 8u16);
        PushNftCounterAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "chain flags\nAssociated type: \"ChainFlags\" (1 bit per enumeration)"]
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 9u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "uniquely identifies a chain in a transaction"]
    pub fn push_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 10u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 11u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetchainDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump chains."]
#[doc = "Original name: \"op-getchain-do-request\""]
#[derive(Clone)]
pub enum OpGetchainDoRequest<'a> {
    #[doc = "name of the table containing the chain"]
    Table(&'a CStr),
    #[doc = "numeric handle of the chain"]
    Handle(u64),
    #[doc = "name of the chain"]
    Name(&'a CStr),
    #[doc = "hook specification for basechains"]
    Hook(Iterable<'a, NftHookAttrs<'a>>),
    #[doc = "numeric policy of the chain"]
    Policy(u32),
    #[doc = "number of references to this chain"]
    Use(u32),
    #[doc = "type name of the chain"]
    Type(&'a CStr),
    #[doc = "counter specification of the chain"]
    Counters(Iterable<'a, NftCounterAttrs>),
    #[doc = "chain flags\nAssociated type: \"ChainFlags\" (1 bit per enumeration)"]
    Flags(u32),
    #[doc = "uniquely identifies a chain in a transaction"]
    Id(u32),
    #[doc = "user data"]
    Userdata(&'a [u8]),
}
impl<'a> Iterable<'a, OpGetchainDoRequest<'a>> {
    #[doc = "name of the table containing the chain"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDoRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetchainDoRequest", "Table"))
    }
    #[doc = "numeric handle of the chain"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDoRequest::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetchainDoRequest", "Handle"))
    }
    #[doc = "name of the chain"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDoRequest::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetchainDoRequest", "Name"))
    }
    #[doc = "hook specification for basechains"]
    pub fn get_hook(&self) -> Result<Iterable<'a, NftHookAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDoRequest::Hook(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetchainDoRequest", "Hook"))
    }
    #[doc = "numeric policy of the chain"]
    pub fn get_policy(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDoRequest::Policy(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetchainDoRequest", "Policy"))
    }
    #[doc = "number of references to this chain"]
    pub fn get_use(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDoRequest::Use(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetchainDoRequest", "Use"))
    }
    #[doc = "type name of the chain"]
    pub fn get_type(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDoRequest::Type(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetchainDoRequest", "Type"))
    }
    #[doc = "counter specification of the chain"]
    pub fn get_counters(&self) -> Result<Iterable<'a, NftCounterAttrs>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDoRequest::Counters(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetchainDoRequest", "Counters"))
    }
    #[doc = "chain flags\nAssociated type: \"ChainFlags\" (1 bit per enumeration)"]
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDoRequest::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetchainDoRequest", "Flags"))
    }
    #[doc = "uniquely identifies a chain in a transaction"]
    pub fn get_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDoRequest::Id(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetchainDoRequest", "Id"))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDoRequest::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetchainDoRequest", "Userdata"))
    }
}
impl<'a> OpGetchainDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpGetchainDoRequest<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        ChainAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpGetchainDoRequest<'a>> {
    type Item = Result<OpGetchainDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetchainDoRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetchainDoRequest::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetchainDoRequest::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpGetchainDoRequest::Hook({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpGetchainDoRequest::Policy({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpGetchainDoRequest::Use({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpGetchainDoRequest::Type({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpGetchainDoRequest::Counters({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => OpGetchainDoRequest::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => OpGetchainDoRequest::Id({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => OpGetchainDoRequest::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpGetchainDoRequest",
            r#type.and_then(|t| OpGetchainDoRequest::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpGetchainDoRequest<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetchainDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetchainDoRequest::Table(val) => fmt.field("Table", &val),
                OpGetchainDoRequest::Handle(val) => fmt.field("Handle", &val),
                OpGetchainDoRequest::Name(val) => fmt.field("Name", &val),
                OpGetchainDoRequest::Hook(val) => fmt.field("Hook", &val),
                OpGetchainDoRequest::Policy(val) => fmt.field("Policy", &val),
                OpGetchainDoRequest::Use(val) => fmt.field("Use", &val),
                OpGetchainDoRequest::Type(val) => fmt.field("Type", &val),
                OpGetchainDoRequest::Counters(val) => fmt.field("Counters", &val),
                OpGetchainDoRequest::Flags(val) => {
                    fmt.field("Flags", &FormatFlags(val.into(), ChainFlags::from_value))
                }
                OpGetchainDoRequest::Id(val) => fmt.field("Id", &val),
                OpGetchainDoRequest::Userdata(val) => fmt.field("Userdata", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpGetchainDoRequest<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetchainDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetchainDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetchainDoRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpGetchainDoRequest::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpGetchainDoRequest::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpGetchainDoRequest::Hook(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetchainDoRequest::Policy(val) => {
                    if last_off == offset {
                        stack.push(("Policy", last_off));
                        break;
                    }
                }
                OpGetchainDoRequest::Use(val) => {
                    if last_off == offset {
                        stack.push(("Use", last_off));
                        break;
                    }
                }
                OpGetchainDoRequest::Type(val) => {
                    if last_off == offset {
                        stack.push(("Type", last_off));
                        break;
                    }
                }
                OpGetchainDoRequest::Counters(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetchainDoRequest::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                OpGetchainDoRequest::Id(val) => {
                    if last_off == offset {
                        stack.push(("Id", last_off));
                        break;
                    }
                }
                OpGetchainDoRequest::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetchainDoRequest", cur));
        }
        (stack, missing)
    }
}
#[doc = "Get / dump chains."]
pub struct PushOpGetchainDoReply<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetchainDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetchainDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the chain"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the chain"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "numeric handle of the chain"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 2u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "name of the chain"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            3u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the chain"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 3u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "hook specification for basechains"]
    pub fn nested_hook(mut self) -> PushNftHookAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushNftHookAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "numeric policy of the chain"]
    pub fn push_policy(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "number of references to this chain"]
    pub fn push_use(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "type name of the chain"]
    pub fn push_type(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            7u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "type name of the chain"]
    pub fn push_type_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 7u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "counter specification of the chain"]
    pub fn nested_counters(mut self) -> PushNftCounterAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 8u16);
        PushNftCounterAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "chain flags\nAssociated type: \"ChainFlags\" (1 bit per enumeration)"]
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 9u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "uniquely identifies a chain in a transaction"]
    pub fn push_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 10u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 11u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetchainDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump chains."]
#[doc = "Original name: \"op-getchain-do-reply\""]
#[derive(Clone)]
pub enum OpGetchainDoReply<'a> {
    #[doc = "name of the table containing the chain"]
    Table(&'a CStr),
    #[doc = "numeric handle of the chain"]
    Handle(u64),
    #[doc = "name of the chain"]
    Name(&'a CStr),
    #[doc = "hook specification for basechains"]
    Hook(Iterable<'a, NftHookAttrs<'a>>),
    #[doc = "numeric policy of the chain"]
    Policy(u32),
    #[doc = "number of references to this chain"]
    Use(u32),
    #[doc = "type name of the chain"]
    Type(&'a CStr),
    #[doc = "counter specification of the chain"]
    Counters(Iterable<'a, NftCounterAttrs>),
    #[doc = "chain flags\nAssociated type: \"ChainFlags\" (1 bit per enumeration)"]
    Flags(u32),
    #[doc = "uniquely identifies a chain in a transaction"]
    Id(u32),
    #[doc = "user data"]
    Userdata(&'a [u8]),
}
impl<'a> Iterable<'a, OpGetchainDoReply<'a>> {
    #[doc = "name of the table containing the chain"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDoReply::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetchainDoReply", "Table"))
    }
    #[doc = "numeric handle of the chain"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDoReply::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetchainDoReply", "Handle"))
    }
    #[doc = "name of the chain"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDoReply::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetchainDoReply", "Name"))
    }
    #[doc = "hook specification for basechains"]
    pub fn get_hook(&self) -> Result<Iterable<'a, NftHookAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDoReply::Hook(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetchainDoReply", "Hook"))
    }
    #[doc = "numeric policy of the chain"]
    pub fn get_policy(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDoReply::Policy(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetchainDoReply", "Policy"))
    }
    #[doc = "number of references to this chain"]
    pub fn get_use(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDoReply::Use(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetchainDoReply", "Use"))
    }
    #[doc = "type name of the chain"]
    pub fn get_type(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDoReply::Type(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetchainDoReply", "Type"))
    }
    #[doc = "counter specification of the chain"]
    pub fn get_counters(&self) -> Result<Iterable<'a, NftCounterAttrs>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDoReply::Counters(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetchainDoReply", "Counters"))
    }
    #[doc = "chain flags\nAssociated type: \"ChainFlags\" (1 bit per enumeration)"]
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDoReply::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetchainDoReply", "Flags"))
    }
    #[doc = "uniquely identifies a chain in a transaction"]
    pub fn get_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDoReply::Id(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetchainDoReply", "Id"))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDoReply::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetchainDoReply", "Userdata"))
    }
}
impl<'a> OpGetchainDoReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpGetchainDoReply<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        ChainAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpGetchainDoReply<'a>> {
    type Item = Result<OpGetchainDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetchainDoReply::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetchainDoReply::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetchainDoReply::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpGetchainDoReply::Hook({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpGetchainDoReply::Policy({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpGetchainDoReply::Use({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpGetchainDoReply::Type({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpGetchainDoReply::Counters({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => OpGetchainDoReply::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => OpGetchainDoReply::Id({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => OpGetchainDoReply::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpGetchainDoReply",
            r#type.and_then(|t| OpGetchainDoReply::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpGetchainDoReply<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetchainDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetchainDoReply::Table(val) => fmt.field("Table", &val),
                OpGetchainDoReply::Handle(val) => fmt.field("Handle", &val),
                OpGetchainDoReply::Name(val) => fmt.field("Name", &val),
                OpGetchainDoReply::Hook(val) => fmt.field("Hook", &val),
                OpGetchainDoReply::Policy(val) => fmt.field("Policy", &val),
                OpGetchainDoReply::Use(val) => fmt.field("Use", &val),
                OpGetchainDoReply::Type(val) => fmt.field("Type", &val),
                OpGetchainDoReply::Counters(val) => fmt.field("Counters", &val),
                OpGetchainDoReply::Flags(val) => {
                    fmt.field("Flags", &FormatFlags(val.into(), ChainFlags::from_value))
                }
                OpGetchainDoReply::Id(val) => fmt.field("Id", &val),
                OpGetchainDoReply::Userdata(val) => fmt.field("Userdata", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpGetchainDoReply<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetchainDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetchainDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetchainDoReply::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpGetchainDoReply::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpGetchainDoReply::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpGetchainDoReply::Hook(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetchainDoReply::Policy(val) => {
                    if last_off == offset {
                        stack.push(("Policy", last_off));
                        break;
                    }
                }
                OpGetchainDoReply::Use(val) => {
                    if last_off == offset {
                        stack.push(("Use", last_off));
                        break;
                    }
                }
                OpGetchainDoReply::Type(val) => {
                    if last_off == offset {
                        stack.push(("Type", last_off));
                        break;
                    }
                }
                OpGetchainDoReply::Counters(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetchainDoReply::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                OpGetchainDoReply::Id(val) => {
                    if last_off == offset {
                        stack.push(("Id", last_off));
                        break;
                    }
                }
                OpGetchainDoReply::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetchainDoReply", cur));
        }
        (stack, missing)
    }
}
#[derive(Debug)]
pub struct RequestOpGetchainDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpGetchainDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpGetchainDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpGetchainDoRequest<&mut Vec<u8>> {
        PushOpGetchainDoRequest::new_without_header(self.request.buf_mut())
    }
}
impl NetlinkRequest for RequestOpGetchainDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, Iterable<'buf, OpGetchainDoReply<'buf>>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2564u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpGetchainDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpGetchainDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Delete an existing chain."]
pub struct PushOpDelchainDoRequest<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDelchainDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDelchainDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the chain"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the chain"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "numeric handle of the chain"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 2u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "name of the chain"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            3u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the chain"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 3u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "hook specification for basechains"]
    pub fn nested_hook(mut self) -> PushNftHookAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushNftHookAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "numeric policy of the chain"]
    pub fn push_policy(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "number of references to this chain"]
    pub fn push_use(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "type name of the chain"]
    pub fn push_type(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            7u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "type name of the chain"]
    pub fn push_type_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 7u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "counter specification of the chain"]
    pub fn nested_counters(mut self) -> PushNftCounterAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 8u16);
        PushNftCounterAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "chain flags\nAssociated type: \"ChainFlags\" (1 bit per enumeration)"]
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 9u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "uniquely identifies a chain in a transaction"]
    pub fn push_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 10u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 11u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushOpDelchainDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete an existing chain."]
#[doc = "Original name: \"op-delchain-do-request\""]
#[derive(Clone)]
pub enum OpDelchainDoRequest<'a> {
    #[doc = "name of the table containing the chain"]
    Table(&'a CStr),
    #[doc = "numeric handle of the chain"]
    Handle(u64),
    #[doc = "name of the chain"]
    Name(&'a CStr),
    #[doc = "hook specification for basechains"]
    Hook(Iterable<'a, NftHookAttrs<'a>>),
    #[doc = "numeric policy of the chain"]
    Policy(u32),
    #[doc = "number of references to this chain"]
    Use(u32),
    #[doc = "type name of the chain"]
    Type(&'a CStr),
    #[doc = "counter specification of the chain"]
    Counters(Iterable<'a, NftCounterAttrs>),
    #[doc = "chain flags\nAssociated type: \"ChainFlags\" (1 bit per enumeration)"]
    Flags(u32),
    #[doc = "uniquely identifies a chain in a transaction"]
    Id(u32),
    #[doc = "user data"]
    Userdata(&'a [u8]),
}
impl<'a> Iterable<'a, OpDelchainDoRequest<'a>> {
    #[doc = "name of the table containing the chain"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelchainDoRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelchainDoRequest", "Table"))
    }
    #[doc = "numeric handle of the chain"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelchainDoRequest::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelchainDoRequest", "Handle"))
    }
    #[doc = "name of the chain"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelchainDoRequest::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelchainDoRequest", "Name"))
    }
    #[doc = "hook specification for basechains"]
    pub fn get_hook(&self) -> Result<Iterable<'a, NftHookAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelchainDoRequest::Hook(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelchainDoRequest", "Hook"))
    }
    #[doc = "numeric policy of the chain"]
    pub fn get_policy(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelchainDoRequest::Policy(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelchainDoRequest", "Policy"))
    }
    #[doc = "number of references to this chain"]
    pub fn get_use(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelchainDoRequest::Use(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelchainDoRequest", "Use"))
    }
    #[doc = "type name of the chain"]
    pub fn get_type(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelchainDoRequest::Type(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelchainDoRequest", "Type"))
    }
    #[doc = "counter specification of the chain"]
    pub fn get_counters(&self) -> Result<Iterable<'a, NftCounterAttrs>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelchainDoRequest::Counters(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelchainDoRequest", "Counters"))
    }
    #[doc = "chain flags\nAssociated type: \"ChainFlags\" (1 bit per enumeration)"]
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelchainDoRequest::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelchainDoRequest", "Flags"))
    }
    #[doc = "uniquely identifies a chain in a transaction"]
    pub fn get_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelchainDoRequest::Id(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelchainDoRequest", "Id"))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelchainDoRequest::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelchainDoRequest", "Userdata"))
    }
}
impl<'a> OpDelchainDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpDelchainDoRequest<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        ChainAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpDelchainDoRequest<'a>> {
    type Item = Result<OpDelchainDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpDelchainDoRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpDelchainDoRequest::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpDelchainDoRequest::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpDelchainDoRequest::Hook({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpDelchainDoRequest::Policy({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpDelchainDoRequest::Use({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpDelchainDoRequest::Type({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpDelchainDoRequest::Counters({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => OpDelchainDoRequest::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => OpDelchainDoRequest::Id({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => OpDelchainDoRequest::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpDelchainDoRequest",
            r#type.and_then(|t| OpDelchainDoRequest::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpDelchainDoRequest<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDelchainDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpDelchainDoRequest::Table(val) => fmt.field("Table", &val),
                OpDelchainDoRequest::Handle(val) => fmt.field("Handle", &val),
                OpDelchainDoRequest::Name(val) => fmt.field("Name", &val),
                OpDelchainDoRequest::Hook(val) => fmt.field("Hook", &val),
                OpDelchainDoRequest::Policy(val) => fmt.field("Policy", &val),
                OpDelchainDoRequest::Use(val) => fmt.field("Use", &val),
                OpDelchainDoRequest::Type(val) => fmt.field("Type", &val),
                OpDelchainDoRequest::Counters(val) => fmt.field("Counters", &val),
                OpDelchainDoRequest::Flags(val) => {
                    fmt.field("Flags", &FormatFlags(val.into(), ChainFlags::from_value))
                }
                OpDelchainDoRequest::Id(val) => fmt.field("Id", &val),
                OpDelchainDoRequest::Userdata(val) => fmt.field("Userdata", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpDelchainDoRequest<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpDelchainDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDelchainDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpDelchainDoRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpDelchainDoRequest::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpDelchainDoRequest::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpDelchainDoRequest::Hook(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpDelchainDoRequest::Policy(val) => {
                    if last_off == offset {
                        stack.push(("Policy", last_off));
                        break;
                    }
                }
                OpDelchainDoRequest::Use(val) => {
                    if last_off == offset {
                        stack.push(("Use", last_off));
                        break;
                    }
                }
                OpDelchainDoRequest::Type(val) => {
                    if last_off == offset {
                        stack.push(("Type", last_off));
                        break;
                    }
                }
                OpDelchainDoRequest::Counters(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpDelchainDoRequest::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                OpDelchainDoRequest::Id(val) => {
                    if last_off == offset {
                        stack.push(("Id", last_off));
                        break;
                    }
                }
                OpDelchainDoRequest::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpDelchainDoRequest", cur));
        }
        (stack, missing)
    }
}
#[doc = "Delete an existing chain."]
pub struct PushOpDelchainDoReply<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDelchainDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDelchainDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the chain"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the chain"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "numeric handle of the chain"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 2u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "name of the chain"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            3u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the chain"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 3u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "hook specification for basechains"]
    pub fn nested_hook(mut self) -> PushNftHookAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushNftHookAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "numeric policy of the chain"]
    pub fn push_policy(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "number of references to this chain"]
    pub fn push_use(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "type name of the chain"]
    pub fn push_type(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            7u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "type name of the chain"]
    pub fn push_type_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 7u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "counter specification of the chain"]
    pub fn nested_counters(mut self) -> PushNftCounterAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 8u16);
        PushNftCounterAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "chain flags\nAssociated type: \"ChainFlags\" (1 bit per enumeration)"]
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 9u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "uniquely identifies a chain in a transaction"]
    pub fn push_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 10u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 11u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushOpDelchainDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete an existing chain."]
#[doc = "Original name: \"op-delchain-do-reply\""]
#[derive(Clone)]
pub enum OpDelchainDoReply<'a> {
    #[doc = "name of the table containing the chain"]
    Table(&'a CStr),
    #[doc = "numeric handle of the chain"]
    Handle(u64),
    #[doc = "name of the chain"]
    Name(&'a CStr),
    #[doc = "hook specification for basechains"]
    Hook(Iterable<'a, NftHookAttrs<'a>>),
    #[doc = "numeric policy of the chain"]
    Policy(u32),
    #[doc = "number of references to this chain"]
    Use(u32),
    #[doc = "type name of the chain"]
    Type(&'a CStr),
    #[doc = "counter specification of the chain"]
    Counters(Iterable<'a, NftCounterAttrs>),
    #[doc = "chain flags\nAssociated type: \"ChainFlags\" (1 bit per enumeration)"]
    Flags(u32),
    #[doc = "uniquely identifies a chain in a transaction"]
    Id(u32),
    #[doc = "user data"]
    Userdata(&'a [u8]),
}
impl<'a> Iterable<'a, OpDelchainDoReply<'a>> {
    #[doc = "name of the table containing the chain"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelchainDoReply::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelchainDoReply", "Table"))
    }
    #[doc = "numeric handle of the chain"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelchainDoReply::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelchainDoReply", "Handle"))
    }
    #[doc = "name of the chain"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelchainDoReply::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelchainDoReply", "Name"))
    }
    #[doc = "hook specification for basechains"]
    pub fn get_hook(&self) -> Result<Iterable<'a, NftHookAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelchainDoReply::Hook(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelchainDoReply", "Hook"))
    }
    #[doc = "numeric policy of the chain"]
    pub fn get_policy(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelchainDoReply::Policy(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelchainDoReply", "Policy"))
    }
    #[doc = "number of references to this chain"]
    pub fn get_use(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelchainDoReply::Use(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelchainDoReply", "Use"))
    }
    #[doc = "type name of the chain"]
    pub fn get_type(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelchainDoReply::Type(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelchainDoReply", "Type"))
    }
    #[doc = "counter specification of the chain"]
    pub fn get_counters(&self) -> Result<Iterable<'a, NftCounterAttrs>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelchainDoReply::Counters(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelchainDoReply", "Counters"))
    }
    #[doc = "chain flags\nAssociated type: \"ChainFlags\" (1 bit per enumeration)"]
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelchainDoReply::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelchainDoReply", "Flags"))
    }
    #[doc = "uniquely identifies a chain in a transaction"]
    pub fn get_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelchainDoReply::Id(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelchainDoReply", "Id"))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelchainDoReply::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelchainDoReply", "Userdata"))
    }
}
impl<'a> OpDelchainDoReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpDelchainDoReply<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        ChainAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpDelchainDoReply<'a>> {
    type Item = Result<OpDelchainDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpDelchainDoReply::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpDelchainDoReply::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpDelchainDoReply::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpDelchainDoReply::Hook({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpDelchainDoReply::Policy({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpDelchainDoReply::Use({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpDelchainDoReply::Type({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpDelchainDoReply::Counters({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => OpDelchainDoReply::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => OpDelchainDoReply::Id({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => OpDelchainDoReply::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpDelchainDoReply",
            r#type.and_then(|t| OpDelchainDoReply::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpDelchainDoReply<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDelchainDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpDelchainDoReply::Table(val) => fmt.field("Table", &val),
                OpDelchainDoReply::Handle(val) => fmt.field("Handle", &val),
                OpDelchainDoReply::Name(val) => fmt.field("Name", &val),
                OpDelchainDoReply::Hook(val) => fmt.field("Hook", &val),
                OpDelchainDoReply::Policy(val) => fmt.field("Policy", &val),
                OpDelchainDoReply::Use(val) => fmt.field("Use", &val),
                OpDelchainDoReply::Type(val) => fmt.field("Type", &val),
                OpDelchainDoReply::Counters(val) => fmt.field("Counters", &val),
                OpDelchainDoReply::Flags(val) => {
                    fmt.field("Flags", &FormatFlags(val.into(), ChainFlags::from_value))
                }
                OpDelchainDoReply::Id(val) => fmt.field("Id", &val),
                OpDelchainDoReply::Userdata(val) => fmt.field("Userdata", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpDelchainDoReply<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpDelchainDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDelchainDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpDelchainDoReply::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpDelchainDoReply::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpDelchainDoReply::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpDelchainDoReply::Hook(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpDelchainDoReply::Policy(val) => {
                    if last_off == offset {
                        stack.push(("Policy", last_off));
                        break;
                    }
                }
                OpDelchainDoReply::Use(val) => {
                    if last_off == offset {
                        stack.push(("Use", last_off));
                        break;
                    }
                }
                OpDelchainDoReply::Type(val) => {
                    if last_off == offset {
                        stack.push(("Type", last_off));
                        break;
                    }
                }
                OpDelchainDoReply::Counters(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpDelchainDoReply::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                OpDelchainDoReply::Id(val) => {
                    if last_off == offset {
                        stack.push(("Id", last_off));
                        break;
                    }
                }
                OpDelchainDoReply::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpDelchainDoReply", cur));
        }
        (stack, missing)
    }
}
#[derive(Debug)]
pub struct RequestOpDelchainDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpDelchainDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpDelchainDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpDelchainDoRequest<&mut Vec<u8>> {
        PushOpDelchainDoRequest::new_without_header(self.request.buf_mut())
    }
}
impl NetlinkRequest for RequestOpDelchainDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, Iterable<'buf, OpDelchainDoReply<'buf>>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2565u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpDelchainDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpDelchainDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Delete an existing chain with destroy semantics (ignoring ENOENT\nerrors).\n"]
pub struct PushOpDestroychainDoRequest<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDestroychainDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDestroychainDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the chain"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the chain"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "numeric handle of the chain"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 2u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "name of the chain"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            3u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the chain"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 3u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "hook specification for basechains"]
    pub fn nested_hook(mut self) -> PushNftHookAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushNftHookAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "numeric policy of the chain"]
    pub fn push_policy(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "number of references to this chain"]
    pub fn push_use(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "type name of the chain"]
    pub fn push_type(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            7u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "type name of the chain"]
    pub fn push_type_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 7u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "counter specification of the chain"]
    pub fn nested_counters(mut self) -> PushNftCounterAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 8u16);
        PushNftCounterAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "chain flags\nAssociated type: \"ChainFlags\" (1 bit per enumeration)"]
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 9u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "uniquely identifies a chain in a transaction"]
    pub fn push_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 10u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 11u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushOpDestroychainDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete an existing chain with destroy semantics (ignoring ENOENT\nerrors).\n"]
#[doc = "Original name: \"op-destroychain-do-request\""]
#[derive(Clone)]
pub enum OpDestroychainDoRequest<'a> {
    #[doc = "name of the table containing the chain"]
    Table(&'a CStr),
    #[doc = "numeric handle of the chain"]
    Handle(u64),
    #[doc = "name of the chain"]
    Name(&'a CStr),
    #[doc = "hook specification for basechains"]
    Hook(Iterable<'a, NftHookAttrs<'a>>),
    #[doc = "numeric policy of the chain"]
    Policy(u32),
    #[doc = "number of references to this chain"]
    Use(u32),
    #[doc = "type name of the chain"]
    Type(&'a CStr),
    #[doc = "counter specification of the chain"]
    Counters(Iterable<'a, NftCounterAttrs>),
    #[doc = "chain flags\nAssociated type: \"ChainFlags\" (1 bit per enumeration)"]
    Flags(u32),
    #[doc = "uniquely identifies a chain in a transaction"]
    Id(u32),
    #[doc = "user data"]
    Userdata(&'a [u8]),
}
impl<'a> Iterable<'a, OpDestroychainDoRequest<'a>> {
    #[doc = "name of the table containing the chain"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroychainDoRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroychainDoRequest", "Table"))
    }
    #[doc = "numeric handle of the chain"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroychainDoRequest::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroychainDoRequest", "Handle"))
    }
    #[doc = "name of the chain"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroychainDoRequest::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroychainDoRequest", "Name"))
    }
    #[doc = "hook specification for basechains"]
    pub fn get_hook(&self) -> Result<Iterable<'a, NftHookAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroychainDoRequest::Hook(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroychainDoRequest", "Hook"))
    }
    #[doc = "numeric policy of the chain"]
    pub fn get_policy(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroychainDoRequest::Policy(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroychainDoRequest", "Policy"))
    }
    #[doc = "number of references to this chain"]
    pub fn get_use(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroychainDoRequest::Use(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroychainDoRequest", "Use"))
    }
    #[doc = "type name of the chain"]
    pub fn get_type(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroychainDoRequest::Type(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroychainDoRequest", "Type"))
    }
    #[doc = "counter specification of the chain"]
    pub fn get_counters(&self) -> Result<Iterable<'a, NftCounterAttrs>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroychainDoRequest::Counters(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroychainDoRequest", "Counters"))
    }
    #[doc = "chain flags\nAssociated type: \"ChainFlags\" (1 bit per enumeration)"]
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroychainDoRequest::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroychainDoRequest", "Flags"))
    }
    #[doc = "uniquely identifies a chain in a transaction"]
    pub fn get_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroychainDoRequest::Id(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroychainDoRequest", "Id"))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroychainDoRequest::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroychainDoRequest", "Userdata"))
    }
}
impl<'a> OpDestroychainDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpDestroychainDoRequest<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        ChainAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpDestroychainDoRequest<'a>> {
    type Item = Result<OpDestroychainDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpDestroychainDoRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpDestroychainDoRequest::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpDestroychainDoRequest::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpDestroychainDoRequest::Hook({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpDestroychainDoRequest::Policy({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpDestroychainDoRequest::Use({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpDestroychainDoRequest::Type({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpDestroychainDoRequest::Counters({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => OpDestroychainDoRequest::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => OpDestroychainDoRequest::Id({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => OpDestroychainDoRequest::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpDestroychainDoRequest",
            r#type.and_then(|t| OpDestroychainDoRequest::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpDestroychainDoRequest<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDestroychainDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpDestroychainDoRequest::Table(val) => fmt.field("Table", &val),
                OpDestroychainDoRequest::Handle(val) => fmt.field("Handle", &val),
                OpDestroychainDoRequest::Name(val) => fmt.field("Name", &val),
                OpDestroychainDoRequest::Hook(val) => fmt.field("Hook", &val),
                OpDestroychainDoRequest::Policy(val) => fmt.field("Policy", &val),
                OpDestroychainDoRequest::Use(val) => fmt.field("Use", &val),
                OpDestroychainDoRequest::Type(val) => fmt.field("Type", &val),
                OpDestroychainDoRequest::Counters(val) => fmt.field("Counters", &val),
                OpDestroychainDoRequest::Flags(val) => {
                    fmt.field("Flags", &FormatFlags(val.into(), ChainFlags::from_value))
                }
                OpDestroychainDoRequest::Id(val) => fmt.field("Id", &val),
                OpDestroychainDoRequest::Userdata(val) => fmt.field("Userdata", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpDestroychainDoRequest<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpDestroychainDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDestroychainDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpDestroychainDoRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpDestroychainDoRequest::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpDestroychainDoRequest::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpDestroychainDoRequest::Hook(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpDestroychainDoRequest::Policy(val) => {
                    if last_off == offset {
                        stack.push(("Policy", last_off));
                        break;
                    }
                }
                OpDestroychainDoRequest::Use(val) => {
                    if last_off == offset {
                        stack.push(("Use", last_off));
                        break;
                    }
                }
                OpDestroychainDoRequest::Type(val) => {
                    if last_off == offset {
                        stack.push(("Type", last_off));
                        break;
                    }
                }
                OpDestroychainDoRequest::Counters(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpDestroychainDoRequest::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                OpDestroychainDoRequest::Id(val) => {
                    if last_off == offset {
                        stack.push(("Id", last_off));
                        break;
                    }
                }
                OpDestroychainDoRequest::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpDestroychainDoRequest", cur));
        }
        (stack, missing)
    }
}
#[doc = "Delete an existing chain with destroy semantics (ignoring ENOENT\nerrors).\n"]
pub struct PushOpDestroychainDoReply<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDestroychainDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDestroychainDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the chain"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the chain"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "numeric handle of the chain"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 2u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "name of the chain"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            3u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the chain"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 3u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "hook specification for basechains"]
    pub fn nested_hook(mut self) -> PushNftHookAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushNftHookAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "numeric policy of the chain"]
    pub fn push_policy(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "number of references to this chain"]
    pub fn push_use(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "type name of the chain"]
    pub fn push_type(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            7u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "type name of the chain"]
    pub fn push_type_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 7u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "counter specification of the chain"]
    pub fn nested_counters(mut self) -> PushNftCounterAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 8u16);
        PushNftCounterAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "chain flags\nAssociated type: \"ChainFlags\" (1 bit per enumeration)"]
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 9u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "uniquely identifies a chain in a transaction"]
    pub fn push_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 10u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 11u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushOpDestroychainDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete an existing chain with destroy semantics (ignoring ENOENT\nerrors).\n"]
#[doc = "Original name: \"op-destroychain-do-reply\""]
#[derive(Clone)]
pub enum OpDestroychainDoReply<'a> {
    #[doc = "name of the table containing the chain"]
    Table(&'a CStr),
    #[doc = "numeric handle of the chain"]
    Handle(u64),
    #[doc = "name of the chain"]
    Name(&'a CStr),
    #[doc = "hook specification for basechains"]
    Hook(Iterable<'a, NftHookAttrs<'a>>),
    #[doc = "numeric policy of the chain"]
    Policy(u32),
    #[doc = "number of references to this chain"]
    Use(u32),
    #[doc = "type name of the chain"]
    Type(&'a CStr),
    #[doc = "counter specification of the chain"]
    Counters(Iterable<'a, NftCounterAttrs>),
    #[doc = "chain flags\nAssociated type: \"ChainFlags\" (1 bit per enumeration)"]
    Flags(u32),
    #[doc = "uniquely identifies a chain in a transaction"]
    Id(u32),
    #[doc = "user data"]
    Userdata(&'a [u8]),
}
impl<'a> Iterable<'a, OpDestroychainDoReply<'a>> {
    #[doc = "name of the table containing the chain"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroychainDoReply::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroychainDoReply", "Table"))
    }
    #[doc = "numeric handle of the chain"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroychainDoReply::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroychainDoReply", "Handle"))
    }
    #[doc = "name of the chain"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroychainDoReply::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroychainDoReply", "Name"))
    }
    #[doc = "hook specification for basechains"]
    pub fn get_hook(&self) -> Result<Iterable<'a, NftHookAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroychainDoReply::Hook(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroychainDoReply", "Hook"))
    }
    #[doc = "numeric policy of the chain"]
    pub fn get_policy(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroychainDoReply::Policy(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroychainDoReply", "Policy"))
    }
    #[doc = "number of references to this chain"]
    pub fn get_use(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroychainDoReply::Use(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroychainDoReply", "Use"))
    }
    #[doc = "type name of the chain"]
    pub fn get_type(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroychainDoReply::Type(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroychainDoReply", "Type"))
    }
    #[doc = "counter specification of the chain"]
    pub fn get_counters(&self) -> Result<Iterable<'a, NftCounterAttrs>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroychainDoReply::Counters(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroychainDoReply", "Counters"))
    }
    #[doc = "chain flags\nAssociated type: \"ChainFlags\" (1 bit per enumeration)"]
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroychainDoReply::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroychainDoReply", "Flags"))
    }
    #[doc = "uniquely identifies a chain in a transaction"]
    pub fn get_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroychainDoReply::Id(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroychainDoReply", "Id"))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroychainDoReply::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroychainDoReply", "Userdata"))
    }
}
impl<'a> OpDestroychainDoReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpDestroychainDoReply<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        ChainAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpDestroychainDoReply<'a>> {
    type Item = Result<OpDestroychainDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpDestroychainDoReply::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpDestroychainDoReply::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpDestroychainDoReply::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpDestroychainDoReply::Hook({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpDestroychainDoReply::Policy({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpDestroychainDoReply::Use({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpDestroychainDoReply::Type({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpDestroychainDoReply::Counters({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => OpDestroychainDoReply::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => OpDestroychainDoReply::Id({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => OpDestroychainDoReply::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpDestroychainDoReply",
            r#type.and_then(|t| OpDestroychainDoReply::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpDestroychainDoReply<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDestroychainDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpDestroychainDoReply::Table(val) => fmt.field("Table", &val),
                OpDestroychainDoReply::Handle(val) => fmt.field("Handle", &val),
                OpDestroychainDoReply::Name(val) => fmt.field("Name", &val),
                OpDestroychainDoReply::Hook(val) => fmt.field("Hook", &val),
                OpDestroychainDoReply::Policy(val) => fmt.field("Policy", &val),
                OpDestroychainDoReply::Use(val) => fmt.field("Use", &val),
                OpDestroychainDoReply::Type(val) => fmt.field("Type", &val),
                OpDestroychainDoReply::Counters(val) => fmt.field("Counters", &val),
                OpDestroychainDoReply::Flags(val) => {
                    fmt.field("Flags", &FormatFlags(val.into(), ChainFlags::from_value))
                }
                OpDestroychainDoReply::Id(val) => fmt.field("Id", &val),
                OpDestroychainDoReply::Userdata(val) => fmt.field("Userdata", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpDestroychainDoReply<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpDestroychainDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDestroychainDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpDestroychainDoReply::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpDestroychainDoReply::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpDestroychainDoReply::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpDestroychainDoReply::Hook(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpDestroychainDoReply::Policy(val) => {
                    if last_off == offset {
                        stack.push(("Policy", last_off));
                        break;
                    }
                }
                OpDestroychainDoReply::Use(val) => {
                    if last_off == offset {
                        stack.push(("Use", last_off));
                        break;
                    }
                }
                OpDestroychainDoReply::Type(val) => {
                    if last_off == offset {
                        stack.push(("Type", last_off));
                        break;
                    }
                }
                OpDestroychainDoReply::Counters(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpDestroychainDoReply::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                OpDestroychainDoReply::Id(val) => {
                    if last_off == offset {
                        stack.push(("Id", last_off));
                        break;
                    }
                }
                OpDestroychainDoReply::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpDestroychainDoReply", cur));
        }
        (stack, missing)
    }
}
#[derive(Debug)]
pub struct RequestOpDestroychainDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpDestroychainDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpDestroychainDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpDestroychainDoRequest<&mut Vec<u8>> {
        PushOpDestroychainDoRequest::new_without_header(self.request.buf_mut())
    }
}
impl NetlinkRequest for RequestOpDestroychainDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, Iterable<'buf, OpDestroychainDoReply<'buf>>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2587u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpDestroychainDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpDestroychainDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Create a new rule."]
pub struct PushOpNewruleDoRequest<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpNewruleDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpNewruleDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the rule"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the rule"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "name of the chain containing the rule"]
    pub fn push_chain(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the chain containing the rule"]
    pub fn push_chain_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "numeric handle of the rule"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 3u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "list of expressions"]
    pub fn nested_expressions(mut self) -> PushExprListAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushExprListAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "compatibility specifications of the rule"]
    pub fn nested_compat(mut self) -> PushRuleCompatAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 5u16);
        PushRuleCompatAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "numeric handle of the previous rule"]
    pub fn push_position(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 6u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 7u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    #[doc = "uniquely identifies a rule in a transaction"]
    pub fn push_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 8u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "transaction unique identifier of the previous rule"]
    pub fn push_position_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 9u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "add the rule to chain by ID, alternative to chain name"]
    pub fn push_chain_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 10u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpNewruleDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Create a new rule."]
#[doc = "Original name: \"op-newrule-do-request\""]
#[derive(Clone)]
pub enum OpNewruleDoRequest<'a> {
    #[doc = "name of the table containing the rule"]
    Table(&'a CStr),
    #[doc = "name of the chain containing the rule"]
    Chain(&'a CStr),
    #[doc = "numeric handle of the rule"]
    Handle(u64),
    #[doc = "list of expressions"]
    Expressions(Iterable<'a, ExprListAttrs<'a>>),
    #[doc = "compatibility specifications of the rule"]
    Compat(Iterable<'a, RuleCompatAttrs>),
    #[doc = "numeric handle of the previous rule"]
    Position(u64),
    #[doc = "user data"]
    Userdata(&'a [u8]),
    #[doc = "uniquely identifies a rule in a transaction"]
    Id(u32),
    #[doc = "transaction unique identifier of the previous rule"]
    PositionId(u32),
    #[doc = "add the rule to chain by ID, alternative to chain name"]
    ChainId(u32),
}
impl<'a> Iterable<'a, OpNewruleDoRequest<'a>> {
    #[doc = "name of the table containing the rule"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewruleDoRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewruleDoRequest", "Table"))
    }
    #[doc = "name of the chain containing the rule"]
    pub fn get_chain(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewruleDoRequest::Chain(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewruleDoRequest", "Chain"))
    }
    #[doc = "numeric handle of the rule"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewruleDoRequest::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewruleDoRequest", "Handle"))
    }
    #[doc = "list of expressions"]
    pub fn get_expressions(&self) -> Result<Iterable<'a, ExprListAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewruleDoRequest::Expressions(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewruleDoRequest", "Expressions"))
    }
    #[doc = "compatibility specifications of the rule"]
    pub fn get_compat(&self) -> Result<Iterable<'a, RuleCompatAttrs>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewruleDoRequest::Compat(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewruleDoRequest", "Compat"))
    }
    #[doc = "numeric handle of the previous rule"]
    pub fn get_position(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewruleDoRequest::Position(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewruleDoRequest", "Position"))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewruleDoRequest::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewruleDoRequest", "Userdata"))
    }
    #[doc = "uniquely identifies a rule in a transaction"]
    pub fn get_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewruleDoRequest::Id(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewruleDoRequest", "Id"))
    }
    #[doc = "transaction unique identifier of the previous rule"]
    pub fn get_position_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewruleDoRequest::PositionId(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewruleDoRequest", "PositionId"))
    }
    #[doc = "add the rule to chain by ID, alternative to chain name"]
    pub fn get_chain_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewruleDoRequest::ChainId(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewruleDoRequest", "ChainId"))
    }
}
impl<'a> OpNewruleDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpNewruleDoRequest<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        RuleAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpNewruleDoRequest<'a>> {
    type Item = Result<OpNewruleDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpNewruleDoRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpNewruleDoRequest::Chain({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpNewruleDoRequest::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpNewruleDoRequest::Expressions({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpNewruleDoRequest::Compat({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpNewruleDoRequest::Position({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpNewruleDoRequest::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpNewruleDoRequest::Id({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => OpNewruleDoRequest::PositionId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => OpNewruleDoRequest::ChainId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpNewruleDoRequest",
            r#type.and_then(|t| OpNewruleDoRequest::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpNewruleDoRequest<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpNewruleDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpNewruleDoRequest::Table(val) => fmt.field("Table", &val),
                OpNewruleDoRequest::Chain(val) => fmt.field("Chain", &val),
                OpNewruleDoRequest::Handle(val) => fmt.field("Handle", &val),
                OpNewruleDoRequest::Expressions(val) => fmt.field("Expressions", &val),
                OpNewruleDoRequest::Compat(val) => fmt.field("Compat", &val),
                OpNewruleDoRequest::Position(val) => fmt.field("Position", &val),
                OpNewruleDoRequest::Userdata(val) => fmt.field("Userdata", &val),
                OpNewruleDoRequest::Id(val) => fmt.field("Id", &val),
                OpNewruleDoRequest::PositionId(val) => fmt.field("PositionId", &val),
                OpNewruleDoRequest::ChainId(val) => fmt.field("ChainId", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpNewruleDoRequest<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpNewruleDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpNewruleDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpNewruleDoRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpNewruleDoRequest::Chain(val) => {
                    if last_off == offset {
                        stack.push(("Chain", last_off));
                        break;
                    }
                }
                OpNewruleDoRequest::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpNewruleDoRequest::Expressions(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpNewruleDoRequest::Compat(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpNewruleDoRequest::Position(val) => {
                    if last_off == offset {
                        stack.push(("Position", last_off));
                        break;
                    }
                }
                OpNewruleDoRequest::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                OpNewruleDoRequest::Id(val) => {
                    if last_off == offset {
                        stack.push(("Id", last_off));
                        break;
                    }
                }
                OpNewruleDoRequest::PositionId(val) => {
                    if last_off == offset {
                        stack.push(("PositionId", last_off));
                        break;
                    }
                }
                OpNewruleDoRequest::ChainId(val) => {
                    if last_off == offset {
                        stack.push(("ChainId", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpNewruleDoRequest", cur));
        }
        (stack, missing)
    }
}
#[doc = "Create a new rule."]
pub struct PushOpNewruleDoReply<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpNewruleDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpNewruleDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the rule"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the rule"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "name of the chain containing the rule"]
    pub fn push_chain(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the chain containing the rule"]
    pub fn push_chain_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "numeric handle of the rule"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 3u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "list of expressions"]
    pub fn nested_expressions(mut self) -> PushExprListAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushExprListAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "compatibility specifications of the rule"]
    pub fn nested_compat(mut self) -> PushRuleCompatAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 5u16);
        PushRuleCompatAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "numeric handle of the previous rule"]
    pub fn push_position(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 6u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 7u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    #[doc = "uniquely identifies a rule in a transaction"]
    pub fn push_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 8u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "transaction unique identifier of the previous rule"]
    pub fn push_position_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 9u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "add the rule to chain by ID, alternative to chain name"]
    pub fn push_chain_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 10u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpNewruleDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Create a new rule."]
#[doc = "Original name: \"op-newrule-do-reply\""]
#[derive(Clone)]
pub enum OpNewruleDoReply<'a> {
    #[doc = "name of the table containing the rule"]
    Table(&'a CStr),
    #[doc = "name of the chain containing the rule"]
    Chain(&'a CStr),
    #[doc = "numeric handle of the rule"]
    Handle(u64),
    #[doc = "list of expressions"]
    Expressions(Iterable<'a, ExprListAttrs<'a>>),
    #[doc = "compatibility specifications of the rule"]
    Compat(Iterable<'a, RuleCompatAttrs>),
    #[doc = "numeric handle of the previous rule"]
    Position(u64),
    #[doc = "user data"]
    Userdata(&'a [u8]),
    #[doc = "uniquely identifies a rule in a transaction"]
    Id(u32),
    #[doc = "transaction unique identifier of the previous rule"]
    PositionId(u32),
    #[doc = "add the rule to chain by ID, alternative to chain name"]
    ChainId(u32),
}
impl<'a> Iterable<'a, OpNewruleDoReply<'a>> {
    #[doc = "name of the table containing the rule"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewruleDoReply::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewruleDoReply", "Table"))
    }
    #[doc = "name of the chain containing the rule"]
    pub fn get_chain(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewruleDoReply::Chain(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewruleDoReply", "Chain"))
    }
    #[doc = "numeric handle of the rule"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewruleDoReply::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewruleDoReply", "Handle"))
    }
    #[doc = "list of expressions"]
    pub fn get_expressions(&self) -> Result<Iterable<'a, ExprListAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewruleDoReply::Expressions(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewruleDoReply", "Expressions"))
    }
    #[doc = "compatibility specifications of the rule"]
    pub fn get_compat(&self) -> Result<Iterable<'a, RuleCompatAttrs>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewruleDoReply::Compat(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewruleDoReply", "Compat"))
    }
    #[doc = "numeric handle of the previous rule"]
    pub fn get_position(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewruleDoReply::Position(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewruleDoReply", "Position"))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewruleDoReply::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewruleDoReply", "Userdata"))
    }
    #[doc = "uniquely identifies a rule in a transaction"]
    pub fn get_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewruleDoReply::Id(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewruleDoReply", "Id"))
    }
    #[doc = "transaction unique identifier of the previous rule"]
    pub fn get_position_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewruleDoReply::PositionId(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewruleDoReply", "PositionId"))
    }
    #[doc = "add the rule to chain by ID, alternative to chain name"]
    pub fn get_chain_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewruleDoReply::ChainId(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewruleDoReply", "ChainId"))
    }
}
impl<'a> OpNewruleDoReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpNewruleDoReply<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        RuleAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpNewruleDoReply<'a>> {
    type Item = Result<OpNewruleDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpNewruleDoReply::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpNewruleDoReply::Chain({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpNewruleDoReply::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpNewruleDoReply::Expressions({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpNewruleDoReply::Compat({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpNewruleDoReply::Position({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpNewruleDoReply::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpNewruleDoReply::Id({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => OpNewruleDoReply::PositionId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => OpNewruleDoReply::ChainId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpNewruleDoReply",
            r#type.and_then(|t| OpNewruleDoReply::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpNewruleDoReply<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpNewruleDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpNewruleDoReply::Table(val) => fmt.field("Table", &val),
                OpNewruleDoReply::Chain(val) => fmt.field("Chain", &val),
                OpNewruleDoReply::Handle(val) => fmt.field("Handle", &val),
                OpNewruleDoReply::Expressions(val) => fmt.field("Expressions", &val),
                OpNewruleDoReply::Compat(val) => fmt.field("Compat", &val),
                OpNewruleDoReply::Position(val) => fmt.field("Position", &val),
                OpNewruleDoReply::Userdata(val) => fmt.field("Userdata", &val),
                OpNewruleDoReply::Id(val) => fmt.field("Id", &val),
                OpNewruleDoReply::PositionId(val) => fmt.field("PositionId", &val),
                OpNewruleDoReply::ChainId(val) => fmt.field("ChainId", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpNewruleDoReply<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpNewruleDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpNewruleDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpNewruleDoReply::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpNewruleDoReply::Chain(val) => {
                    if last_off == offset {
                        stack.push(("Chain", last_off));
                        break;
                    }
                }
                OpNewruleDoReply::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpNewruleDoReply::Expressions(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpNewruleDoReply::Compat(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpNewruleDoReply::Position(val) => {
                    if last_off == offset {
                        stack.push(("Position", last_off));
                        break;
                    }
                }
                OpNewruleDoReply::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                OpNewruleDoReply::Id(val) => {
                    if last_off == offset {
                        stack.push(("Id", last_off));
                        break;
                    }
                }
                OpNewruleDoReply::PositionId(val) => {
                    if last_off == offset {
                        stack.push(("PositionId", last_off));
                        break;
                    }
                }
                OpNewruleDoReply::ChainId(val) => {
                    if last_off == offset {
                        stack.push(("ChainId", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpNewruleDoReply", cur));
        }
        (stack, missing)
    }
}
#[derive(Debug)]
pub struct RequestOpNewruleDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpNewruleDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpNewruleDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpNewruleDoRequest<&mut Vec<u8>> {
        PushOpNewruleDoRequest::new_without_header(self.request.buf_mut())
    }
}
impl NetlinkRequest for RequestOpNewruleDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, Iterable<'buf, OpNewruleDoReply<'buf>>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2566u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpNewruleDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpNewruleDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Get / dump rules."]
pub struct PushOpGetruleDumpRequest<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetruleDumpRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetruleDumpRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the rule"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the rule"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "name of the chain containing the rule"]
    pub fn push_chain(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the chain containing the rule"]
    pub fn push_chain_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "numeric handle of the rule"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 3u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "list of expressions"]
    pub fn nested_expressions(mut self) -> PushExprListAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushExprListAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "compatibility specifications of the rule"]
    pub fn nested_compat(mut self) -> PushRuleCompatAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 5u16);
        PushRuleCompatAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "numeric handle of the previous rule"]
    pub fn push_position(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 6u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 7u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    #[doc = "uniquely identifies a rule in a transaction"]
    pub fn push_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 8u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "transaction unique identifier of the previous rule"]
    pub fn push_position_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 9u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "add the rule to chain by ID, alternative to chain name"]
    pub fn push_chain_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 10u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetruleDumpRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump rules."]
#[doc = "Original name: \"op-getrule-dump-request\""]
#[derive(Clone)]
pub enum OpGetruleDumpRequest<'a> {
    #[doc = "name of the table containing the rule"]
    Table(&'a CStr),
    #[doc = "name of the chain containing the rule"]
    Chain(&'a CStr),
    #[doc = "numeric handle of the rule"]
    Handle(u64),
    #[doc = "list of expressions"]
    Expressions(Iterable<'a, ExprListAttrs<'a>>),
    #[doc = "compatibility specifications of the rule"]
    Compat(Iterable<'a, RuleCompatAttrs>),
    #[doc = "numeric handle of the previous rule"]
    Position(u64),
    #[doc = "user data"]
    Userdata(&'a [u8]),
    #[doc = "uniquely identifies a rule in a transaction"]
    Id(u32),
    #[doc = "transaction unique identifier of the previous rule"]
    PositionId(u32),
    #[doc = "add the rule to chain by ID, alternative to chain name"]
    ChainId(u32),
}
impl<'a> Iterable<'a, OpGetruleDumpRequest<'a>> {
    #[doc = "name of the table containing the rule"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleDumpRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleDumpRequest", "Table"))
    }
    #[doc = "name of the chain containing the rule"]
    pub fn get_chain(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleDumpRequest::Chain(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleDumpRequest", "Chain"))
    }
    #[doc = "numeric handle of the rule"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleDumpRequest::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleDumpRequest", "Handle"))
    }
    #[doc = "list of expressions"]
    pub fn get_expressions(&self) -> Result<Iterable<'a, ExprListAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleDumpRequest::Expressions(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleDumpRequest", "Expressions"))
    }
    #[doc = "compatibility specifications of the rule"]
    pub fn get_compat(&self) -> Result<Iterable<'a, RuleCompatAttrs>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleDumpRequest::Compat(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleDumpRequest", "Compat"))
    }
    #[doc = "numeric handle of the previous rule"]
    pub fn get_position(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleDumpRequest::Position(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleDumpRequest", "Position"))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleDumpRequest::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleDumpRequest", "Userdata"))
    }
    #[doc = "uniquely identifies a rule in a transaction"]
    pub fn get_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleDumpRequest::Id(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleDumpRequest", "Id"))
    }
    #[doc = "transaction unique identifier of the previous rule"]
    pub fn get_position_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleDumpRequest::PositionId(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleDumpRequest", "PositionId"))
    }
    #[doc = "add the rule to chain by ID, alternative to chain name"]
    pub fn get_chain_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleDumpRequest::ChainId(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleDumpRequest", "ChainId"))
    }
}
impl<'a> OpGetruleDumpRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpGetruleDumpRequest<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        RuleAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpGetruleDumpRequest<'a>> {
    type Item = Result<OpGetruleDumpRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetruleDumpRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetruleDumpRequest::Chain({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetruleDumpRequest::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpGetruleDumpRequest::Expressions({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpGetruleDumpRequest::Compat({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpGetruleDumpRequest::Position({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpGetruleDumpRequest::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpGetruleDumpRequest::Id({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => OpGetruleDumpRequest::PositionId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => OpGetruleDumpRequest::ChainId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpGetruleDumpRequest",
            r#type.and_then(|t| OpGetruleDumpRequest::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpGetruleDumpRequest<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetruleDumpRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetruleDumpRequest::Table(val) => fmt.field("Table", &val),
                OpGetruleDumpRequest::Chain(val) => fmt.field("Chain", &val),
                OpGetruleDumpRequest::Handle(val) => fmt.field("Handle", &val),
                OpGetruleDumpRequest::Expressions(val) => fmt.field("Expressions", &val),
                OpGetruleDumpRequest::Compat(val) => fmt.field("Compat", &val),
                OpGetruleDumpRequest::Position(val) => fmt.field("Position", &val),
                OpGetruleDumpRequest::Userdata(val) => fmt.field("Userdata", &val),
                OpGetruleDumpRequest::Id(val) => fmt.field("Id", &val),
                OpGetruleDumpRequest::PositionId(val) => fmt.field("PositionId", &val),
                OpGetruleDumpRequest::ChainId(val) => fmt.field("ChainId", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpGetruleDumpRequest<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetruleDumpRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetruleDumpRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetruleDumpRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpGetruleDumpRequest::Chain(val) => {
                    if last_off == offset {
                        stack.push(("Chain", last_off));
                        break;
                    }
                }
                OpGetruleDumpRequest::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpGetruleDumpRequest::Expressions(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetruleDumpRequest::Compat(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetruleDumpRequest::Position(val) => {
                    if last_off == offset {
                        stack.push(("Position", last_off));
                        break;
                    }
                }
                OpGetruleDumpRequest::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                OpGetruleDumpRequest::Id(val) => {
                    if last_off == offset {
                        stack.push(("Id", last_off));
                        break;
                    }
                }
                OpGetruleDumpRequest::PositionId(val) => {
                    if last_off == offset {
                        stack.push(("PositionId", last_off));
                        break;
                    }
                }
                OpGetruleDumpRequest::ChainId(val) => {
                    if last_off == offset {
                        stack.push(("ChainId", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetruleDumpRequest", cur));
        }
        (stack, missing)
    }
}
#[doc = "Get / dump rules."]
pub struct PushOpGetruleDumpReply<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetruleDumpReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetruleDumpReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the rule"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the rule"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "name of the chain containing the rule"]
    pub fn push_chain(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the chain containing the rule"]
    pub fn push_chain_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "numeric handle of the rule"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 3u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "list of expressions"]
    pub fn nested_expressions(mut self) -> PushExprListAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushExprListAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "compatibility specifications of the rule"]
    pub fn nested_compat(mut self) -> PushRuleCompatAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 5u16);
        PushRuleCompatAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "numeric handle of the previous rule"]
    pub fn push_position(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 6u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 7u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    #[doc = "uniquely identifies a rule in a transaction"]
    pub fn push_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 8u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "transaction unique identifier of the previous rule"]
    pub fn push_position_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 9u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "add the rule to chain by ID, alternative to chain name"]
    pub fn push_chain_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 10u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetruleDumpReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump rules."]
#[doc = "Original name: \"op-getrule-dump-reply\""]
#[derive(Clone)]
pub enum OpGetruleDumpReply<'a> {
    #[doc = "name of the table containing the rule"]
    Table(&'a CStr),
    #[doc = "name of the chain containing the rule"]
    Chain(&'a CStr),
    #[doc = "numeric handle of the rule"]
    Handle(u64),
    #[doc = "list of expressions"]
    Expressions(Iterable<'a, ExprListAttrs<'a>>),
    #[doc = "compatibility specifications of the rule"]
    Compat(Iterable<'a, RuleCompatAttrs>),
    #[doc = "numeric handle of the previous rule"]
    Position(u64),
    #[doc = "user data"]
    Userdata(&'a [u8]),
    #[doc = "uniquely identifies a rule in a transaction"]
    Id(u32),
    #[doc = "transaction unique identifier of the previous rule"]
    PositionId(u32),
    #[doc = "add the rule to chain by ID, alternative to chain name"]
    ChainId(u32),
}
impl<'a> Iterable<'a, OpGetruleDumpReply<'a>> {
    #[doc = "name of the table containing the rule"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleDumpReply::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleDumpReply", "Table"))
    }
    #[doc = "name of the chain containing the rule"]
    pub fn get_chain(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleDumpReply::Chain(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleDumpReply", "Chain"))
    }
    #[doc = "numeric handle of the rule"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleDumpReply::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleDumpReply", "Handle"))
    }
    #[doc = "list of expressions"]
    pub fn get_expressions(&self) -> Result<Iterable<'a, ExprListAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleDumpReply::Expressions(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleDumpReply", "Expressions"))
    }
    #[doc = "compatibility specifications of the rule"]
    pub fn get_compat(&self) -> Result<Iterable<'a, RuleCompatAttrs>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleDumpReply::Compat(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleDumpReply", "Compat"))
    }
    #[doc = "numeric handle of the previous rule"]
    pub fn get_position(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleDumpReply::Position(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleDumpReply", "Position"))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleDumpReply::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleDumpReply", "Userdata"))
    }
    #[doc = "uniquely identifies a rule in a transaction"]
    pub fn get_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleDumpReply::Id(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleDumpReply", "Id"))
    }
    #[doc = "transaction unique identifier of the previous rule"]
    pub fn get_position_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleDumpReply::PositionId(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleDumpReply", "PositionId"))
    }
    #[doc = "add the rule to chain by ID, alternative to chain name"]
    pub fn get_chain_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleDumpReply::ChainId(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleDumpReply", "ChainId"))
    }
}
impl<'a> OpGetruleDumpReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpGetruleDumpReply<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        RuleAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpGetruleDumpReply<'a>> {
    type Item = Result<OpGetruleDumpReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetruleDumpReply::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetruleDumpReply::Chain({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetruleDumpReply::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpGetruleDumpReply::Expressions({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpGetruleDumpReply::Compat({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpGetruleDumpReply::Position({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpGetruleDumpReply::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpGetruleDumpReply::Id({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => OpGetruleDumpReply::PositionId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => OpGetruleDumpReply::ChainId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpGetruleDumpReply",
            r#type.and_then(|t| OpGetruleDumpReply::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpGetruleDumpReply<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetruleDumpReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetruleDumpReply::Table(val) => fmt.field("Table", &val),
                OpGetruleDumpReply::Chain(val) => fmt.field("Chain", &val),
                OpGetruleDumpReply::Handle(val) => fmt.field("Handle", &val),
                OpGetruleDumpReply::Expressions(val) => fmt.field("Expressions", &val),
                OpGetruleDumpReply::Compat(val) => fmt.field("Compat", &val),
                OpGetruleDumpReply::Position(val) => fmt.field("Position", &val),
                OpGetruleDumpReply::Userdata(val) => fmt.field("Userdata", &val),
                OpGetruleDumpReply::Id(val) => fmt.field("Id", &val),
                OpGetruleDumpReply::PositionId(val) => fmt.field("PositionId", &val),
                OpGetruleDumpReply::ChainId(val) => fmt.field("ChainId", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpGetruleDumpReply<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetruleDumpReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetruleDumpReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetruleDumpReply::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpGetruleDumpReply::Chain(val) => {
                    if last_off == offset {
                        stack.push(("Chain", last_off));
                        break;
                    }
                }
                OpGetruleDumpReply::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpGetruleDumpReply::Expressions(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetruleDumpReply::Compat(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetruleDumpReply::Position(val) => {
                    if last_off == offset {
                        stack.push(("Position", last_off));
                        break;
                    }
                }
                OpGetruleDumpReply::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                OpGetruleDumpReply::Id(val) => {
                    if last_off == offset {
                        stack.push(("Id", last_off));
                        break;
                    }
                }
                OpGetruleDumpReply::PositionId(val) => {
                    if last_off == offset {
                        stack.push(("PositionId", last_off));
                        break;
                    }
                }
                OpGetruleDumpReply::ChainId(val) => {
                    if last_off == offset {
                        stack.push(("ChainId", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetruleDumpReply", cur));
        }
        (stack, missing)
    }
}
#[derive(Debug)]
pub struct RequestOpGetruleDumpRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpGetruleDumpRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpGetruleDumpRequest::write_header(&mut request.buf_mut(), header);
        Self {
            request: request.set_dump(),
        }
    }
    pub fn encode(&mut self) -> PushOpGetruleDumpRequest<&mut Vec<u8>> {
        PushOpGetruleDumpRequest::new_without_header(self.request.buf_mut())
    }
}
impl NetlinkRequest for RequestOpGetruleDumpRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, Iterable<'buf, OpGetruleDumpReply<'buf>>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2567u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpGetruleDumpReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpGetruleDumpRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Get / dump rules."]
pub struct PushOpGetruleDoRequest<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetruleDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetruleDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the rule"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the rule"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "name of the chain containing the rule"]
    pub fn push_chain(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the chain containing the rule"]
    pub fn push_chain_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "numeric handle of the rule"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 3u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "list of expressions"]
    pub fn nested_expressions(mut self) -> PushExprListAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushExprListAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "compatibility specifications of the rule"]
    pub fn nested_compat(mut self) -> PushRuleCompatAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 5u16);
        PushRuleCompatAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "numeric handle of the previous rule"]
    pub fn push_position(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 6u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 7u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    #[doc = "uniquely identifies a rule in a transaction"]
    pub fn push_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 8u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "transaction unique identifier of the previous rule"]
    pub fn push_position_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 9u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "add the rule to chain by ID, alternative to chain name"]
    pub fn push_chain_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 10u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetruleDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump rules."]
#[doc = "Original name: \"op-getrule-do-request\""]
#[derive(Clone)]
pub enum OpGetruleDoRequest<'a> {
    #[doc = "name of the table containing the rule"]
    Table(&'a CStr),
    #[doc = "name of the chain containing the rule"]
    Chain(&'a CStr),
    #[doc = "numeric handle of the rule"]
    Handle(u64),
    #[doc = "list of expressions"]
    Expressions(Iterable<'a, ExprListAttrs<'a>>),
    #[doc = "compatibility specifications of the rule"]
    Compat(Iterable<'a, RuleCompatAttrs>),
    #[doc = "numeric handle of the previous rule"]
    Position(u64),
    #[doc = "user data"]
    Userdata(&'a [u8]),
    #[doc = "uniquely identifies a rule in a transaction"]
    Id(u32),
    #[doc = "transaction unique identifier of the previous rule"]
    PositionId(u32),
    #[doc = "add the rule to chain by ID, alternative to chain name"]
    ChainId(u32),
}
impl<'a> Iterable<'a, OpGetruleDoRequest<'a>> {
    #[doc = "name of the table containing the rule"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleDoRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleDoRequest", "Table"))
    }
    #[doc = "name of the chain containing the rule"]
    pub fn get_chain(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleDoRequest::Chain(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleDoRequest", "Chain"))
    }
    #[doc = "numeric handle of the rule"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleDoRequest::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleDoRequest", "Handle"))
    }
    #[doc = "list of expressions"]
    pub fn get_expressions(&self) -> Result<Iterable<'a, ExprListAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleDoRequest::Expressions(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleDoRequest", "Expressions"))
    }
    #[doc = "compatibility specifications of the rule"]
    pub fn get_compat(&self) -> Result<Iterable<'a, RuleCompatAttrs>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleDoRequest::Compat(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleDoRequest", "Compat"))
    }
    #[doc = "numeric handle of the previous rule"]
    pub fn get_position(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleDoRequest::Position(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleDoRequest", "Position"))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleDoRequest::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleDoRequest", "Userdata"))
    }
    #[doc = "uniquely identifies a rule in a transaction"]
    pub fn get_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleDoRequest::Id(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleDoRequest", "Id"))
    }
    #[doc = "transaction unique identifier of the previous rule"]
    pub fn get_position_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleDoRequest::PositionId(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleDoRequest", "PositionId"))
    }
    #[doc = "add the rule to chain by ID, alternative to chain name"]
    pub fn get_chain_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleDoRequest::ChainId(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleDoRequest", "ChainId"))
    }
}
impl<'a> OpGetruleDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpGetruleDoRequest<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        RuleAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpGetruleDoRequest<'a>> {
    type Item = Result<OpGetruleDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetruleDoRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetruleDoRequest::Chain({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetruleDoRequest::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpGetruleDoRequest::Expressions({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpGetruleDoRequest::Compat({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpGetruleDoRequest::Position({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpGetruleDoRequest::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpGetruleDoRequest::Id({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => OpGetruleDoRequest::PositionId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => OpGetruleDoRequest::ChainId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpGetruleDoRequest",
            r#type.and_then(|t| OpGetruleDoRequest::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpGetruleDoRequest<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetruleDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetruleDoRequest::Table(val) => fmt.field("Table", &val),
                OpGetruleDoRequest::Chain(val) => fmt.field("Chain", &val),
                OpGetruleDoRequest::Handle(val) => fmt.field("Handle", &val),
                OpGetruleDoRequest::Expressions(val) => fmt.field("Expressions", &val),
                OpGetruleDoRequest::Compat(val) => fmt.field("Compat", &val),
                OpGetruleDoRequest::Position(val) => fmt.field("Position", &val),
                OpGetruleDoRequest::Userdata(val) => fmt.field("Userdata", &val),
                OpGetruleDoRequest::Id(val) => fmt.field("Id", &val),
                OpGetruleDoRequest::PositionId(val) => fmt.field("PositionId", &val),
                OpGetruleDoRequest::ChainId(val) => fmt.field("ChainId", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpGetruleDoRequest<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetruleDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetruleDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetruleDoRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpGetruleDoRequest::Chain(val) => {
                    if last_off == offset {
                        stack.push(("Chain", last_off));
                        break;
                    }
                }
                OpGetruleDoRequest::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpGetruleDoRequest::Expressions(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetruleDoRequest::Compat(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetruleDoRequest::Position(val) => {
                    if last_off == offset {
                        stack.push(("Position", last_off));
                        break;
                    }
                }
                OpGetruleDoRequest::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                OpGetruleDoRequest::Id(val) => {
                    if last_off == offset {
                        stack.push(("Id", last_off));
                        break;
                    }
                }
                OpGetruleDoRequest::PositionId(val) => {
                    if last_off == offset {
                        stack.push(("PositionId", last_off));
                        break;
                    }
                }
                OpGetruleDoRequest::ChainId(val) => {
                    if last_off == offset {
                        stack.push(("ChainId", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetruleDoRequest", cur));
        }
        (stack, missing)
    }
}
#[doc = "Get / dump rules."]
pub struct PushOpGetruleDoReply<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetruleDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetruleDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the rule"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the rule"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "name of the chain containing the rule"]
    pub fn push_chain(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the chain containing the rule"]
    pub fn push_chain_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "numeric handle of the rule"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 3u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "list of expressions"]
    pub fn nested_expressions(mut self) -> PushExprListAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushExprListAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "compatibility specifications of the rule"]
    pub fn nested_compat(mut self) -> PushRuleCompatAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 5u16);
        PushRuleCompatAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "numeric handle of the previous rule"]
    pub fn push_position(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 6u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 7u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    #[doc = "uniquely identifies a rule in a transaction"]
    pub fn push_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 8u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "transaction unique identifier of the previous rule"]
    pub fn push_position_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 9u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "add the rule to chain by ID, alternative to chain name"]
    pub fn push_chain_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 10u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetruleDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump rules."]
#[doc = "Original name: \"op-getrule-do-reply\""]
#[derive(Clone)]
pub enum OpGetruleDoReply<'a> {
    #[doc = "name of the table containing the rule"]
    Table(&'a CStr),
    #[doc = "name of the chain containing the rule"]
    Chain(&'a CStr),
    #[doc = "numeric handle of the rule"]
    Handle(u64),
    #[doc = "list of expressions"]
    Expressions(Iterable<'a, ExprListAttrs<'a>>),
    #[doc = "compatibility specifications of the rule"]
    Compat(Iterable<'a, RuleCompatAttrs>),
    #[doc = "numeric handle of the previous rule"]
    Position(u64),
    #[doc = "user data"]
    Userdata(&'a [u8]),
    #[doc = "uniquely identifies a rule in a transaction"]
    Id(u32),
    #[doc = "transaction unique identifier of the previous rule"]
    PositionId(u32),
    #[doc = "add the rule to chain by ID, alternative to chain name"]
    ChainId(u32),
}
impl<'a> Iterable<'a, OpGetruleDoReply<'a>> {
    #[doc = "name of the table containing the rule"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleDoReply::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleDoReply", "Table"))
    }
    #[doc = "name of the chain containing the rule"]
    pub fn get_chain(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleDoReply::Chain(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleDoReply", "Chain"))
    }
    #[doc = "numeric handle of the rule"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleDoReply::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleDoReply", "Handle"))
    }
    #[doc = "list of expressions"]
    pub fn get_expressions(&self) -> Result<Iterable<'a, ExprListAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleDoReply::Expressions(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleDoReply", "Expressions"))
    }
    #[doc = "compatibility specifications of the rule"]
    pub fn get_compat(&self) -> Result<Iterable<'a, RuleCompatAttrs>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleDoReply::Compat(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleDoReply", "Compat"))
    }
    #[doc = "numeric handle of the previous rule"]
    pub fn get_position(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleDoReply::Position(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleDoReply", "Position"))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleDoReply::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleDoReply", "Userdata"))
    }
    #[doc = "uniquely identifies a rule in a transaction"]
    pub fn get_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleDoReply::Id(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleDoReply", "Id"))
    }
    #[doc = "transaction unique identifier of the previous rule"]
    pub fn get_position_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleDoReply::PositionId(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleDoReply", "PositionId"))
    }
    #[doc = "add the rule to chain by ID, alternative to chain name"]
    pub fn get_chain_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleDoReply::ChainId(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleDoReply", "ChainId"))
    }
}
impl<'a> OpGetruleDoReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpGetruleDoReply<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        RuleAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpGetruleDoReply<'a>> {
    type Item = Result<OpGetruleDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetruleDoReply::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetruleDoReply::Chain({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetruleDoReply::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpGetruleDoReply::Expressions({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpGetruleDoReply::Compat({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpGetruleDoReply::Position({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpGetruleDoReply::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpGetruleDoReply::Id({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => OpGetruleDoReply::PositionId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => OpGetruleDoReply::ChainId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpGetruleDoReply",
            r#type.and_then(|t| OpGetruleDoReply::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpGetruleDoReply<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetruleDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetruleDoReply::Table(val) => fmt.field("Table", &val),
                OpGetruleDoReply::Chain(val) => fmt.field("Chain", &val),
                OpGetruleDoReply::Handle(val) => fmt.field("Handle", &val),
                OpGetruleDoReply::Expressions(val) => fmt.field("Expressions", &val),
                OpGetruleDoReply::Compat(val) => fmt.field("Compat", &val),
                OpGetruleDoReply::Position(val) => fmt.field("Position", &val),
                OpGetruleDoReply::Userdata(val) => fmt.field("Userdata", &val),
                OpGetruleDoReply::Id(val) => fmt.field("Id", &val),
                OpGetruleDoReply::PositionId(val) => fmt.field("PositionId", &val),
                OpGetruleDoReply::ChainId(val) => fmt.field("ChainId", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpGetruleDoReply<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetruleDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetruleDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetruleDoReply::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpGetruleDoReply::Chain(val) => {
                    if last_off == offset {
                        stack.push(("Chain", last_off));
                        break;
                    }
                }
                OpGetruleDoReply::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpGetruleDoReply::Expressions(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetruleDoReply::Compat(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetruleDoReply::Position(val) => {
                    if last_off == offset {
                        stack.push(("Position", last_off));
                        break;
                    }
                }
                OpGetruleDoReply::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                OpGetruleDoReply::Id(val) => {
                    if last_off == offset {
                        stack.push(("Id", last_off));
                        break;
                    }
                }
                OpGetruleDoReply::PositionId(val) => {
                    if last_off == offset {
                        stack.push(("PositionId", last_off));
                        break;
                    }
                }
                OpGetruleDoReply::ChainId(val) => {
                    if last_off == offset {
                        stack.push(("ChainId", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetruleDoReply", cur));
        }
        (stack, missing)
    }
}
#[derive(Debug)]
pub struct RequestOpGetruleDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpGetruleDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpGetruleDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpGetruleDoRequest<&mut Vec<u8>> {
        PushOpGetruleDoRequest::new_without_header(self.request.buf_mut())
    }
}
impl NetlinkRequest for RequestOpGetruleDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, Iterable<'buf, OpGetruleDoReply<'buf>>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2567u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpGetruleDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpGetruleDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Get / dump rules and reset stateful expressions."]
pub struct PushOpGetruleResetDumpRequest<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetruleResetDumpRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetruleResetDumpRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the rule"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the rule"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "name of the chain containing the rule"]
    pub fn push_chain(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the chain containing the rule"]
    pub fn push_chain_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "numeric handle of the rule"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 3u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "list of expressions"]
    pub fn nested_expressions(mut self) -> PushExprListAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushExprListAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "compatibility specifications of the rule"]
    pub fn nested_compat(mut self) -> PushRuleCompatAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 5u16);
        PushRuleCompatAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "numeric handle of the previous rule"]
    pub fn push_position(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 6u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 7u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    #[doc = "uniquely identifies a rule in a transaction"]
    pub fn push_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 8u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "transaction unique identifier of the previous rule"]
    pub fn push_position_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 9u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "add the rule to chain by ID, alternative to chain name"]
    pub fn push_chain_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 10u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetruleResetDumpRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump rules and reset stateful expressions."]
#[doc = "Original name: \"op-getrule-reset-dump-request\""]
#[derive(Clone)]
pub enum OpGetruleResetDumpRequest<'a> {
    #[doc = "name of the table containing the rule"]
    Table(&'a CStr),
    #[doc = "name of the chain containing the rule"]
    Chain(&'a CStr),
    #[doc = "numeric handle of the rule"]
    Handle(u64),
    #[doc = "list of expressions"]
    Expressions(Iterable<'a, ExprListAttrs<'a>>),
    #[doc = "compatibility specifications of the rule"]
    Compat(Iterable<'a, RuleCompatAttrs>),
    #[doc = "numeric handle of the previous rule"]
    Position(u64),
    #[doc = "user data"]
    Userdata(&'a [u8]),
    #[doc = "uniquely identifies a rule in a transaction"]
    Id(u32),
    #[doc = "transaction unique identifier of the previous rule"]
    PositionId(u32),
    #[doc = "add the rule to chain by ID, alternative to chain name"]
    ChainId(u32),
}
impl<'a> Iterable<'a, OpGetruleResetDumpRequest<'a>> {
    #[doc = "name of the table containing the rule"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleResetDumpRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleResetDumpRequest", "Table"))
    }
    #[doc = "name of the chain containing the rule"]
    pub fn get_chain(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleResetDumpRequest::Chain(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleResetDumpRequest", "Chain"))
    }
    #[doc = "numeric handle of the rule"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleResetDumpRequest::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleResetDumpRequest", "Handle"))
    }
    #[doc = "list of expressions"]
    pub fn get_expressions(&self) -> Result<Iterable<'a, ExprListAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleResetDumpRequest::Expressions(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleResetDumpRequest", "Expressions"))
    }
    #[doc = "compatibility specifications of the rule"]
    pub fn get_compat(&self) -> Result<Iterable<'a, RuleCompatAttrs>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleResetDumpRequest::Compat(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleResetDumpRequest", "Compat"))
    }
    #[doc = "numeric handle of the previous rule"]
    pub fn get_position(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleResetDumpRequest::Position(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleResetDumpRequest", "Position"))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleResetDumpRequest::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleResetDumpRequest", "Userdata"))
    }
    #[doc = "uniquely identifies a rule in a transaction"]
    pub fn get_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleResetDumpRequest::Id(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleResetDumpRequest", "Id"))
    }
    #[doc = "transaction unique identifier of the previous rule"]
    pub fn get_position_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleResetDumpRequest::PositionId(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleResetDumpRequest", "PositionId"))
    }
    #[doc = "add the rule to chain by ID, alternative to chain name"]
    pub fn get_chain_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleResetDumpRequest::ChainId(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleResetDumpRequest", "ChainId"))
    }
}
impl<'a> OpGetruleResetDumpRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpGetruleResetDumpRequest<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        RuleAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpGetruleResetDumpRequest<'a>> {
    type Item = Result<OpGetruleResetDumpRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetruleResetDumpRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetruleResetDumpRequest::Chain({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetruleResetDumpRequest::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpGetruleResetDumpRequest::Expressions({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpGetruleResetDumpRequest::Compat({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpGetruleResetDumpRequest::Position({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpGetruleResetDumpRequest::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpGetruleResetDumpRequest::Id({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => OpGetruleResetDumpRequest::PositionId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => OpGetruleResetDumpRequest::ChainId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpGetruleResetDumpRequest",
            r#type.and_then(|t| OpGetruleResetDumpRequest::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpGetruleResetDumpRequest<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetruleResetDumpRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetruleResetDumpRequest::Table(val) => fmt.field("Table", &val),
                OpGetruleResetDumpRequest::Chain(val) => fmt.field("Chain", &val),
                OpGetruleResetDumpRequest::Handle(val) => fmt.field("Handle", &val),
                OpGetruleResetDumpRequest::Expressions(val) => fmt.field("Expressions", &val),
                OpGetruleResetDumpRequest::Compat(val) => fmt.field("Compat", &val),
                OpGetruleResetDumpRequest::Position(val) => fmt.field("Position", &val),
                OpGetruleResetDumpRequest::Userdata(val) => fmt.field("Userdata", &val),
                OpGetruleResetDumpRequest::Id(val) => fmt.field("Id", &val),
                OpGetruleResetDumpRequest::PositionId(val) => fmt.field("PositionId", &val),
                OpGetruleResetDumpRequest::ChainId(val) => fmt.field("ChainId", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpGetruleResetDumpRequest<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetruleResetDumpRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetruleResetDumpRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetruleResetDumpRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpGetruleResetDumpRequest::Chain(val) => {
                    if last_off == offset {
                        stack.push(("Chain", last_off));
                        break;
                    }
                }
                OpGetruleResetDumpRequest::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpGetruleResetDumpRequest::Expressions(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetruleResetDumpRequest::Compat(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetruleResetDumpRequest::Position(val) => {
                    if last_off == offset {
                        stack.push(("Position", last_off));
                        break;
                    }
                }
                OpGetruleResetDumpRequest::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                OpGetruleResetDumpRequest::Id(val) => {
                    if last_off == offset {
                        stack.push(("Id", last_off));
                        break;
                    }
                }
                OpGetruleResetDumpRequest::PositionId(val) => {
                    if last_off == offset {
                        stack.push(("PositionId", last_off));
                        break;
                    }
                }
                OpGetruleResetDumpRequest::ChainId(val) => {
                    if last_off == offset {
                        stack.push(("ChainId", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetruleResetDumpRequest", cur));
        }
        (stack, missing)
    }
}
#[doc = "Get / dump rules and reset stateful expressions."]
pub struct PushOpGetruleResetDumpReply<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetruleResetDumpReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetruleResetDumpReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the rule"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the rule"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "name of the chain containing the rule"]
    pub fn push_chain(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the chain containing the rule"]
    pub fn push_chain_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "numeric handle of the rule"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 3u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "list of expressions"]
    pub fn nested_expressions(mut self) -> PushExprListAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushExprListAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "compatibility specifications of the rule"]
    pub fn nested_compat(mut self) -> PushRuleCompatAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 5u16);
        PushRuleCompatAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "numeric handle of the previous rule"]
    pub fn push_position(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 6u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 7u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    #[doc = "uniquely identifies a rule in a transaction"]
    pub fn push_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 8u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "transaction unique identifier of the previous rule"]
    pub fn push_position_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 9u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "add the rule to chain by ID, alternative to chain name"]
    pub fn push_chain_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 10u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetruleResetDumpReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump rules and reset stateful expressions."]
#[doc = "Original name: \"op-getrule-reset-dump-reply\""]
#[derive(Clone)]
pub enum OpGetruleResetDumpReply<'a> {
    #[doc = "name of the table containing the rule"]
    Table(&'a CStr),
    #[doc = "name of the chain containing the rule"]
    Chain(&'a CStr),
    #[doc = "numeric handle of the rule"]
    Handle(u64),
    #[doc = "list of expressions"]
    Expressions(Iterable<'a, ExprListAttrs<'a>>),
    #[doc = "compatibility specifications of the rule"]
    Compat(Iterable<'a, RuleCompatAttrs>),
    #[doc = "numeric handle of the previous rule"]
    Position(u64),
    #[doc = "user data"]
    Userdata(&'a [u8]),
    #[doc = "uniquely identifies a rule in a transaction"]
    Id(u32),
    #[doc = "transaction unique identifier of the previous rule"]
    PositionId(u32),
    #[doc = "add the rule to chain by ID, alternative to chain name"]
    ChainId(u32),
}
impl<'a> Iterable<'a, OpGetruleResetDumpReply<'a>> {
    #[doc = "name of the table containing the rule"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleResetDumpReply::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleResetDumpReply", "Table"))
    }
    #[doc = "name of the chain containing the rule"]
    pub fn get_chain(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleResetDumpReply::Chain(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleResetDumpReply", "Chain"))
    }
    #[doc = "numeric handle of the rule"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleResetDumpReply::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleResetDumpReply", "Handle"))
    }
    #[doc = "list of expressions"]
    pub fn get_expressions(&self) -> Result<Iterable<'a, ExprListAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleResetDumpReply::Expressions(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleResetDumpReply", "Expressions"))
    }
    #[doc = "compatibility specifications of the rule"]
    pub fn get_compat(&self) -> Result<Iterable<'a, RuleCompatAttrs>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleResetDumpReply::Compat(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleResetDumpReply", "Compat"))
    }
    #[doc = "numeric handle of the previous rule"]
    pub fn get_position(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleResetDumpReply::Position(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleResetDumpReply", "Position"))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleResetDumpReply::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleResetDumpReply", "Userdata"))
    }
    #[doc = "uniquely identifies a rule in a transaction"]
    pub fn get_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleResetDumpReply::Id(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleResetDumpReply", "Id"))
    }
    #[doc = "transaction unique identifier of the previous rule"]
    pub fn get_position_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleResetDumpReply::PositionId(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleResetDumpReply", "PositionId"))
    }
    #[doc = "add the rule to chain by ID, alternative to chain name"]
    pub fn get_chain_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleResetDumpReply::ChainId(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleResetDumpReply", "ChainId"))
    }
}
impl<'a> OpGetruleResetDumpReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpGetruleResetDumpReply<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        RuleAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpGetruleResetDumpReply<'a>> {
    type Item = Result<OpGetruleResetDumpReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetruleResetDumpReply::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetruleResetDumpReply::Chain({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetruleResetDumpReply::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpGetruleResetDumpReply::Expressions({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpGetruleResetDumpReply::Compat({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpGetruleResetDumpReply::Position({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpGetruleResetDumpReply::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpGetruleResetDumpReply::Id({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => OpGetruleResetDumpReply::PositionId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => OpGetruleResetDumpReply::ChainId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpGetruleResetDumpReply",
            r#type.and_then(|t| OpGetruleResetDumpReply::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpGetruleResetDumpReply<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetruleResetDumpReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetruleResetDumpReply::Table(val) => fmt.field("Table", &val),
                OpGetruleResetDumpReply::Chain(val) => fmt.field("Chain", &val),
                OpGetruleResetDumpReply::Handle(val) => fmt.field("Handle", &val),
                OpGetruleResetDumpReply::Expressions(val) => fmt.field("Expressions", &val),
                OpGetruleResetDumpReply::Compat(val) => fmt.field("Compat", &val),
                OpGetruleResetDumpReply::Position(val) => fmt.field("Position", &val),
                OpGetruleResetDumpReply::Userdata(val) => fmt.field("Userdata", &val),
                OpGetruleResetDumpReply::Id(val) => fmt.field("Id", &val),
                OpGetruleResetDumpReply::PositionId(val) => fmt.field("PositionId", &val),
                OpGetruleResetDumpReply::ChainId(val) => fmt.field("ChainId", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpGetruleResetDumpReply<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetruleResetDumpReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetruleResetDumpReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetruleResetDumpReply::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpGetruleResetDumpReply::Chain(val) => {
                    if last_off == offset {
                        stack.push(("Chain", last_off));
                        break;
                    }
                }
                OpGetruleResetDumpReply::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpGetruleResetDumpReply::Expressions(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetruleResetDumpReply::Compat(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetruleResetDumpReply::Position(val) => {
                    if last_off == offset {
                        stack.push(("Position", last_off));
                        break;
                    }
                }
                OpGetruleResetDumpReply::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                OpGetruleResetDumpReply::Id(val) => {
                    if last_off == offset {
                        stack.push(("Id", last_off));
                        break;
                    }
                }
                OpGetruleResetDumpReply::PositionId(val) => {
                    if last_off == offset {
                        stack.push(("PositionId", last_off));
                        break;
                    }
                }
                OpGetruleResetDumpReply::ChainId(val) => {
                    if last_off == offset {
                        stack.push(("ChainId", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetruleResetDumpReply", cur));
        }
        (stack, missing)
    }
}
#[derive(Debug)]
pub struct RequestOpGetruleResetDumpRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpGetruleResetDumpRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpGetruleResetDumpRequest::write_header(&mut request.buf_mut(), header);
        Self {
            request: request.set_dump(),
        }
    }
    pub fn encode(&mut self) -> PushOpGetruleResetDumpRequest<&mut Vec<u8>> {
        PushOpGetruleResetDumpRequest::new_without_header(self.request.buf_mut())
    }
}
impl NetlinkRequest for RequestOpGetruleResetDumpRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, Iterable<'buf, OpGetruleResetDumpReply<'buf>>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2585u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpGetruleResetDumpReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpGetruleResetDumpRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Get / dump rules and reset stateful expressions."]
pub struct PushOpGetruleResetDoRequest<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetruleResetDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetruleResetDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the rule"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the rule"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "name of the chain containing the rule"]
    pub fn push_chain(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the chain containing the rule"]
    pub fn push_chain_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "numeric handle of the rule"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 3u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "list of expressions"]
    pub fn nested_expressions(mut self) -> PushExprListAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushExprListAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "compatibility specifications of the rule"]
    pub fn nested_compat(mut self) -> PushRuleCompatAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 5u16);
        PushRuleCompatAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "numeric handle of the previous rule"]
    pub fn push_position(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 6u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 7u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    #[doc = "uniquely identifies a rule in a transaction"]
    pub fn push_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 8u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "transaction unique identifier of the previous rule"]
    pub fn push_position_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 9u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "add the rule to chain by ID, alternative to chain name"]
    pub fn push_chain_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 10u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetruleResetDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump rules and reset stateful expressions."]
#[doc = "Original name: \"op-getrule-reset-do-request\""]
#[derive(Clone)]
pub enum OpGetruleResetDoRequest<'a> {
    #[doc = "name of the table containing the rule"]
    Table(&'a CStr),
    #[doc = "name of the chain containing the rule"]
    Chain(&'a CStr),
    #[doc = "numeric handle of the rule"]
    Handle(u64),
    #[doc = "list of expressions"]
    Expressions(Iterable<'a, ExprListAttrs<'a>>),
    #[doc = "compatibility specifications of the rule"]
    Compat(Iterable<'a, RuleCompatAttrs>),
    #[doc = "numeric handle of the previous rule"]
    Position(u64),
    #[doc = "user data"]
    Userdata(&'a [u8]),
    #[doc = "uniquely identifies a rule in a transaction"]
    Id(u32),
    #[doc = "transaction unique identifier of the previous rule"]
    PositionId(u32),
    #[doc = "add the rule to chain by ID, alternative to chain name"]
    ChainId(u32),
}
impl<'a> Iterable<'a, OpGetruleResetDoRequest<'a>> {
    #[doc = "name of the table containing the rule"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleResetDoRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleResetDoRequest", "Table"))
    }
    #[doc = "name of the chain containing the rule"]
    pub fn get_chain(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleResetDoRequest::Chain(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleResetDoRequest", "Chain"))
    }
    #[doc = "numeric handle of the rule"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleResetDoRequest::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleResetDoRequest", "Handle"))
    }
    #[doc = "list of expressions"]
    pub fn get_expressions(&self) -> Result<Iterable<'a, ExprListAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleResetDoRequest::Expressions(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleResetDoRequest", "Expressions"))
    }
    #[doc = "compatibility specifications of the rule"]
    pub fn get_compat(&self) -> Result<Iterable<'a, RuleCompatAttrs>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleResetDoRequest::Compat(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleResetDoRequest", "Compat"))
    }
    #[doc = "numeric handle of the previous rule"]
    pub fn get_position(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleResetDoRequest::Position(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleResetDoRequest", "Position"))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleResetDoRequest::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleResetDoRequest", "Userdata"))
    }
    #[doc = "uniquely identifies a rule in a transaction"]
    pub fn get_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleResetDoRequest::Id(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleResetDoRequest", "Id"))
    }
    #[doc = "transaction unique identifier of the previous rule"]
    pub fn get_position_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleResetDoRequest::PositionId(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleResetDoRequest", "PositionId"))
    }
    #[doc = "add the rule to chain by ID, alternative to chain name"]
    pub fn get_chain_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleResetDoRequest::ChainId(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleResetDoRequest", "ChainId"))
    }
}
impl<'a> OpGetruleResetDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpGetruleResetDoRequest<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        RuleAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpGetruleResetDoRequest<'a>> {
    type Item = Result<OpGetruleResetDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetruleResetDoRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetruleResetDoRequest::Chain({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetruleResetDoRequest::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpGetruleResetDoRequest::Expressions({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpGetruleResetDoRequest::Compat({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpGetruleResetDoRequest::Position({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpGetruleResetDoRequest::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpGetruleResetDoRequest::Id({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => OpGetruleResetDoRequest::PositionId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => OpGetruleResetDoRequest::ChainId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpGetruleResetDoRequest",
            r#type.and_then(|t| OpGetruleResetDoRequest::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpGetruleResetDoRequest<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetruleResetDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetruleResetDoRequest::Table(val) => fmt.field("Table", &val),
                OpGetruleResetDoRequest::Chain(val) => fmt.field("Chain", &val),
                OpGetruleResetDoRequest::Handle(val) => fmt.field("Handle", &val),
                OpGetruleResetDoRequest::Expressions(val) => fmt.field("Expressions", &val),
                OpGetruleResetDoRequest::Compat(val) => fmt.field("Compat", &val),
                OpGetruleResetDoRequest::Position(val) => fmt.field("Position", &val),
                OpGetruleResetDoRequest::Userdata(val) => fmt.field("Userdata", &val),
                OpGetruleResetDoRequest::Id(val) => fmt.field("Id", &val),
                OpGetruleResetDoRequest::PositionId(val) => fmt.field("PositionId", &val),
                OpGetruleResetDoRequest::ChainId(val) => fmt.field("ChainId", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpGetruleResetDoRequest<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetruleResetDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetruleResetDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetruleResetDoRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpGetruleResetDoRequest::Chain(val) => {
                    if last_off == offset {
                        stack.push(("Chain", last_off));
                        break;
                    }
                }
                OpGetruleResetDoRequest::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpGetruleResetDoRequest::Expressions(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetruleResetDoRequest::Compat(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetruleResetDoRequest::Position(val) => {
                    if last_off == offset {
                        stack.push(("Position", last_off));
                        break;
                    }
                }
                OpGetruleResetDoRequest::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                OpGetruleResetDoRequest::Id(val) => {
                    if last_off == offset {
                        stack.push(("Id", last_off));
                        break;
                    }
                }
                OpGetruleResetDoRequest::PositionId(val) => {
                    if last_off == offset {
                        stack.push(("PositionId", last_off));
                        break;
                    }
                }
                OpGetruleResetDoRequest::ChainId(val) => {
                    if last_off == offset {
                        stack.push(("ChainId", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetruleResetDoRequest", cur));
        }
        (stack, missing)
    }
}
#[doc = "Get / dump rules and reset stateful expressions."]
pub struct PushOpGetruleResetDoReply<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetruleResetDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetruleResetDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the rule"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the rule"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "name of the chain containing the rule"]
    pub fn push_chain(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the chain containing the rule"]
    pub fn push_chain_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "numeric handle of the rule"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 3u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "list of expressions"]
    pub fn nested_expressions(mut self) -> PushExprListAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushExprListAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "compatibility specifications of the rule"]
    pub fn nested_compat(mut self) -> PushRuleCompatAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 5u16);
        PushRuleCompatAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "numeric handle of the previous rule"]
    pub fn push_position(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 6u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 7u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    #[doc = "uniquely identifies a rule in a transaction"]
    pub fn push_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 8u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "transaction unique identifier of the previous rule"]
    pub fn push_position_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 9u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "add the rule to chain by ID, alternative to chain name"]
    pub fn push_chain_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 10u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetruleResetDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump rules and reset stateful expressions."]
#[doc = "Original name: \"op-getrule-reset-do-reply\""]
#[derive(Clone)]
pub enum OpGetruleResetDoReply<'a> {
    #[doc = "name of the table containing the rule"]
    Table(&'a CStr),
    #[doc = "name of the chain containing the rule"]
    Chain(&'a CStr),
    #[doc = "numeric handle of the rule"]
    Handle(u64),
    #[doc = "list of expressions"]
    Expressions(Iterable<'a, ExprListAttrs<'a>>),
    #[doc = "compatibility specifications of the rule"]
    Compat(Iterable<'a, RuleCompatAttrs>),
    #[doc = "numeric handle of the previous rule"]
    Position(u64),
    #[doc = "user data"]
    Userdata(&'a [u8]),
    #[doc = "uniquely identifies a rule in a transaction"]
    Id(u32),
    #[doc = "transaction unique identifier of the previous rule"]
    PositionId(u32),
    #[doc = "add the rule to chain by ID, alternative to chain name"]
    ChainId(u32),
}
impl<'a> Iterable<'a, OpGetruleResetDoReply<'a>> {
    #[doc = "name of the table containing the rule"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleResetDoReply::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleResetDoReply", "Table"))
    }
    #[doc = "name of the chain containing the rule"]
    pub fn get_chain(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleResetDoReply::Chain(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleResetDoReply", "Chain"))
    }
    #[doc = "numeric handle of the rule"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleResetDoReply::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleResetDoReply", "Handle"))
    }
    #[doc = "list of expressions"]
    pub fn get_expressions(&self) -> Result<Iterable<'a, ExprListAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleResetDoReply::Expressions(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleResetDoReply", "Expressions"))
    }
    #[doc = "compatibility specifications of the rule"]
    pub fn get_compat(&self) -> Result<Iterable<'a, RuleCompatAttrs>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleResetDoReply::Compat(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleResetDoReply", "Compat"))
    }
    #[doc = "numeric handle of the previous rule"]
    pub fn get_position(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleResetDoReply::Position(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleResetDoReply", "Position"))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleResetDoReply::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleResetDoReply", "Userdata"))
    }
    #[doc = "uniquely identifies a rule in a transaction"]
    pub fn get_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleResetDoReply::Id(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleResetDoReply", "Id"))
    }
    #[doc = "transaction unique identifier of the previous rule"]
    pub fn get_position_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleResetDoReply::PositionId(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleResetDoReply", "PositionId"))
    }
    #[doc = "add the rule to chain by ID, alternative to chain name"]
    pub fn get_chain_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleResetDoReply::ChainId(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetruleResetDoReply", "ChainId"))
    }
}
impl<'a> OpGetruleResetDoReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpGetruleResetDoReply<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        RuleAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpGetruleResetDoReply<'a>> {
    type Item = Result<OpGetruleResetDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetruleResetDoReply::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetruleResetDoReply::Chain({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetruleResetDoReply::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpGetruleResetDoReply::Expressions({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpGetruleResetDoReply::Compat({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpGetruleResetDoReply::Position({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpGetruleResetDoReply::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpGetruleResetDoReply::Id({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => OpGetruleResetDoReply::PositionId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => OpGetruleResetDoReply::ChainId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpGetruleResetDoReply",
            r#type.and_then(|t| OpGetruleResetDoReply::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpGetruleResetDoReply<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetruleResetDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetruleResetDoReply::Table(val) => fmt.field("Table", &val),
                OpGetruleResetDoReply::Chain(val) => fmt.field("Chain", &val),
                OpGetruleResetDoReply::Handle(val) => fmt.field("Handle", &val),
                OpGetruleResetDoReply::Expressions(val) => fmt.field("Expressions", &val),
                OpGetruleResetDoReply::Compat(val) => fmt.field("Compat", &val),
                OpGetruleResetDoReply::Position(val) => fmt.field("Position", &val),
                OpGetruleResetDoReply::Userdata(val) => fmt.field("Userdata", &val),
                OpGetruleResetDoReply::Id(val) => fmt.field("Id", &val),
                OpGetruleResetDoReply::PositionId(val) => fmt.field("PositionId", &val),
                OpGetruleResetDoReply::ChainId(val) => fmt.field("ChainId", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpGetruleResetDoReply<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetruleResetDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetruleResetDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetruleResetDoReply::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpGetruleResetDoReply::Chain(val) => {
                    if last_off == offset {
                        stack.push(("Chain", last_off));
                        break;
                    }
                }
                OpGetruleResetDoReply::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpGetruleResetDoReply::Expressions(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetruleResetDoReply::Compat(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetruleResetDoReply::Position(val) => {
                    if last_off == offset {
                        stack.push(("Position", last_off));
                        break;
                    }
                }
                OpGetruleResetDoReply::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                OpGetruleResetDoReply::Id(val) => {
                    if last_off == offset {
                        stack.push(("Id", last_off));
                        break;
                    }
                }
                OpGetruleResetDoReply::PositionId(val) => {
                    if last_off == offset {
                        stack.push(("PositionId", last_off));
                        break;
                    }
                }
                OpGetruleResetDoReply::ChainId(val) => {
                    if last_off == offset {
                        stack.push(("ChainId", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetruleResetDoReply", cur));
        }
        (stack, missing)
    }
}
#[derive(Debug)]
pub struct RequestOpGetruleResetDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpGetruleResetDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpGetruleResetDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpGetruleResetDoRequest<&mut Vec<u8>> {
        PushOpGetruleResetDoRequest::new_without_header(self.request.buf_mut())
    }
}
impl NetlinkRequest for RequestOpGetruleResetDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, Iterable<'buf, OpGetruleResetDoReply<'buf>>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2585u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpGetruleResetDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpGetruleResetDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Delete an existing rule."]
pub struct PushOpDelruleDoRequest<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDelruleDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDelruleDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the rule"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the rule"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "name of the chain containing the rule"]
    pub fn push_chain(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the chain containing the rule"]
    pub fn push_chain_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "numeric handle of the rule"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 3u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "list of expressions"]
    pub fn nested_expressions(mut self) -> PushExprListAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushExprListAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "compatibility specifications of the rule"]
    pub fn nested_compat(mut self) -> PushRuleCompatAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 5u16);
        PushRuleCompatAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "numeric handle of the previous rule"]
    pub fn push_position(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 6u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 7u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    #[doc = "uniquely identifies a rule in a transaction"]
    pub fn push_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 8u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "transaction unique identifier of the previous rule"]
    pub fn push_position_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 9u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "add the rule to chain by ID, alternative to chain name"]
    pub fn push_chain_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 10u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpDelruleDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete an existing rule."]
#[doc = "Original name: \"op-delrule-do-request\""]
#[derive(Clone)]
pub enum OpDelruleDoRequest<'a> {
    #[doc = "name of the table containing the rule"]
    Table(&'a CStr),
    #[doc = "name of the chain containing the rule"]
    Chain(&'a CStr),
    #[doc = "numeric handle of the rule"]
    Handle(u64),
    #[doc = "list of expressions"]
    Expressions(Iterable<'a, ExprListAttrs<'a>>),
    #[doc = "compatibility specifications of the rule"]
    Compat(Iterable<'a, RuleCompatAttrs>),
    #[doc = "numeric handle of the previous rule"]
    Position(u64),
    #[doc = "user data"]
    Userdata(&'a [u8]),
    #[doc = "uniquely identifies a rule in a transaction"]
    Id(u32),
    #[doc = "transaction unique identifier of the previous rule"]
    PositionId(u32),
    #[doc = "add the rule to chain by ID, alternative to chain name"]
    ChainId(u32),
}
impl<'a> Iterable<'a, OpDelruleDoRequest<'a>> {
    #[doc = "name of the table containing the rule"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelruleDoRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelruleDoRequest", "Table"))
    }
    #[doc = "name of the chain containing the rule"]
    pub fn get_chain(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelruleDoRequest::Chain(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelruleDoRequest", "Chain"))
    }
    #[doc = "numeric handle of the rule"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelruleDoRequest::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelruleDoRequest", "Handle"))
    }
    #[doc = "list of expressions"]
    pub fn get_expressions(&self) -> Result<Iterable<'a, ExprListAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelruleDoRequest::Expressions(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelruleDoRequest", "Expressions"))
    }
    #[doc = "compatibility specifications of the rule"]
    pub fn get_compat(&self) -> Result<Iterable<'a, RuleCompatAttrs>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelruleDoRequest::Compat(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelruleDoRequest", "Compat"))
    }
    #[doc = "numeric handle of the previous rule"]
    pub fn get_position(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelruleDoRequest::Position(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelruleDoRequest", "Position"))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelruleDoRequest::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelruleDoRequest", "Userdata"))
    }
    #[doc = "uniquely identifies a rule in a transaction"]
    pub fn get_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelruleDoRequest::Id(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelruleDoRequest", "Id"))
    }
    #[doc = "transaction unique identifier of the previous rule"]
    pub fn get_position_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelruleDoRequest::PositionId(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelruleDoRequest", "PositionId"))
    }
    #[doc = "add the rule to chain by ID, alternative to chain name"]
    pub fn get_chain_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelruleDoRequest::ChainId(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelruleDoRequest", "ChainId"))
    }
}
impl<'a> OpDelruleDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpDelruleDoRequest<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        RuleAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpDelruleDoRequest<'a>> {
    type Item = Result<OpDelruleDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpDelruleDoRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpDelruleDoRequest::Chain({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpDelruleDoRequest::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpDelruleDoRequest::Expressions({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpDelruleDoRequest::Compat({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpDelruleDoRequest::Position({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpDelruleDoRequest::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpDelruleDoRequest::Id({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => OpDelruleDoRequest::PositionId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => OpDelruleDoRequest::ChainId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpDelruleDoRequest",
            r#type.and_then(|t| OpDelruleDoRequest::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpDelruleDoRequest<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDelruleDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpDelruleDoRequest::Table(val) => fmt.field("Table", &val),
                OpDelruleDoRequest::Chain(val) => fmt.field("Chain", &val),
                OpDelruleDoRequest::Handle(val) => fmt.field("Handle", &val),
                OpDelruleDoRequest::Expressions(val) => fmt.field("Expressions", &val),
                OpDelruleDoRequest::Compat(val) => fmt.field("Compat", &val),
                OpDelruleDoRequest::Position(val) => fmt.field("Position", &val),
                OpDelruleDoRequest::Userdata(val) => fmt.field("Userdata", &val),
                OpDelruleDoRequest::Id(val) => fmt.field("Id", &val),
                OpDelruleDoRequest::PositionId(val) => fmt.field("PositionId", &val),
                OpDelruleDoRequest::ChainId(val) => fmt.field("ChainId", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpDelruleDoRequest<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpDelruleDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDelruleDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpDelruleDoRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpDelruleDoRequest::Chain(val) => {
                    if last_off == offset {
                        stack.push(("Chain", last_off));
                        break;
                    }
                }
                OpDelruleDoRequest::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpDelruleDoRequest::Expressions(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpDelruleDoRequest::Compat(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpDelruleDoRequest::Position(val) => {
                    if last_off == offset {
                        stack.push(("Position", last_off));
                        break;
                    }
                }
                OpDelruleDoRequest::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                OpDelruleDoRequest::Id(val) => {
                    if last_off == offset {
                        stack.push(("Id", last_off));
                        break;
                    }
                }
                OpDelruleDoRequest::PositionId(val) => {
                    if last_off == offset {
                        stack.push(("PositionId", last_off));
                        break;
                    }
                }
                OpDelruleDoRequest::ChainId(val) => {
                    if last_off == offset {
                        stack.push(("ChainId", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpDelruleDoRequest", cur));
        }
        (stack, missing)
    }
}
#[doc = "Delete an existing rule."]
pub struct PushOpDelruleDoReply<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDelruleDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDelruleDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the rule"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the rule"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "name of the chain containing the rule"]
    pub fn push_chain(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the chain containing the rule"]
    pub fn push_chain_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "numeric handle of the rule"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 3u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "list of expressions"]
    pub fn nested_expressions(mut self) -> PushExprListAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushExprListAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "compatibility specifications of the rule"]
    pub fn nested_compat(mut self) -> PushRuleCompatAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 5u16);
        PushRuleCompatAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "numeric handle of the previous rule"]
    pub fn push_position(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 6u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 7u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    #[doc = "uniquely identifies a rule in a transaction"]
    pub fn push_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 8u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "transaction unique identifier of the previous rule"]
    pub fn push_position_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 9u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "add the rule to chain by ID, alternative to chain name"]
    pub fn push_chain_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 10u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpDelruleDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete an existing rule."]
#[doc = "Original name: \"op-delrule-do-reply\""]
#[derive(Clone)]
pub enum OpDelruleDoReply<'a> {
    #[doc = "name of the table containing the rule"]
    Table(&'a CStr),
    #[doc = "name of the chain containing the rule"]
    Chain(&'a CStr),
    #[doc = "numeric handle of the rule"]
    Handle(u64),
    #[doc = "list of expressions"]
    Expressions(Iterable<'a, ExprListAttrs<'a>>),
    #[doc = "compatibility specifications of the rule"]
    Compat(Iterable<'a, RuleCompatAttrs>),
    #[doc = "numeric handle of the previous rule"]
    Position(u64),
    #[doc = "user data"]
    Userdata(&'a [u8]),
    #[doc = "uniquely identifies a rule in a transaction"]
    Id(u32),
    #[doc = "transaction unique identifier of the previous rule"]
    PositionId(u32),
    #[doc = "add the rule to chain by ID, alternative to chain name"]
    ChainId(u32),
}
impl<'a> Iterable<'a, OpDelruleDoReply<'a>> {
    #[doc = "name of the table containing the rule"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelruleDoReply::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelruleDoReply", "Table"))
    }
    #[doc = "name of the chain containing the rule"]
    pub fn get_chain(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelruleDoReply::Chain(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelruleDoReply", "Chain"))
    }
    #[doc = "numeric handle of the rule"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelruleDoReply::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelruleDoReply", "Handle"))
    }
    #[doc = "list of expressions"]
    pub fn get_expressions(&self) -> Result<Iterable<'a, ExprListAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelruleDoReply::Expressions(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelruleDoReply", "Expressions"))
    }
    #[doc = "compatibility specifications of the rule"]
    pub fn get_compat(&self) -> Result<Iterable<'a, RuleCompatAttrs>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelruleDoReply::Compat(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelruleDoReply", "Compat"))
    }
    #[doc = "numeric handle of the previous rule"]
    pub fn get_position(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelruleDoReply::Position(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelruleDoReply", "Position"))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelruleDoReply::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelruleDoReply", "Userdata"))
    }
    #[doc = "uniquely identifies a rule in a transaction"]
    pub fn get_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelruleDoReply::Id(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelruleDoReply", "Id"))
    }
    #[doc = "transaction unique identifier of the previous rule"]
    pub fn get_position_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelruleDoReply::PositionId(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelruleDoReply", "PositionId"))
    }
    #[doc = "add the rule to chain by ID, alternative to chain name"]
    pub fn get_chain_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelruleDoReply::ChainId(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelruleDoReply", "ChainId"))
    }
}
impl<'a> OpDelruleDoReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpDelruleDoReply<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        RuleAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpDelruleDoReply<'a>> {
    type Item = Result<OpDelruleDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpDelruleDoReply::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpDelruleDoReply::Chain({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpDelruleDoReply::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpDelruleDoReply::Expressions({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpDelruleDoReply::Compat({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpDelruleDoReply::Position({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpDelruleDoReply::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpDelruleDoReply::Id({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => OpDelruleDoReply::PositionId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => OpDelruleDoReply::ChainId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpDelruleDoReply",
            r#type.and_then(|t| OpDelruleDoReply::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpDelruleDoReply<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDelruleDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpDelruleDoReply::Table(val) => fmt.field("Table", &val),
                OpDelruleDoReply::Chain(val) => fmt.field("Chain", &val),
                OpDelruleDoReply::Handle(val) => fmt.field("Handle", &val),
                OpDelruleDoReply::Expressions(val) => fmt.field("Expressions", &val),
                OpDelruleDoReply::Compat(val) => fmt.field("Compat", &val),
                OpDelruleDoReply::Position(val) => fmt.field("Position", &val),
                OpDelruleDoReply::Userdata(val) => fmt.field("Userdata", &val),
                OpDelruleDoReply::Id(val) => fmt.field("Id", &val),
                OpDelruleDoReply::PositionId(val) => fmt.field("PositionId", &val),
                OpDelruleDoReply::ChainId(val) => fmt.field("ChainId", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpDelruleDoReply<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpDelruleDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDelruleDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpDelruleDoReply::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpDelruleDoReply::Chain(val) => {
                    if last_off == offset {
                        stack.push(("Chain", last_off));
                        break;
                    }
                }
                OpDelruleDoReply::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpDelruleDoReply::Expressions(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpDelruleDoReply::Compat(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpDelruleDoReply::Position(val) => {
                    if last_off == offset {
                        stack.push(("Position", last_off));
                        break;
                    }
                }
                OpDelruleDoReply::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                OpDelruleDoReply::Id(val) => {
                    if last_off == offset {
                        stack.push(("Id", last_off));
                        break;
                    }
                }
                OpDelruleDoReply::PositionId(val) => {
                    if last_off == offset {
                        stack.push(("PositionId", last_off));
                        break;
                    }
                }
                OpDelruleDoReply::ChainId(val) => {
                    if last_off == offset {
                        stack.push(("ChainId", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpDelruleDoReply", cur));
        }
        (stack, missing)
    }
}
#[derive(Debug)]
pub struct RequestOpDelruleDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpDelruleDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpDelruleDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpDelruleDoRequest<&mut Vec<u8>> {
        PushOpDelruleDoRequest::new_without_header(self.request.buf_mut())
    }
}
impl NetlinkRequest for RequestOpDelruleDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, Iterable<'buf, OpDelruleDoReply<'buf>>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2568u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpDelruleDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpDelruleDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Delete an existing rule with destroy semantics (ignoring ENOENT errors).\n"]
pub struct PushOpDestroyruleDoRequest<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDestroyruleDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDestroyruleDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the rule"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the rule"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "name of the chain containing the rule"]
    pub fn push_chain(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the chain containing the rule"]
    pub fn push_chain_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "numeric handle of the rule"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 3u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "list of expressions"]
    pub fn nested_expressions(mut self) -> PushExprListAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushExprListAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "compatibility specifications of the rule"]
    pub fn nested_compat(mut self) -> PushRuleCompatAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 5u16);
        PushRuleCompatAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "numeric handle of the previous rule"]
    pub fn push_position(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 6u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 7u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    #[doc = "uniquely identifies a rule in a transaction"]
    pub fn push_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 8u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "transaction unique identifier of the previous rule"]
    pub fn push_position_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 9u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "add the rule to chain by ID, alternative to chain name"]
    pub fn push_chain_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 10u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpDestroyruleDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete an existing rule with destroy semantics (ignoring ENOENT errors).\n"]
#[doc = "Original name: \"op-destroyrule-do-request\""]
#[derive(Clone)]
pub enum OpDestroyruleDoRequest<'a> {
    #[doc = "name of the table containing the rule"]
    Table(&'a CStr),
    #[doc = "name of the chain containing the rule"]
    Chain(&'a CStr),
    #[doc = "numeric handle of the rule"]
    Handle(u64),
    #[doc = "list of expressions"]
    Expressions(Iterable<'a, ExprListAttrs<'a>>),
    #[doc = "compatibility specifications of the rule"]
    Compat(Iterable<'a, RuleCompatAttrs>),
    #[doc = "numeric handle of the previous rule"]
    Position(u64),
    #[doc = "user data"]
    Userdata(&'a [u8]),
    #[doc = "uniquely identifies a rule in a transaction"]
    Id(u32),
    #[doc = "transaction unique identifier of the previous rule"]
    PositionId(u32),
    #[doc = "add the rule to chain by ID, alternative to chain name"]
    ChainId(u32),
}
impl<'a> Iterable<'a, OpDestroyruleDoRequest<'a>> {
    #[doc = "name of the table containing the rule"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyruleDoRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroyruleDoRequest", "Table"))
    }
    #[doc = "name of the chain containing the rule"]
    pub fn get_chain(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyruleDoRequest::Chain(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroyruleDoRequest", "Chain"))
    }
    #[doc = "numeric handle of the rule"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyruleDoRequest::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroyruleDoRequest", "Handle"))
    }
    #[doc = "list of expressions"]
    pub fn get_expressions(&self) -> Result<Iterable<'a, ExprListAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyruleDoRequest::Expressions(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroyruleDoRequest", "Expressions"))
    }
    #[doc = "compatibility specifications of the rule"]
    pub fn get_compat(&self) -> Result<Iterable<'a, RuleCompatAttrs>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyruleDoRequest::Compat(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroyruleDoRequest", "Compat"))
    }
    #[doc = "numeric handle of the previous rule"]
    pub fn get_position(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyruleDoRequest::Position(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroyruleDoRequest", "Position"))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyruleDoRequest::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroyruleDoRequest", "Userdata"))
    }
    #[doc = "uniquely identifies a rule in a transaction"]
    pub fn get_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyruleDoRequest::Id(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroyruleDoRequest", "Id"))
    }
    #[doc = "transaction unique identifier of the previous rule"]
    pub fn get_position_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyruleDoRequest::PositionId(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroyruleDoRequest", "PositionId"))
    }
    #[doc = "add the rule to chain by ID, alternative to chain name"]
    pub fn get_chain_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyruleDoRequest::ChainId(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroyruleDoRequest", "ChainId"))
    }
}
impl<'a> OpDestroyruleDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpDestroyruleDoRequest<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        RuleAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpDestroyruleDoRequest<'a>> {
    type Item = Result<OpDestroyruleDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpDestroyruleDoRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpDestroyruleDoRequest::Chain({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpDestroyruleDoRequest::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpDestroyruleDoRequest::Expressions({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpDestroyruleDoRequest::Compat({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpDestroyruleDoRequest::Position({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpDestroyruleDoRequest::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpDestroyruleDoRequest::Id({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => OpDestroyruleDoRequest::PositionId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => OpDestroyruleDoRequest::ChainId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpDestroyruleDoRequest",
            r#type.and_then(|t| OpDestroyruleDoRequest::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpDestroyruleDoRequest<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDestroyruleDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpDestroyruleDoRequest::Table(val) => fmt.field("Table", &val),
                OpDestroyruleDoRequest::Chain(val) => fmt.field("Chain", &val),
                OpDestroyruleDoRequest::Handle(val) => fmt.field("Handle", &val),
                OpDestroyruleDoRequest::Expressions(val) => fmt.field("Expressions", &val),
                OpDestroyruleDoRequest::Compat(val) => fmt.field("Compat", &val),
                OpDestroyruleDoRequest::Position(val) => fmt.field("Position", &val),
                OpDestroyruleDoRequest::Userdata(val) => fmt.field("Userdata", &val),
                OpDestroyruleDoRequest::Id(val) => fmt.field("Id", &val),
                OpDestroyruleDoRequest::PositionId(val) => fmt.field("PositionId", &val),
                OpDestroyruleDoRequest::ChainId(val) => fmt.field("ChainId", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpDestroyruleDoRequest<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpDestroyruleDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDestroyruleDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpDestroyruleDoRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpDestroyruleDoRequest::Chain(val) => {
                    if last_off == offset {
                        stack.push(("Chain", last_off));
                        break;
                    }
                }
                OpDestroyruleDoRequest::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpDestroyruleDoRequest::Expressions(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpDestroyruleDoRequest::Compat(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpDestroyruleDoRequest::Position(val) => {
                    if last_off == offset {
                        stack.push(("Position", last_off));
                        break;
                    }
                }
                OpDestroyruleDoRequest::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                OpDestroyruleDoRequest::Id(val) => {
                    if last_off == offset {
                        stack.push(("Id", last_off));
                        break;
                    }
                }
                OpDestroyruleDoRequest::PositionId(val) => {
                    if last_off == offset {
                        stack.push(("PositionId", last_off));
                        break;
                    }
                }
                OpDestroyruleDoRequest::ChainId(val) => {
                    if last_off == offset {
                        stack.push(("ChainId", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpDestroyruleDoRequest", cur));
        }
        (stack, missing)
    }
}
#[doc = "Delete an existing rule with destroy semantics (ignoring ENOENT errors).\n"]
pub struct PushOpDestroyruleDoReply<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDestroyruleDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDestroyruleDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the rule"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the rule"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "name of the chain containing the rule"]
    pub fn push_chain(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the chain containing the rule"]
    pub fn push_chain_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "numeric handle of the rule"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 3u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "list of expressions"]
    pub fn nested_expressions(mut self) -> PushExprListAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushExprListAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "compatibility specifications of the rule"]
    pub fn nested_compat(mut self) -> PushRuleCompatAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 5u16);
        PushRuleCompatAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "numeric handle of the previous rule"]
    pub fn push_position(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 6u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 7u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    #[doc = "uniquely identifies a rule in a transaction"]
    pub fn push_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 8u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "transaction unique identifier of the previous rule"]
    pub fn push_position_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 9u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "add the rule to chain by ID, alternative to chain name"]
    pub fn push_chain_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 10u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpDestroyruleDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete an existing rule with destroy semantics (ignoring ENOENT errors).\n"]
#[doc = "Original name: \"op-destroyrule-do-reply\""]
#[derive(Clone)]
pub enum OpDestroyruleDoReply<'a> {
    #[doc = "name of the table containing the rule"]
    Table(&'a CStr),
    #[doc = "name of the chain containing the rule"]
    Chain(&'a CStr),
    #[doc = "numeric handle of the rule"]
    Handle(u64),
    #[doc = "list of expressions"]
    Expressions(Iterable<'a, ExprListAttrs<'a>>),
    #[doc = "compatibility specifications of the rule"]
    Compat(Iterable<'a, RuleCompatAttrs>),
    #[doc = "numeric handle of the previous rule"]
    Position(u64),
    #[doc = "user data"]
    Userdata(&'a [u8]),
    #[doc = "uniquely identifies a rule in a transaction"]
    Id(u32),
    #[doc = "transaction unique identifier of the previous rule"]
    PositionId(u32),
    #[doc = "add the rule to chain by ID, alternative to chain name"]
    ChainId(u32),
}
impl<'a> Iterable<'a, OpDestroyruleDoReply<'a>> {
    #[doc = "name of the table containing the rule"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyruleDoReply::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroyruleDoReply", "Table"))
    }
    #[doc = "name of the chain containing the rule"]
    pub fn get_chain(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyruleDoReply::Chain(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroyruleDoReply", "Chain"))
    }
    #[doc = "numeric handle of the rule"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyruleDoReply::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroyruleDoReply", "Handle"))
    }
    #[doc = "list of expressions"]
    pub fn get_expressions(&self) -> Result<Iterable<'a, ExprListAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyruleDoReply::Expressions(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroyruleDoReply", "Expressions"))
    }
    #[doc = "compatibility specifications of the rule"]
    pub fn get_compat(&self) -> Result<Iterable<'a, RuleCompatAttrs>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyruleDoReply::Compat(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroyruleDoReply", "Compat"))
    }
    #[doc = "numeric handle of the previous rule"]
    pub fn get_position(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyruleDoReply::Position(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroyruleDoReply", "Position"))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyruleDoReply::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroyruleDoReply", "Userdata"))
    }
    #[doc = "uniquely identifies a rule in a transaction"]
    pub fn get_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyruleDoReply::Id(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroyruleDoReply", "Id"))
    }
    #[doc = "transaction unique identifier of the previous rule"]
    pub fn get_position_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyruleDoReply::PositionId(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroyruleDoReply", "PositionId"))
    }
    #[doc = "add the rule to chain by ID, alternative to chain name"]
    pub fn get_chain_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyruleDoReply::ChainId(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroyruleDoReply", "ChainId"))
    }
}
impl<'a> OpDestroyruleDoReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpDestroyruleDoReply<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        RuleAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpDestroyruleDoReply<'a>> {
    type Item = Result<OpDestroyruleDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpDestroyruleDoReply::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpDestroyruleDoReply::Chain({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpDestroyruleDoReply::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpDestroyruleDoReply::Expressions({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpDestroyruleDoReply::Compat({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpDestroyruleDoReply::Position({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpDestroyruleDoReply::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpDestroyruleDoReply::Id({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => OpDestroyruleDoReply::PositionId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => OpDestroyruleDoReply::ChainId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpDestroyruleDoReply",
            r#type.and_then(|t| OpDestroyruleDoReply::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpDestroyruleDoReply<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDestroyruleDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpDestroyruleDoReply::Table(val) => fmt.field("Table", &val),
                OpDestroyruleDoReply::Chain(val) => fmt.field("Chain", &val),
                OpDestroyruleDoReply::Handle(val) => fmt.field("Handle", &val),
                OpDestroyruleDoReply::Expressions(val) => fmt.field("Expressions", &val),
                OpDestroyruleDoReply::Compat(val) => fmt.field("Compat", &val),
                OpDestroyruleDoReply::Position(val) => fmt.field("Position", &val),
                OpDestroyruleDoReply::Userdata(val) => fmt.field("Userdata", &val),
                OpDestroyruleDoReply::Id(val) => fmt.field("Id", &val),
                OpDestroyruleDoReply::PositionId(val) => fmt.field("PositionId", &val),
                OpDestroyruleDoReply::ChainId(val) => fmt.field("ChainId", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpDestroyruleDoReply<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpDestroyruleDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDestroyruleDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpDestroyruleDoReply::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpDestroyruleDoReply::Chain(val) => {
                    if last_off == offset {
                        stack.push(("Chain", last_off));
                        break;
                    }
                }
                OpDestroyruleDoReply::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpDestroyruleDoReply::Expressions(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpDestroyruleDoReply::Compat(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpDestroyruleDoReply::Position(val) => {
                    if last_off == offset {
                        stack.push(("Position", last_off));
                        break;
                    }
                }
                OpDestroyruleDoReply::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                OpDestroyruleDoReply::Id(val) => {
                    if last_off == offset {
                        stack.push(("Id", last_off));
                        break;
                    }
                }
                OpDestroyruleDoReply::PositionId(val) => {
                    if last_off == offset {
                        stack.push(("PositionId", last_off));
                        break;
                    }
                }
                OpDestroyruleDoReply::ChainId(val) => {
                    if last_off == offset {
                        stack.push(("ChainId", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpDestroyruleDoReply", cur));
        }
        (stack, missing)
    }
}
#[derive(Debug)]
pub struct RequestOpDestroyruleDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpDestroyruleDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpDestroyruleDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpDestroyruleDoRequest<&mut Vec<u8>> {
        PushOpDestroyruleDoRequest::new_without_header(self.request.buf_mut())
    }
}
impl NetlinkRequest for RequestOpDestroyruleDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, Iterable<'buf, OpDestroyruleDoReply<'buf>>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2588u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpDestroyruleDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpDestroyruleDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Create a new set."]
pub struct PushOpNewsetDoRequest<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpNewsetDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpNewsetDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "table name"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "table name"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "set name"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "set name"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "bitmask of enum nft_set_flags\nAssociated type: \"SetFlags\" (enum)"]
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "key data type, informational purpose only"]
    pub fn push_key_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "key data length"]
    pub fn push_key_len(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "mapping data type"]
    pub fn push_data_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "mapping data length"]
    pub fn push_data_len(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 7u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "selection policy"]
    pub fn push_policy(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 8u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "set description"]
    pub fn nested_desc(mut self) -> PushSetDescAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 9u16);
        PushSetDescAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "uniquely identifies a set in a transaction"]
    pub fn push_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 10u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "default timeout value"]
    pub fn push_timeout(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 11u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "garbage collection interval"]
    pub fn push_gc_interval(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 12u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 13u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 14u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    #[doc = "stateful object type"]
    pub fn push_obj_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 15u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "set handle"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 16u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "set expression\nAttribute may repeat multiple times (treat it as array)"]
    pub fn nested_expr(mut self) -> PushExprAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 17u16);
        PushExprAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "list of expressions"]
    pub fn nested_expressions(mut self) -> PushSetListAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 18u16);
        PushSetListAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushOpNewsetDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Create a new set."]
#[doc = "Original name: \"op-newset-do-request\""]
#[derive(Clone)]
pub enum OpNewsetDoRequest<'a> {
    #[doc = "table name"]
    Table(&'a CStr),
    #[doc = "set name"]
    Name(&'a CStr),
    #[doc = "bitmask of enum nft_set_flags\nAssociated type: \"SetFlags\" (enum)"]
    Flags(u32),
    #[doc = "key data type, informational purpose only"]
    KeyType(u32),
    #[doc = "key data length"]
    KeyLen(u32),
    #[doc = "mapping data type"]
    DataType(u32),
    #[doc = "mapping data length"]
    DataLen(u32),
    #[doc = "selection policy"]
    Policy(u32),
    #[doc = "set description"]
    Desc(Iterable<'a, SetDescAttrs<'a>>),
    #[doc = "uniquely identifies a set in a transaction"]
    Id(u32),
    #[doc = "default timeout value"]
    Timeout(u64),
    #[doc = "garbage collection interval"]
    GcInterval(u32),
    #[doc = "user data"]
    Userdata(&'a [u8]),
    Pad(&'a [u8]),
    #[doc = "stateful object type"]
    ObjType(u32),
    #[doc = "set handle"]
    Handle(u64),
    #[doc = "set expression\nAttribute may repeat multiple times (treat it as array)"]
    Expr(Iterable<'a, ExprAttrs<'a>>),
    #[doc = "list of expressions"]
    Expressions(Iterable<'a, SetListAttrs<'a>>),
}
impl<'a> Iterable<'a, OpNewsetDoRequest<'a>> {
    #[doc = "table name"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewsetDoRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewsetDoRequest", "Table"))
    }
    #[doc = "set name"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewsetDoRequest::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewsetDoRequest", "Name"))
    }
    #[doc = "bitmask of enum nft_set_flags\nAssociated type: \"SetFlags\" (enum)"]
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewsetDoRequest::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewsetDoRequest", "Flags"))
    }
    #[doc = "key data type, informational purpose only"]
    pub fn get_key_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewsetDoRequest::KeyType(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewsetDoRequest", "KeyType"))
    }
    #[doc = "key data length"]
    pub fn get_key_len(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewsetDoRequest::KeyLen(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewsetDoRequest", "KeyLen"))
    }
    #[doc = "mapping data type"]
    pub fn get_data_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewsetDoRequest::DataType(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewsetDoRequest", "DataType"))
    }
    #[doc = "mapping data length"]
    pub fn get_data_len(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewsetDoRequest::DataLen(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewsetDoRequest", "DataLen"))
    }
    #[doc = "selection policy"]
    pub fn get_policy(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewsetDoRequest::Policy(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewsetDoRequest", "Policy"))
    }
    #[doc = "set description"]
    pub fn get_desc(&self) -> Result<Iterable<'a, SetDescAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewsetDoRequest::Desc(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewsetDoRequest", "Desc"))
    }
    #[doc = "uniquely identifies a set in a transaction"]
    pub fn get_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewsetDoRequest::Id(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewsetDoRequest", "Id"))
    }
    #[doc = "default timeout value"]
    pub fn get_timeout(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewsetDoRequest::Timeout(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewsetDoRequest", "Timeout"))
    }
    #[doc = "garbage collection interval"]
    pub fn get_gc_interval(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewsetDoRequest::GcInterval(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewsetDoRequest", "GcInterval"))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewsetDoRequest::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewsetDoRequest", "Userdata"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewsetDoRequest::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewsetDoRequest", "Pad"))
    }
    #[doc = "stateful object type"]
    pub fn get_obj_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewsetDoRequest::ObjType(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewsetDoRequest", "ObjType"))
    }
    #[doc = "set handle"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewsetDoRequest::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewsetDoRequest", "Handle"))
    }
    #[doc = "set expression\nAttribute may repeat multiple times (treat it as array)"]
    pub fn get_expr(
        &self,
    ) -> MultiAttrIterable<Self, OpNewsetDoRequest<'a>, Iterable<'a, ExprAttrs<'a>>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let OpNewsetDoRequest::Expr(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
    #[doc = "list of expressions"]
    pub fn get_expressions(&self) -> Result<Iterable<'a, SetListAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewsetDoRequest::Expressions(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewsetDoRequest", "Expressions"))
    }
}
impl<'a> OpNewsetDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpNewsetDoRequest<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        SetAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpNewsetDoRequest<'a>> {
    type Item = Result<OpNewsetDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpNewsetDoRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpNewsetDoRequest::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpNewsetDoRequest::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpNewsetDoRequest::KeyType({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpNewsetDoRequest::KeyLen({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpNewsetDoRequest::DataType({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpNewsetDoRequest::DataLen({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpNewsetDoRequest::Policy({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => OpNewsetDoRequest::Desc({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => OpNewsetDoRequest::Id({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => OpNewsetDoRequest::Timeout({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                12u16 => OpNewsetDoRequest::GcInterval({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                13u16 => OpNewsetDoRequest::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                14u16 => OpNewsetDoRequest::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                15u16 => OpNewsetDoRequest::ObjType({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                16u16 => OpNewsetDoRequest::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                17u16 => OpNewsetDoRequest::Expr({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                18u16 => OpNewsetDoRequest::Expressions({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpNewsetDoRequest",
            r#type.and_then(|t| OpNewsetDoRequest::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpNewsetDoRequest<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpNewsetDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpNewsetDoRequest::Table(val) => fmt.field("Table", &val),
                OpNewsetDoRequest::Name(val) => fmt.field("Name", &val),
                OpNewsetDoRequest::Flags(val) => {
                    fmt.field("Flags", &FormatFlags(val.into(), SetFlags::from_value))
                }
                OpNewsetDoRequest::KeyType(val) => fmt.field("KeyType", &val),
                OpNewsetDoRequest::KeyLen(val) => fmt.field("KeyLen", &val),
                OpNewsetDoRequest::DataType(val) => fmt.field("DataType", &val),
                OpNewsetDoRequest::DataLen(val) => fmt.field("DataLen", &val),
                OpNewsetDoRequest::Policy(val) => fmt.field("Policy", &val),
                OpNewsetDoRequest::Desc(val) => fmt.field("Desc", &val),
                OpNewsetDoRequest::Id(val) => fmt.field("Id", &val),
                OpNewsetDoRequest::Timeout(val) => fmt.field("Timeout", &val),
                OpNewsetDoRequest::GcInterval(val) => fmt.field("GcInterval", &val),
                OpNewsetDoRequest::Userdata(val) => fmt.field("Userdata", &val),
                OpNewsetDoRequest::Pad(val) => fmt.field("Pad", &val),
                OpNewsetDoRequest::ObjType(val) => fmt.field("ObjType", &val),
                OpNewsetDoRequest::Handle(val) => fmt.field("Handle", &val),
                OpNewsetDoRequest::Expr(val) => fmt.field("Expr", &val),
                OpNewsetDoRequest::Expressions(val) => fmt.field("Expressions", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpNewsetDoRequest<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpNewsetDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpNewsetDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpNewsetDoRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpNewsetDoRequest::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpNewsetDoRequest::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                OpNewsetDoRequest::KeyType(val) => {
                    if last_off == offset {
                        stack.push(("KeyType", last_off));
                        break;
                    }
                }
                OpNewsetDoRequest::KeyLen(val) => {
                    if last_off == offset {
                        stack.push(("KeyLen", last_off));
                        break;
                    }
                }
                OpNewsetDoRequest::DataType(val) => {
                    if last_off == offset {
                        stack.push(("DataType", last_off));
                        break;
                    }
                }
                OpNewsetDoRequest::DataLen(val) => {
                    if last_off == offset {
                        stack.push(("DataLen", last_off));
                        break;
                    }
                }
                OpNewsetDoRequest::Policy(val) => {
                    if last_off == offset {
                        stack.push(("Policy", last_off));
                        break;
                    }
                }
                OpNewsetDoRequest::Desc(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpNewsetDoRequest::Id(val) => {
                    if last_off == offset {
                        stack.push(("Id", last_off));
                        break;
                    }
                }
                OpNewsetDoRequest::Timeout(val) => {
                    if last_off == offset {
                        stack.push(("Timeout", last_off));
                        break;
                    }
                }
                OpNewsetDoRequest::GcInterval(val) => {
                    if last_off == offset {
                        stack.push(("GcInterval", last_off));
                        break;
                    }
                }
                OpNewsetDoRequest::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                OpNewsetDoRequest::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                OpNewsetDoRequest::ObjType(val) => {
                    if last_off == offset {
                        stack.push(("ObjType", last_off));
                        break;
                    }
                }
                OpNewsetDoRequest::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpNewsetDoRequest::Expr(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpNewsetDoRequest::Expressions(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpNewsetDoRequest", cur));
        }
        (stack, missing)
    }
}
#[doc = "Create a new set."]
pub struct PushOpNewsetDoReply<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpNewsetDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpNewsetDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "table name"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "table name"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "set name"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "set name"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "bitmask of enum nft_set_flags\nAssociated type: \"SetFlags\" (enum)"]
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "key data type, informational purpose only"]
    pub fn push_key_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "key data length"]
    pub fn push_key_len(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "mapping data type"]
    pub fn push_data_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "mapping data length"]
    pub fn push_data_len(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 7u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "selection policy"]
    pub fn push_policy(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 8u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "set description"]
    pub fn nested_desc(mut self) -> PushSetDescAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 9u16);
        PushSetDescAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "uniquely identifies a set in a transaction"]
    pub fn push_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 10u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "default timeout value"]
    pub fn push_timeout(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 11u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "garbage collection interval"]
    pub fn push_gc_interval(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 12u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 13u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 14u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    #[doc = "stateful object type"]
    pub fn push_obj_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 15u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "set handle"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 16u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "set expression\nAttribute may repeat multiple times (treat it as array)"]
    pub fn nested_expr(mut self) -> PushExprAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 17u16);
        PushExprAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "list of expressions"]
    pub fn nested_expressions(mut self) -> PushSetListAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 18u16);
        PushSetListAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushOpNewsetDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Create a new set."]
#[doc = "Original name: \"op-newset-do-reply\""]
#[derive(Clone)]
pub enum OpNewsetDoReply<'a> {
    #[doc = "table name"]
    Table(&'a CStr),
    #[doc = "set name"]
    Name(&'a CStr),
    #[doc = "bitmask of enum nft_set_flags\nAssociated type: \"SetFlags\" (enum)"]
    Flags(u32),
    #[doc = "key data type, informational purpose only"]
    KeyType(u32),
    #[doc = "key data length"]
    KeyLen(u32),
    #[doc = "mapping data type"]
    DataType(u32),
    #[doc = "mapping data length"]
    DataLen(u32),
    #[doc = "selection policy"]
    Policy(u32),
    #[doc = "set description"]
    Desc(Iterable<'a, SetDescAttrs<'a>>),
    #[doc = "uniquely identifies a set in a transaction"]
    Id(u32),
    #[doc = "default timeout value"]
    Timeout(u64),
    #[doc = "garbage collection interval"]
    GcInterval(u32),
    #[doc = "user data"]
    Userdata(&'a [u8]),
    Pad(&'a [u8]),
    #[doc = "stateful object type"]
    ObjType(u32),
    #[doc = "set handle"]
    Handle(u64),
    #[doc = "set expression\nAttribute may repeat multiple times (treat it as array)"]
    Expr(Iterable<'a, ExprAttrs<'a>>),
    #[doc = "list of expressions"]
    Expressions(Iterable<'a, SetListAttrs<'a>>),
}
impl<'a> Iterable<'a, OpNewsetDoReply<'a>> {
    #[doc = "table name"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewsetDoReply::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewsetDoReply", "Table"))
    }
    #[doc = "set name"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewsetDoReply::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewsetDoReply", "Name"))
    }
    #[doc = "bitmask of enum nft_set_flags\nAssociated type: \"SetFlags\" (enum)"]
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewsetDoReply::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewsetDoReply", "Flags"))
    }
    #[doc = "key data type, informational purpose only"]
    pub fn get_key_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewsetDoReply::KeyType(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewsetDoReply", "KeyType"))
    }
    #[doc = "key data length"]
    pub fn get_key_len(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewsetDoReply::KeyLen(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewsetDoReply", "KeyLen"))
    }
    #[doc = "mapping data type"]
    pub fn get_data_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewsetDoReply::DataType(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewsetDoReply", "DataType"))
    }
    #[doc = "mapping data length"]
    pub fn get_data_len(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewsetDoReply::DataLen(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewsetDoReply", "DataLen"))
    }
    #[doc = "selection policy"]
    pub fn get_policy(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewsetDoReply::Policy(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewsetDoReply", "Policy"))
    }
    #[doc = "set description"]
    pub fn get_desc(&self) -> Result<Iterable<'a, SetDescAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewsetDoReply::Desc(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewsetDoReply", "Desc"))
    }
    #[doc = "uniquely identifies a set in a transaction"]
    pub fn get_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewsetDoReply::Id(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewsetDoReply", "Id"))
    }
    #[doc = "default timeout value"]
    pub fn get_timeout(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewsetDoReply::Timeout(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewsetDoReply", "Timeout"))
    }
    #[doc = "garbage collection interval"]
    pub fn get_gc_interval(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewsetDoReply::GcInterval(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewsetDoReply", "GcInterval"))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewsetDoReply::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewsetDoReply", "Userdata"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewsetDoReply::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewsetDoReply", "Pad"))
    }
    #[doc = "stateful object type"]
    pub fn get_obj_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewsetDoReply::ObjType(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewsetDoReply", "ObjType"))
    }
    #[doc = "set handle"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewsetDoReply::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewsetDoReply", "Handle"))
    }
    #[doc = "set expression\nAttribute may repeat multiple times (treat it as array)"]
    pub fn get_expr(
        &self,
    ) -> MultiAttrIterable<Self, OpNewsetDoReply<'a>, Iterable<'a, ExprAttrs<'a>>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let OpNewsetDoReply::Expr(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
    #[doc = "list of expressions"]
    pub fn get_expressions(&self) -> Result<Iterable<'a, SetListAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewsetDoReply::Expressions(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewsetDoReply", "Expressions"))
    }
}
impl<'a> OpNewsetDoReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpNewsetDoReply<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        SetAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpNewsetDoReply<'a>> {
    type Item = Result<OpNewsetDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpNewsetDoReply::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpNewsetDoReply::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpNewsetDoReply::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpNewsetDoReply::KeyType({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpNewsetDoReply::KeyLen({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpNewsetDoReply::DataType({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpNewsetDoReply::DataLen({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpNewsetDoReply::Policy({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => OpNewsetDoReply::Desc({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => OpNewsetDoReply::Id({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => OpNewsetDoReply::Timeout({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                12u16 => OpNewsetDoReply::GcInterval({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                13u16 => OpNewsetDoReply::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                14u16 => OpNewsetDoReply::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                15u16 => OpNewsetDoReply::ObjType({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                16u16 => OpNewsetDoReply::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                17u16 => OpNewsetDoReply::Expr({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                18u16 => OpNewsetDoReply::Expressions({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpNewsetDoReply",
            r#type.and_then(|t| OpNewsetDoReply::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpNewsetDoReply<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpNewsetDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpNewsetDoReply::Table(val) => fmt.field("Table", &val),
                OpNewsetDoReply::Name(val) => fmt.field("Name", &val),
                OpNewsetDoReply::Flags(val) => {
                    fmt.field("Flags", &FormatFlags(val.into(), SetFlags::from_value))
                }
                OpNewsetDoReply::KeyType(val) => fmt.field("KeyType", &val),
                OpNewsetDoReply::KeyLen(val) => fmt.field("KeyLen", &val),
                OpNewsetDoReply::DataType(val) => fmt.field("DataType", &val),
                OpNewsetDoReply::DataLen(val) => fmt.field("DataLen", &val),
                OpNewsetDoReply::Policy(val) => fmt.field("Policy", &val),
                OpNewsetDoReply::Desc(val) => fmt.field("Desc", &val),
                OpNewsetDoReply::Id(val) => fmt.field("Id", &val),
                OpNewsetDoReply::Timeout(val) => fmt.field("Timeout", &val),
                OpNewsetDoReply::GcInterval(val) => fmt.field("GcInterval", &val),
                OpNewsetDoReply::Userdata(val) => fmt.field("Userdata", &val),
                OpNewsetDoReply::Pad(val) => fmt.field("Pad", &val),
                OpNewsetDoReply::ObjType(val) => fmt.field("ObjType", &val),
                OpNewsetDoReply::Handle(val) => fmt.field("Handle", &val),
                OpNewsetDoReply::Expr(val) => fmt.field("Expr", &val),
                OpNewsetDoReply::Expressions(val) => fmt.field("Expressions", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpNewsetDoReply<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpNewsetDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpNewsetDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpNewsetDoReply::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpNewsetDoReply::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpNewsetDoReply::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                OpNewsetDoReply::KeyType(val) => {
                    if last_off == offset {
                        stack.push(("KeyType", last_off));
                        break;
                    }
                }
                OpNewsetDoReply::KeyLen(val) => {
                    if last_off == offset {
                        stack.push(("KeyLen", last_off));
                        break;
                    }
                }
                OpNewsetDoReply::DataType(val) => {
                    if last_off == offset {
                        stack.push(("DataType", last_off));
                        break;
                    }
                }
                OpNewsetDoReply::DataLen(val) => {
                    if last_off == offset {
                        stack.push(("DataLen", last_off));
                        break;
                    }
                }
                OpNewsetDoReply::Policy(val) => {
                    if last_off == offset {
                        stack.push(("Policy", last_off));
                        break;
                    }
                }
                OpNewsetDoReply::Desc(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpNewsetDoReply::Id(val) => {
                    if last_off == offset {
                        stack.push(("Id", last_off));
                        break;
                    }
                }
                OpNewsetDoReply::Timeout(val) => {
                    if last_off == offset {
                        stack.push(("Timeout", last_off));
                        break;
                    }
                }
                OpNewsetDoReply::GcInterval(val) => {
                    if last_off == offset {
                        stack.push(("GcInterval", last_off));
                        break;
                    }
                }
                OpNewsetDoReply::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                OpNewsetDoReply::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                OpNewsetDoReply::ObjType(val) => {
                    if last_off == offset {
                        stack.push(("ObjType", last_off));
                        break;
                    }
                }
                OpNewsetDoReply::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpNewsetDoReply::Expr(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpNewsetDoReply::Expressions(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpNewsetDoReply", cur));
        }
        (stack, missing)
    }
}
#[derive(Debug)]
pub struct RequestOpNewsetDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpNewsetDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpNewsetDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpNewsetDoRequest<&mut Vec<u8>> {
        PushOpNewsetDoRequest::new_without_header(self.request.buf_mut())
    }
}
impl NetlinkRequest for RequestOpNewsetDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, Iterable<'buf, OpNewsetDoReply<'buf>>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2569u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpNewsetDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpNewsetDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Get / dump sets."]
pub struct PushOpGetsetDumpRequest<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetsetDumpRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetsetDumpRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "table name"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "table name"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "set name"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "set name"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "bitmask of enum nft_set_flags\nAssociated type: \"SetFlags\" (enum)"]
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "key data type, informational purpose only"]
    pub fn push_key_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "key data length"]
    pub fn push_key_len(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "mapping data type"]
    pub fn push_data_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "mapping data length"]
    pub fn push_data_len(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 7u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "selection policy"]
    pub fn push_policy(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 8u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "set description"]
    pub fn nested_desc(mut self) -> PushSetDescAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 9u16);
        PushSetDescAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "uniquely identifies a set in a transaction"]
    pub fn push_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 10u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "default timeout value"]
    pub fn push_timeout(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 11u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "garbage collection interval"]
    pub fn push_gc_interval(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 12u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 13u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 14u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    #[doc = "stateful object type"]
    pub fn push_obj_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 15u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "set handle"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 16u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "set expression\nAttribute may repeat multiple times (treat it as array)"]
    pub fn nested_expr(mut self) -> PushExprAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 17u16);
        PushExprAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "list of expressions"]
    pub fn nested_expressions(mut self) -> PushSetListAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 18u16);
        PushSetListAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushOpGetsetDumpRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump sets."]
#[doc = "Original name: \"op-getset-dump-request\""]
#[derive(Clone)]
pub enum OpGetsetDumpRequest<'a> {
    #[doc = "table name"]
    Table(&'a CStr),
    #[doc = "set name"]
    Name(&'a CStr),
    #[doc = "bitmask of enum nft_set_flags\nAssociated type: \"SetFlags\" (enum)"]
    Flags(u32),
    #[doc = "key data type, informational purpose only"]
    KeyType(u32),
    #[doc = "key data length"]
    KeyLen(u32),
    #[doc = "mapping data type"]
    DataType(u32),
    #[doc = "mapping data length"]
    DataLen(u32),
    #[doc = "selection policy"]
    Policy(u32),
    #[doc = "set description"]
    Desc(Iterable<'a, SetDescAttrs<'a>>),
    #[doc = "uniquely identifies a set in a transaction"]
    Id(u32),
    #[doc = "default timeout value"]
    Timeout(u64),
    #[doc = "garbage collection interval"]
    GcInterval(u32),
    #[doc = "user data"]
    Userdata(&'a [u8]),
    Pad(&'a [u8]),
    #[doc = "stateful object type"]
    ObjType(u32),
    #[doc = "set handle"]
    Handle(u64),
    #[doc = "set expression\nAttribute may repeat multiple times (treat it as array)"]
    Expr(Iterable<'a, ExprAttrs<'a>>),
    #[doc = "list of expressions"]
    Expressions(Iterable<'a, SetListAttrs<'a>>),
}
impl<'a> Iterable<'a, OpGetsetDumpRequest<'a>> {
    #[doc = "table name"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDumpRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDumpRequest", "Table"))
    }
    #[doc = "set name"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDumpRequest::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDumpRequest", "Name"))
    }
    #[doc = "bitmask of enum nft_set_flags\nAssociated type: \"SetFlags\" (enum)"]
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDumpRequest::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDumpRequest", "Flags"))
    }
    #[doc = "key data type, informational purpose only"]
    pub fn get_key_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDumpRequest::KeyType(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDumpRequest", "KeyType"))
    }
    #[doc = "key data length"]
    pub fn get_key_len(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDumpRequest::KeyLen(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDumpRequest", "KeyLen"))
    }
    #[doc = "mapping data type"]
    pub fn get_data_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDumpRequest::DataType(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDumpRequest", "DataType"))
    }
    #[doc = "mapping data length"]
    pub fn get_data_len(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDumpRequest::DataLen(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDumpRequest", "DataLen"))
    }
    #[doc = "selection policy"]
    pub fn get_policy(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDumpRequest::Policy(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDumpRequest", "Policy"))
    }
    #[doc = "set description"]
    pub fn get_desc(&self) -> Result<Iterable<'a, SetDescAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDumpRequest::Desc(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDumpRequest", "Desc"))
    }
    #[doc = "uniquely identifies a set in a transaction"]
    pub fn get_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDumpRequest::Id(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDumpRequest", "Id"))
    }
    #[doc = "default timeout value"]
    pub fn get_timeout(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDumpRequest::Timeout(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDumpRequest", "Timeout"))
    }
    #[doc = "garbage collection interval"]
    pub fn get_gc_interval(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDumpRequest::GcInterval(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDumpRequest", "GcInterval"))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDumpRequest::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDumpRequest", "Userdata"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDumpRequest::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDumpRequest", "Pad"))
    }
    #[doc = "stateful object type"]
    pub fn get_obj_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDumpRequest::ObjType(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDumpRequest", "ObjType"))
    }
    #[doc = "set handle"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDumpRequest::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDumpRequest", "Handle"))
    }
    #[doc = "set expression\nAttribute may repeat multiple times (treat it as array)"]
    pub fn get_expr(
        &self,
    ) -> MultiAttrIterable<Self, OpGetsetDumpRequest<'a>, Iterable<'a, ExprAttrs<'a>>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let OpGetsetDumpRequest::Expr(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
    #[doc = "list of expressions"]
    pub fn get_expressions(&self) -> Result<Iterable<'a, SetListAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDumpRequest::Expressions(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDumpRequest", "Expressions"))
    }
}
impl<'a> OpGetsetDumpRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpGetsetDumpRequest<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        SetAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpGetsetDumpRequest<'a>> {
    type Item = Result<OpGetsetDumpRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetsetDumpRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetsetDumpRequest::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetsetDumpRequest::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpGetsetDumpRequest::KeyType({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpGetsetDumpRequest::KeyLen({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpGetsetDumpRequest::DataType({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpGetsetDumpRequest::DataLen({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpGetsetDumpRequest::Policy({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => OpGetsetDumpRequest::Desc({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => OpGetsetDumpRequest::Id({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => OpGetsetDumpRequest::Timeout({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                12u16 => OpGetsetDumpRequest::GcInterval({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                13u16 => OpGetsetDumpRequest::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                14u16 => OpGetsetDumpRequest::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                15u16 => OpGetsetDumpRequest::ObjType({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                16u16 => OpGetsetDumpRequest::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                17u16 => OpGetsetDumpRequest::Expr({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                18u16 => OpGetsetDumpRequest::Expressions({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpGetsetDumpRequest",
            r#type.and_then(|t| OpGetsetDumpRequest::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpGetsetDumpRequest<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetsetDumpRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetsetDumpRequest::Table(val) => fmt.field("Table", &val),
                OpGetsetDumpRequest::Name(val) => fmt.field("Name", &val),
                OpGetsetDumpRequest::Flags(val) => {
                    fmt.field("Flags", &FormatFlags(val.into(), SetFlags::from_value))
                }
                OpGetsetDumpRequest::KeyType(val) => fmt.field("KeyType", &val),
                OpGetsetDumpRequest::KeyLen(val) => fmt.field("KeyLen", &val),
                OpGetsetDumpRequest::DataType(val) => fmt.field("DataType", &val),
                OpGetsetDumpRequest::DataLen(val) => fmt.field("DataLen", &val),
                OpGetsetDumpRequest::Policy(val) => fmt.field("Policy", &val),
                OpGetsetDumpRequest::Desc(val) => fmt.field("Desc", &val),
                OpGetsetDumpRequest::Id(val) => fmt.field("Id", &val),
                OpGetsetDumpRequest::Timeout(val) => fmt.field("Timeout", &val),
                OpGetsetDumpRequest::GcInterval(val) => fmt.field("GcInterval", &val),
                OpGetsetDumpRequest::Userdata(val) => fmt.field("Userdata", &val),
                OpGetsetDumpRequest::Pad(val) => fmt.field("Pad", &val),
                OpGetsetDumpRequest::ObjType(val) => fmt.field("ObjType", &val),
                OpGetsetDumpRequest::Handle(val) => fmt.field("Handle", &val),
                OpGetsetDumpRequest::Expr(val) => fmt.field("Expr", &val),
                OpGetsetDumpRequest::Expressions(val) => fmt.field("Expressions", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpGetsetDumpRequest<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetsetDumpRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetsetDumpRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetsetDumpRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpGetsetDumpRequest::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpGetsetDumpRequest::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                OpGetsetDumpRequest::KeyType(val) => {
                    if last_off == offset {
                        stack.push(("KeyType", last_off));
                        break;
                    }
                }
                OpGetsetDumpRequest::KeyLen(val) => {
                    if last_off == offset {
                        stack.push(("KeyLen", last_off));
                        break;
                    }
                }
                OpGetsetDumpRequest::DataType(val) => {
                    if last_off == offset {
                        stack.push(("DataType", last_off));
                        break;
                    }
                }
                OpGetsetDumpRequest::DataLen(val) => {
                    if last_off == offset {
                        stack.push(("DataLen", last_off));
                        break;
                    }
                }
                OpGetsetDumpRequest::Policy(val) => {
                    if last_off == offset {
                        stack.push(("Policy", last_off));
                        break;
                    }
                }
                OpGetsetDumpRequest::Desc(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetsetDumpRequest::Id(val) => {
                    if last_off == offset {
                        stack.push(("Id", last_off));
                        break;
                    }
                }
                OpGetsetDumpRequest::Timeout(val) => {
                    if last_off == offset {
                        stack.push(("Timeout", last_off));
                        break;
                    }
                }
                OpGetsetDumpRequest::GcInterval(val) => {
                    if last_off == offset {
                        stack.push(("GcInterval", last_off));
                        break;
                    }
                }
                OpGetsetDumpRequest::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                OpGetsetDumpRequest::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                OpGetsetDumpRequest::ObjType(val) => {
                    if last_off == offset {
                        stack.push(("ObjType", last_off));
                        break;
                    }
                }
                OpGetsetDumpRequest::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpGetsetDumpRequest::Expr(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetsetDumpRequest::Expressions(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetsetDumpRequest", cur));
        }
        (stack, missing)
    }
}
#[doc = "Get / dump sets."]
pub struct PushOpGetsetDumpReply<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetsetDumpReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetsetDumpReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "table name"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "table name"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "set name"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "set name"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "bitmask of enum nft_set_flags\nAssociated type: \"SetFlags\" (enum)"]
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "key data type, informational purpose only"]
    pub fn push_key_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "key data length"]
    pub fn push_key_len(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "mapping data type"]
    pub fn push_data_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "mapping data length"]
    pub fn push_data_len(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 7u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "selection policy"]
    pub fn push_policy(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 8u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "set description"]
    pub fn nested_desc(mut self) -> PushSetDescAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 9u16);
        PushSetDescAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "uniquely identifies a set in a transaction"]
    pub fn push_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 10u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "default timeout value"]
    pub fn push_timeout(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 11u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "garbage collection interval"]
    pub fn push_gc_interval(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 12u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 13u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 14u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    #[doc = "stateful object type"]
    pub fn push_obj_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 15u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "set handle"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 16u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "set expression\nAttribute may repeat multiple times (treat it as array)"]
    pub fn nested_expr(mut self) -> PushExprAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 17u16);
        PushExprAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "list of expressions"]
    pub fn nested_expressions(mut self) -> PushSetListAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 18u16);
        PushSetListAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushOpGetsetDumpReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump sets."]
#[doc = "Original name: \"op-getset-dump-reply\""]
#[derive(Clone)]
pub enum OpGetsetDumpReply<'a> {
    #[doc = "table name"]
    Table(&'a CStr),
    #[doc = "set name"]
    Name(&'a CStr),
    #[doc = "bitmask of enum nft_set_flags\nAssociated type: \"SetFlags\" (enum)"]
    Flags(u32),
    #[doc = "key data type, informational purpose only"]
    KeyType(u32),
    #[doc = "key data length"]
    KeyLen(u32),
    #[doc = "mapping data type"]
    DataType(u32),
    #[doc = "mapping data length"]
    DataLen(u32),
    #[doc = "selection policy"]
    Policy(u32),
    #[doc = "set description"]
    Desc(Iterable<'a, SetDescAttrs<'a>>),
    #[doc = "uniquely identifies a set in a transaction"]
    Id(u32),
    #[doc = "default timeout value"]
    Timeout(u64),
    #[doc = "garbage collection interval"]
    GcInterval(u32),
    #[doc = "user data"]
    Userdata(&'a [u8]),
    Pad(&'a [u8]),
    #[doc = "stateful object type"]
    ObjType(u32),
    #[doc = "set handle"]
    Handle(u64),
    #[doc = "set expression\nAttribute may repeat multiple times (treat it as array)"]
    Expr(Iterable<'a, ExprAttrs<'a>>),
    #[doc = "list of expressions"]
    Expressions(Iterable<'a, SetListAttrs<'a>>),
}
impl<'a> Iterable<'a, OpGetsetDumpReply<'a>> {
    #[doc = "table name"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDumpReply::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDumpReply", "Table"))
    }
    #[doc = "set name"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDumpReply::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDumpReply", "Name"))
    }
    #[doc = "bitmask of enum nft_set_flags\nAssociated type: \"SetFlags\" (enum)"]
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDumpReply::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDumpReply", "Flags"))
    }
    #[doc = "key data type, informational purpose only"]
    pub fn get_key_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDumpReply::KeyType(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDumpReply", "KeyType"))
    }
    #[doc = "key data length"]
    pub fn get_key_len(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDumpReply::KeyLen(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDumpReply", "KeyLen"))
    }
    #[doc = "mapping data type"]
    pub fn get_data_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDumpReply::DataType(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDumpReply", "DataType"))
    }
    #[doc = "mapping data length"]
    pub fn get_data_len(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDumpReply::DataLen(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDumpReply", "DataLen"))
    }
    #[doc = "selection policy"]
    pub fn get_policy(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDumpReply::Policy(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDumpReply", "Policy"))
    }
    #[doc = "set description"]
    pub fn get_desc(&self) -> Result<Iterable<'a, SetDescAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDumpReply::Desc(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDumpReply", "Desc"))
    }
    #[doc = "uniquely identifies a set in a transaction"]
    pub fn get_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDumpReply::Id(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDumpReply", "Id"))
    }
    #[doc = "default timeout value"]
    pub fn get_timeout(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDumpReply::Timeout(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDumpReply", "Timeout"))
    }
    #[doc = "garbage collection interval"]
    pub fn get_gc_interval(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDumpReply::GcInterval(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDumpReply", "GcInterval"))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDumpReply::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDumpReply", "Userdata"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDumpReply::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDumpReply", "Pad"))
    }
    #[doc = "stateful object type"]
    pub fn get_obj_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDumpReply::ObjType(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDumpReply", "ObjType"))
    }
    #[doc = "set handle"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDumpReply::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDumpReply", "Handle"))
    }
    #[doc = "set expression\nAttribute may repeat multiple times (treat it as array)"]
    pub fn get_expr(
        &self,
    ) -> MultiAttrIterable<Self, OpGetsetDumpReply<'a>, Iterable<'a, ExprAttrs<'a>>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let OpGetsetDumpReply::Expr(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
    #[doc = "list of expressions"]
    pub fn get_expressions(&self) -> Result<Iterable<'a, SetListAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDumpReply::Expressions(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDumpReply", "Expressions"))
    }
}
impl<'a> OpGetsetDumpReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpGetsetDumpReply<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        SetAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpGetsetDumpReply<'a>> {
    type Item = Result<OpGetsetDumpReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetsetDumpReply::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetsetDumpReply::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetsetDumpReply::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpGetsetDumpReply::KeyType({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpGetsetDumpReply::KeyLen({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpGetsetDumpReply::DataType({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpGetsetDumpReply::DataLen({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpGetsetDumpReply::Policy({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => OpGetsetDumpReply::Desc({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => OpGetsetDumpReply::Id({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => OpGetsetDumpReply::Timeout({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                12u16 => OpGetsetDumpReply::GcInterval({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                13u16 => OpGetsetDumpReply::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                14u16 => OpGetsetDumpReply::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                15u16 => OpGetsetDumpReply::ObjType({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                16u16 => OpGetsetDumpReply::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                17u16 => OpGetsetDumpReply::Expr({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                18u16 => OpGetsetDumpReply::Expressions({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpGetsetDumpReply",
            r#type.and_then(|t| OpGetsetDumpReply::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpGetsetDumpReply<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetsetDumpReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetsetDumpReply::Table(val) => fmt.field("Table", &val),
                OpGetsetDumpReply::Name(val) => fmt.field("Name", &val),
                OpGetsetDumpReply::Flags(val) => {
                    fmt.field("Flags", &FormatFlags(val.into(), SetFlags::from_value))
                }
                OpGetsetDumpReply::KeyType(val) => fmt.field("KeyType", &val),
                OpGetsetDumpReply::KeyLen(val) => fmt.field("KeyLen", &val),
                OpGetsetDumpReply::DataType(val) => fmt.field("DataType", &val),
                OpGetsetDumpReply::DataLen(val) => fmt.field("DataLen", &val),
                OpGetsetDumpReply::Policy(val) => fmt.field("Policy", &val),
                OpGetsetDumpReply::Desc(val) => fmt.field("Desc", &val),
                OpGetsetDumpReply::Id(val) => fmt.field("Id", &val),
                OpGetsetDumpReply::Timeout(val) => fmt.field("Timeout", &val),
                OpGetsetDumpReply::GcInterval(val) => fmt.field("GcInterval", &val),
                OpGetsetDumpReply::Userdata(val) => fmt.field("Userdata", &val),
                OpGetsetDumpReply::Pad(val) => fmt.field("Pad", &val),
                OpGetsetDumpReply::ObjType(val) => fmt.field("ObjType", &val),
                OpGetsetDumpReply::Handle(val) => fmt.field("Handle", &val),
                OpGetsetDumpReply::Expr(val) => fmt.field("Expr", &val),
                OpGetsetDumpReply::Expressions(val) => fmt.field("Expressions", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpGetsetDumpReply<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetsetDumpReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetsetDumpReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetsetDumpReply::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpGetsetDumpReply::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpGetsetDumpReply::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                OpGetsetDumpReply::KeyType(val) => {
                    if last_off == offset {
                        stack.push(("KeyType", last_off));
                        break;
                    }
                }
                OpGetsetDumpReply::KeyLen(val) => {
                    if last_off == offset {
                        stack.push(("KeyLen", last_off));
                        break;
                    }
                }
                OpGetsetDumpReply::DataType(val) => {
                    if last_off == offset {
                        stack.push(("DataType", last_off));
                        break;
                    }
                }
                OpGetsetDumpReply::DataLen(val) => {
                    if last_off == offset {
                        stack.push(("DataLen", last_off));
                        break;
                    }
                }
                OpGetsetDumpReply::Policy(val) => {
                    if last_off == offset {
                        stack.push(("Policy", last_off));
                        break;
                    }
                }
                OpGetsetDumpReply::Desc(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetsetDumpReply::Id(val) => {
                    if last_off == offset {
                        stack.push(("Id", last_off));
                        break;
                    }
                }
                OpGetsetDumpReply::Timeout(val) => {
                    if last_off == offset {
                        stack.push(("Timeout", last_off));
                        break;
                    }
                }
                OpGetsetDumpReply::GcInterval(val) => {
                    if last_off == offset {
                        stack.push(("GcInterval", last_off));
                        break;
                    }
                }
                OpGetsetDumpReply::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                OpGetsetDumpReply::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                OpGetsetDumpReply::ObjType(val) => {
                    if last_off == offset {
                        stack.push(("ObjType", last_off));
                        break;
                    }
                }
                OpGetsetDumpReply::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpGetsetDumpReply::Expr(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetsetDumpReply::Expressions(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetsetDumpReply", cur));
        }
        (stack, missing)
    }
}
#[derive(Debug)]
pub struct RequestOpGetsetDumpRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpGetsetDumpRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpGetsetDumpRequest::write_header(&mut request.buf_mut(), header);
        Self {
            request: request.set_dump(),
        }
    }
    pub fn encode(&mut self) -> PushOpGetsetDumpRequest<&mut Vec<u8>> {
        PushOpGetsetDumpRequest::new_without_header(self.request.buf_mut())
    }
}
impl NetlinkRequest for RequestOpGetsetDumpRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, Iterable<'buf, OpGetsetDumpReply<'buf>>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2570u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpGetsetDumpReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpGetsetDumpRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Get / dump sets."]
pub struct PushOpGetsetDoRequest<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetsetDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetsetDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "table name"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "table name"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "set name"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "set name"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "bitmask of enum nft_set_flags\nAssociated type: \"SetFlags\" (enum)"]
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "key data type, informational purpose only"]
    pub fn push_key_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "key data length"]
    pub fn push_key_len(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "mapping data type"]
    pub fn push_data_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "mapping data length"]
    pub fn push_data_len(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 7u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "selection policy"]
    pub fn push_policy(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 8u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "set description"]
    pub fn nested_desc(mut self) -> PushSetDescAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 9u16);
        PushSetDescAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "uniquely identifies a set in a transaction"]
    pub fn push_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 10u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "default timeout value"]
    pub fn push_timeout(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 11u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "garbage collection interval"]
    pub fn push_gc_interval(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 12u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 13u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 14u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    #[doc = "stateful object type"]
    pub fn push_obj_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 15u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "set handle"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 16u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "set expression\nAttribute may repeat multiple times (treat it as array)"]
    pub fn nested_expr(mut self) -> PushExprAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 17u16);
        PushExprAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "list of expressions"]
    pub fn nested_expressions(mut self) -> PushSetListAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 18u16);
        PushSetListAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushOpGetsetDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump sets."]
#[doc = "Original name: \"op-getset-do-request\""]
#[derive(Clone)]
pub enum OpGetsetDoRequest<'a> {
    #[doc = "table name"]
    Table(&'a CStr),
    #[doc = "set name"]
    Name(&'a CStr),
    #[doc = "bitmask of enum nft_set_flags\nAssociated type: \"SetFlags\" (enum)"]
    Flags(u32),
    #[doc = "key data type, informational purpose only"]
    KeyType(u32),
    #[doc = "key data length"]
    KeyLen(u32),
    #[doc = "mapping data type"]
    DataType(u32),
    #[doc = "mapping data length"]
    DataLen(u32),
    #[doc = "selection policy"]
    Policy(u32),
    #[doc = "set description"]
    Desc(Iterable<'a, SetDescAttrs<'a>>),
    #[doc = "uniquely identifies a set in a transaction"]
    Id(u32),
    #[doc = "default timeout value"]
    Timeout(u64),
    #[doc = "garbage collection interval"]
    GcInterval(u32),
    #[doc = "user data"]
    Userdata(&'a [u8]),
    Pad(&'a [u8]),
    #[doc = "stateful object type"]
    ObjType(u32),
    #[doc = "set handle"]
    Handle(u64),
    #[doc = "set expression\nAttribute may repeat multiple times (treat it as array)"]
    Expr(Iterable<'a, ExprAttrs<'a>>),
    #[doc = "list of expressions"]
    Expressions(Iterable<'a, SetListAttrs<'a>>),
}
impl<'a> Iterable<'a, OpGetsetDoRequest<'a>> {
    #[doc = "table name"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDoRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDoRequest", "Table"))
    }
    #[doc = "set name"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDoRequest::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDoRequest", "Name"))
    }
    #[doc = "bitmask of enum nft_set_flags\nAssociated type: \"SetFlags\" (enum)"]
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDoRequest::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDoRequest", "Flags"))
    }
    #[doc = "key data type, informational purpose only"]
    pub fn get_key_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDoRequest::KeyType(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDoRequest", "KeyType"))
    }
    #[doc = "key data length"]
    pub fn get_key_len(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDoRequest::KeyLen(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDoRequest", "KeyLen"))
    }
    #[doc = "mapping data type"]
    pub fn get_data_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDoRequest::DataType(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDoRequest", "DataType"))
    }
    #[doc = "mapping data length"]
    pub fn get_data_len(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDoRequest::DataLen(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDoRequest", "DataLen"))
    }
    #[doc = "selection policy"]
    pub fn get_policy(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDoRequest::Policy(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDoRequest", "Policy"))
    }
    #[doc = "set description"]
    pub fn get_desc(&self) -> Result<Iterable<'a, SetDescAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDoRequest::Desc(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDoRequest", "Desc"))
    }
    #[doc = "uniquely identifies a set in a transaction"]
    pub fn get_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDoRequest::Id(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDoRequest", "Id"))
    }
    #[doc = "default timeout value"]
    pub fn get_timeout(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDoRequest::Timeout(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDoRequest", "Timeout"))
    }
    #[doc = "garbage collection interval"]
    pub fn get_gc_interval(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDoRequest::GcInterval(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDoRequest", "GcInterval"))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDoRequest::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDoRequest", "Userdata"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDoRequest::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDoRequest", "Pad"))
    }
    #[doc = "stateful object type"]
    pub fn get_obj_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDoRequest::ObjType(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDoRequest", "ObjType"))
    }
    #[doc = "set handle"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDoRequest::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDoRequest", "Handle"))
    }
    #[doc = "set expression\nAttribute may repeat multiple times (treat it as array)"]
    pub fn get_expr(
        &self,
    ) -> MultiAttrIterable<Self, OpGetsetDoRequest<'a>, Iterable<'a, ExprAttrs<'a>>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let OpGetsetDoRequest::Expr(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
    #[doc = "list of expressions"]
    pub fn get_expressions(&self) -> Result<Iterable<'a, SetListAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDoRequest::Expressions(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDoRequest", "Expressions"))
    }
}
impl<'a> OpGetsetDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpGetsetDoRequest<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        SetAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpGetsetDoRequest<'a>> {
    type Item = Result<OpGetsetDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetsetDoRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetsetDoRequest::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetsetDoRequest::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpGetsetDoRequest::KeyType({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpGetsetDoRequest::KeyLen({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpGetsetDoRequest::DataType({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpGetsetDoRequest::DataLen({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpGetsetDoRequest::Policy({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => OpGetsetDoRequest::Desc({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => OpGetsetDoRequest::Id({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => OpGetsetDoRequest::Timeout({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                12u16 => OpGetsetDoRequest::GcInterval({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                13u16 => OpGetsetDoRequest::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                14u16 => OpGetsetDoRequest::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                15u16 => OpGetsetDoRequest::ObjType({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                16u16 => OpGetsetDoRequest::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                17u16 => OpGetsetDoRequest::Expr({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                18u16 => OpGetsetDoRequest::Expressions({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpGetsetDoRequest",
            r#type.and_then(|t| OpGetsetDoRequest::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpGetsetDoRequest<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetsetDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetsetDoRequest::Table(val) => fmt.field("Table", &val),
                OpGetsetDoRequest::Name(val) => fmt.field("Name", &val),
                OpGetsetDoRequest::Flags(val) => {
                    fmt.field("Flags", &FormatFlags(val.into(), SetFlags::from_value))
                }
                OpGetsetDoRequest::KeyType(val) => fmt.field("KeyType", &val),
                OpGetsetDoRequest::KeyLen(val) => fmt.field("KeyLen", &val),
                OpGetsetDoRequest::DataType(val) => fmt.field("DataType", &val),
                OpGetsetDoRequest::DataLen(val) => fmt.field("DataLen", &val),
                OpGetsetDoRequest::Policy(val) => fmt.field("Policy", &val),
                OpGetsetDoRequest::Desc(val) => fmt.field("Desc", &val),
                OpGetsetDoRequest::Id(val) => fmt.field("Id", &val),
                OpGetsetDoRequest::Timeout(val) => fmt.field("Timeout", &val),
                OpGetsetDoRequest::GcInterval(val) => fmt.field("GcInterval", &val),
                OpGetsetDoRequest::Userdata(val) => fmt.field("Userdata", &val),
                OpGetsetDoRequest::Pad(val) => fmt.field("Pad", &val),
                OpGetsetDoRequest::ObjType(val) => fmt.field("ObjType", &val),
                OpGetsetDoRequest::Handle(val) => fmt.field("Handle", &val),
                OpGetsetDoRequest::Expr(val) => fmt.field("Expr", &val),
                OpGetsetDoRequest::Expressions(val) => fmt.field("Expressions", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpGetsetDoRequest<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetsetDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetsetDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetsetDoRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpGetsetDoRequest::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpGetsetDoRequest::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                OpGetsetDoRequest::KeyType(val) => {
                    if last_off == offset {
                        stack.push(("KeyType", last_off));
                        break;
                    }
                }
                OpGetsetDoRequest::KeyLen(val) => {
                    if last_off == offset {
                        stack.push(("KeyLen", last_off));
                        break;
                    }
                }
                OpGetsetDoRequest::DataType(val) => {
                    if last_off == offset {
                        stack.push(("DataType", last_off));
                        break;
                    }
                }
                OpGetsetDoRequest::DataLen(val) => {
                    if last_off == offset {
                        stack.push(("DataLen", last_off));
                        break;
                    }
                }
                OpGetsetDoRequest::Policy(val) => {
                    if last_off == offset {
                        stack.push(("Policy", last_off));
                        break;
                    }
                }
                OpGetsetDoRequest::Desc(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetsetDoRequest::Id(val) => {
                    if last_off == offset {
                        stack.push(("Id", last_off));
                        break;
                    }
                }
                OpGetsetDoRequest::Timeout(val) => {
                    if last_off == offset {
                        stack.push(("Timeout", last_off));
                        break;
                    }
                }
                OpGetsetDoRequest::GcInterval(val) => {
                    if last_off == offset {
                        stack.push(("GcInterval", last_off));
                        break;
                    }
                }
                OpGetsetDoRequest::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                OpGetsetDoRequest::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                OpGetsetDoRequest::ObjType(val) => {
                    if last_off == offset {
                        stack.push(("ObjType", last_off));
                        break;
                    }
                }
                OpGetsetDoRequest::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpGetsetDoRequest::Expr(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetsetDoRequest::Expressions(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetsetDoRequest", cur));
        }
        (stack, missing)
    }
}
#[doc = "Get / dump sets."]
pub struct PushOpGetsetDoReply<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetsetDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetsetDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "table name"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "table name"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "set name"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "set name"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "bitmask of enum nft_set_flags\nAssociated type: \"SetFlags\" (enum)"]
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "key data type, informational purpose only"]
    pub fn push_key_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "key data length"]
    pub fn push_key_len(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "mapping data type"]
    pub fn push_data_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "mapping data length"]
    pub fn push_data_len(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 7u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "selection policy"]
    pub fn push_policy(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 8u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "set description"]
    pub fn nested_desc(mut self) -> PushSetDescAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 9u16);
        PushSetDescAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "uniquely identifies a set in a transaction"]
    pub fn push_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 10u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "default timeout value"]
    pub fn push_timeout(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 11u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "garbage collection interval"]
    pub fn push_gc_interval(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 12u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 13u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 14u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    #[doc = "stateful object type"]
    pub fn push_obj_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 15u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "set handle"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 16u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "set expression\nAttribute may repeat multiple times (treat it as array)"]
    pub fn nested_expr(mut self) -> PushExprAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 17u16);
        PushExprAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "list of expressions"]
    pub fn nested_expressions(mut self) -> PushSetListAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 18u16);
        PushSetListAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushOpGetsetDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump sets."]
#[doc = "Original name: \"op-getset-do-reply\""]
#[derive(Clone)]
pub enum OpGetsetDoReply<'a> {
    #[doc = "table name"]
    Table(&'a CStr),
    #[doc = "set name"]
    Name(&'a CStr),
    #[doc = "bitmask of enum nft_set_flags\nAssociated type: \"SetFlags\" (enum)"]
    Flags(u32),
    #[doc = "key data type, informational purpose only"]
    KeyType(u32),
    #[doc = "key data length"]
    KeyLen(u32),
    #[doc = "mapping data type"]
    DataType(u32),
    #[doc = "mapping data length"]
    DataLen(u32),
    #[doc = "selection policy"]
    Policy(u32),
    #[doc = "set description"]
    Desc(Iterable<'a, SetDescAttrs<'a>>),
    #[doc = "uniquely identifies a set in a transaction"]
    Id(u32),
    #[doc = "default timeout value"]
    Timeout(u64),
    #[doc = "garbage collection interval"]
    GcInterval(u32),
    #[doc = "user data"]
    Userdata(&'a [u8]),
    Pad(&'a [u8]),
    #[doc = "stateful object type"]
    ObjType(u32),
    #[doc = "set handle"]
    Handle(u64),
    #[doc = "set expression\nAttribute may repeat multiple times (treat it as array)"]
    Expr(Iterable<'a, ExprAttrs<'a>>),
    #[doc = "list of expressions"]
    Expressions(Iterable<'a, SetListAttrs<'a>>),
}
impl<'a> Iterable<'a, OpGetsetDoReply<'a>> {
    #[doc = "table name"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDoReply::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDoReply", "Table"))
    }
    #[doc = "set name"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDoReply::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDoReply", "Name"))
    }
    #[doc = "bitmask of enum nft_set_flags\nAssociated type: \"SetFlags\" (enum)"]
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDoReply::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDoReply", "Flags"))
    }
    #[doc = "key data type, informational purpose only"]
    pub fn get_key_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDoReply::KeyType(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDoReply", "KeyType"))
    }
    #[doc = "key data length"]
    pub fn get_key_len(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDoReply::KeyLen(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDoReply", "KeyLen"))
    }
    #[doc = "mapping data type"]
    pub fn get_data_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDoReply::DataType(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDoReply", "DataType"))
    }
    #[doc = "mapping data length"]
    pub fn get_data_len(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDoReply::DataLen(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDoReply", "DataLen"))
    }
    #[doc = "selection policy"]
    pub fn get_policy(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDoReply::Policy(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDoReply", "Policy"))
    }
    #[doc = "set description"]
    pub fn get_desc(&self) -> Result<Iterable<'a, SetDescAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDoReply::Desc(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDoReply", "Desc"))
    }
    #[doc = "uniquely identifies a set in a transaction"]
    pub fn get_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDoReply::Id(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDoReply", "Id"))
    }
    #[doc = "default timeout value"]
    pub fn get_timeout(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDoReply::Timeout(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDoReply", "Timeout"))
    }
    #[doc = "garbage collection interval"]
    pub fn get_gc_interval(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDoReply::GcInterval(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDoReply", "GcInterval"))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDoReply::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDoReply", "Userdata"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDoReply::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDoReply", "Pad"))
    }
    #[doc = "stateful object type"]
    pub fn get_obj_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDoReply::ObjType(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDoReply", "ObjType"))
    }
    #[doc = "set handle"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDoReply::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDoReply", "Handle"))
    }
    #[doc = "set expression\nAttribute may repeat multiple times (treat it as array)"]
    pub fn get_expr(
        &self,
    ) -> MultiAttrIterable<Self, OpGetsetDoReply<'a>, Iterable<'a, ExprAttrs<'a>>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let OpGetsetDoReply::Expr(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
    #[doc = "list of expressions"]
    pub fn get_expressions(&self) -> Result<Iterable<'a, SetListAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDoReply::Expressions(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetDoReply", "Expressions"))
    }
}
impl<'a> OpGetsetDoReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpGetsetDoReply<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        SetAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpGetsetDoReply<'a>> {
    type Item = Result<OpGetsetDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetsetDoReply::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetsetDoReply::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetsetDoReply::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpGetsetDoReply::KeyType({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpGetsetDoReply::KeyLen({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpGetsetDoReply::DataType({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpGetsetDoReply::DataLen({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpGetsetDoReply::Policy({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => OpGetsetDoReply::Desc({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => OpGetsetDoReply::Id({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => OpGetsetDoReply::Timeout({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                12u16 => OpGetsetDoReply::GcInterval({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                13u16 => OpGetsetDoReply::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                14u16 => OpGetsetDoReply::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                15u16 => OpGetsetDoReply::ObjType({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                16u16 => OpGetsetDoReply::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                17u16 => OpGetsetDoReply::Expr({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                18u16 => OpGetsetDoReply::Expressions({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpGetsetDoReply",
            r#type.and_then(|t| OpGetsetDoReply::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpGetsetDoReply<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetsetDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetsetDoReply::Table(val) => fmt.field("Table", &val),
                OpGetsetDoReply::Name(val) => fmt.field("Name", &val),
                OpGetsetDoReply::Flags(val) => {
                    fmt.field("Flags", &FormatFlags(val.into(), SetFlags::from_value))
                }
                OpGetsetDoReply::KeyType(val) => fmt.field("KeyType", &val),
                OpGetsetDoReply::KeyLen(val) => fmt.field("KeyLen", &val),
                OpGetsetDoReply::DataType(val) => fmt.field("DataType", &val),
                OpGetsetDoReply::DataLen(val) => fmt.field("DataLen", &val),
                OpGetsetDoReply::Policy(val) => fmt.field("Policy", &val),
                OpGetsetDoReply::Desc(val) => fmt.field("Desc", &val),
                OpGetsetDoReply::Id(val) => fmt.field("Id", &val),
                OpGetsetDoReply::Timeout(val) => fmt.field("Timeout", &val),
                OpGetsetDoReply::GcInterval(val) => fmt.field("GcInterval", &val),
                OpGetsetDoReply::Userdata(val) => fmt.field("Userdata", &val),
                OpGetsetDoReply::Pad(val) => fmt.field("Pad", &val),
                OpGetsetDoReply::ObjType(val) => fmt.field("ObjType", &val),
                OpGetsetDoReply::Handle(val) => fmt.field("Handle", &val),
                OpGetsetDoReply::Expr(val) => fmt.field("Expr", &val),
                OpGetsetDoReply::Expressions(val) => fmt.field("Expressions", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpGetsetDoReply<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetsetDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetsetDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetsetDoReply::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpGetsetDoReply::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpGetsetDoReply::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                OpGetsetDoReply::KeyType(val) => {
                    if last_off == offset {
                        stack.push(("KeyType", last_off));
                        break;
                    }
                }
                OpGetsetDoReply::KeyLen(val) => {
                    if last_off == offset {
                        stack.push(("KeyLen", last_off));
                        break;
                    }
                }
                OpGetsetDoReply::DataType(val) => {
                    if last_off == offset {
                        stack.push(("DataType", last_off));
                        break;
                    }
                }
                OpGetsetDoReply::DataLen(val) => {
                    if last_off == offset {
                        stack.push(("DataLen", last_off));
                        break;
                    }
                }
                OpGetsetDoReply::Policy(val) => {
                    if last_off == offset {
                        stack.push(("Policy", last_off));
                        break;
                    }
                }
                OpGetsetDoReply::Desc(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetsetDoReply::Id(val) => {
                    if last_off == offset {
                        stack.push(("Id", last_off));
                        break;
                    }
                }
                OpGetsetDoReply::Timeout(val) => {
                    if last_off == offset {
                        stack.push(("Timeout", last_off));
                        break;
                    }
                }
                OpGetsetDoReply::GcInterval(val) => {
                    if last_off == offset {
                        stack.push(("GcInterval", last_off));
                        break;
                    }
                }
                OpGetsetDoReply::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                OpGetsetDoReply::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                OpGetsetDoReply::ObjType(val) => {
                    if last_off == offset {
                        stack.push(("ObjType", last_off));
                        break;
                    }
                }
                OpGetsetDoReply::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpGetsetDoReply::Expr(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetsetDoReply::Expressions(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetsetDoReply", cur));
        }
        (stack, missing)
    }
}
#[derive(Debug)]
pub struct RequestOpGetsetDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpGetsetDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpGetsetDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpGetsetDoRequest<&mut Vec<u8>> {
        PushOpGetsetDoRequest::new_without_header(self.request.buf_mut())
    }
}
impl NetlinkRequest for RequestOpGetsetDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, Iterable<'buf, OpGetsetDoReply<'buf>>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2570u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpGetsetDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpGetsetDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Delete an existing set."]
pub struct PushOpDelsetDoRequest<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDelsetDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDelsetDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "table name"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "table name"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "set name"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "set name"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "bitmask of enum nft_set_flags\nAssociated type: \"SetFlags\" (enum)"]
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "key data type, informational purpose only"]
    pub fn push_key_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "key data length"]
    pub fn push_key_len(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "mapping data type"]
    pub fn push_data_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "mapping data length"]
    pub fn push_data_len(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 7u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "selection policy"]
    pub fn push_policy(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 8u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "set description"]
    pub fn nested_desc(mut self) -> PushSetDescAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 9u16);
        PushSetDescAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "uniquely identifies a set in a transaction"]
    pub fn push_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 10u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "default timeout value"]
    pub fn push_timeout(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 11u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "garbage collection interval"]
    pub fn push_gc_interval(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 12u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 13u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 14u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    #[doc = "stateful object type"]
    pub fn push_obj_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 15u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "set handle"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 16u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "set expression\nAttribute may repeat multiple times (treat it as array)"]
    pub fn nested_expr(mut self) -> PushExprAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 17u16);
        PushExprAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "list of expressions"]
    pub fn nested_expressions(mut self) -> PushSetListAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 18u16);
        PushSetListAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushOpDelsetDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete an existing set."]
#[doc = "Original name: \"op-delset-do-request\""]
#[derive(Clone)]
pub enum OpDelsetDoRequest<'a> {
    #[doc = "table name"]
    Table(&'a CStr),
    #[doc = "set name"]
    Name(&'a CStr),
    #[doc = "bitmask of enum nft_set_flags\nAssociated type: \"SetFlags\" (enum)"]
    Flags(u32),
    #[doc = "key data type, informational purpose only"]
    KeyType(u32),
    #[doc = "key data length"]
    KeyLen(u32),
    #[doc = "mapping data type"]
    DataType(u32),
    #[doc = "mapping data length"]
    DataLen(u32),
    #[doc = "selection policy"]
    Policy(u32),
    #[doc = "set description"]
    Desc(Iterable<'a, SetDescAttrs<'a>>),
    #[doc = "uniquely identifies a set in a transaction"]
    Id(u32),
    #[doc = "default timeout value"]
    Timeout(u64),
    #[doc = "garbage collection interval"]
    GcInterval(u32),
    #[doc = "user data"]
    Userdata(&'a [u8]),
    Pad(&'a [u8]),
    #[doc = "stateful object type"]
    ObjType(u32),
    #[doc = "set handle"]
    Handle(u64),
    #[doc = "set expression\nAttribute may repeat multiple times (treat it as array)"]
    Expr(Iterable<'a, ExprAttrs<'a>>),
    #[doc = "list of expressions"]
    Expressions(Iterable<'a, SetListAttrs<'a>>),
}
impl<'a> Iterable<'a, OpDelsetDoRequest<'a>> {
    #[doc = "table name"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelsetDoRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelsetDoRequest", "Table"))
    }
    #[doc = "set name"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelsetDoRequest::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelsetDoRequest", "Name"))
    }
    #[doc = "bitmask of enum nft_set_flags\nAssociated type: \"SetFlags\" (enum)"]
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelsetDoRequest::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelsetDoRequest", "Flags"))
    }
    #[doc = "key data type, informational purpose only"]
    pub fn get_key_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelsetDoRequest::KeyType(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelsetDoRequest", "KeyType"))
    }
    #[doc = "key data length"]
    pub fn get_key_len(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelsetDoRequest::KeyLen(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelsetDoRequest", "KeyLen"))
    }
    #[doc = "mapping data type"]
    pub fn get_data_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelsetDoRequest::DataType(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelsetDoRequest", "DataType"))
    }
    #[doc = "mapping data length"]
    pub fn get_data_len(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelsetDoRequest::DataLen(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelsetDoRequest", "DataLen"))
    }
    #[doc = "selection policy"]
    pub fn get_policy(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelsetDoRequest::Policy(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelsetDoRequest", "Policy"))
    }
    #[doc = "set description"]
    pub fn get_desc(&self) -> Result<Iterable<'a, SetDescAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelsetDoRequest::Desc(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelsetDoRequest", "Desc"))
    }
    #[doc = "uniquely identifies a set in a transaction"]
    pub fn get_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelsetDoRequest::Id(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelsetDoRequest", "Id"))
    }
    #[doc = "default timeout value"]
    pub fn get_timeout(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelsetDoRequest::Timeout(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelsetDoRequest", "Timeout"))
    }
    #[doc = "garbage collection interval"]
    pub fn get_gc_interval(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelsetDoRequest::GcInterval(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelsetDoRequest", "GcInterval"))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelsetDoRequest::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelsetDoRequest", "Userdata"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelsetDoRequest::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelsetDoRequest", "Pad"))
    }
    #[doc = "stateful object type"]
    pub fn get_obj_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelsetDoRequest::ObjType(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelsetDoRequest", "ObjType"))
    }
    #[doc = "set handle"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelsetDoRequest::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelsetDoRequest", "Handle"))
    }
    #[doc = "set expression\nAttribute may repeat multiple times (treat it as array)"]
    pub fn get_expr(
        &self,
    ) -> MultiAttrIterable<Self, OpDelsetDoRequest<'a>, Iterable<'a, ExprAttrs<'a>>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let OpDelsetDoRequest::Expr(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
    #[doc = "list of expressions"]
    pub fn get_expressions(&self) -> Result<Iterable<'a, SetListAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelsetDoRequest::Expressions(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelsetDoRequest", "Expressions"))
    }
}
impl<'a> OpDelsetDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpDelsetDoRequest<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        SetAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpDelsetDoRequest<'a>> {
    type Item = Result<OpDelsetDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpDelsetDoRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpDelsetDoRequest::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpDelsetDoRequest::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpDelsetDoRequest::KeyType({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpDelsetDoRequest::KeyLen({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpDelsetDoRequest::DataType({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpDelsetDoRequest::DataLen({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpDelsetDoRequest::Policy({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => OpDelsetDoRequest::Desc({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => OpDelsetDoRequest::Id({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => OpDelsetDoRequest::Timeout({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                12u16 => OpDelsetDoRequest::GcInterval({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                13u16 => OpDelsetDoRequest::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                14u16 => OpDelsetDoRequest::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                15u16 => OpDelsetDoRequest::ObjType({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                16u16 => OpDelsetDoRequest::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                17u16 => OpDelsetDoRequest::Expr({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                18u16 => OpDelsetDoRequest::Expressions({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpDelsetDoRequest",
            r#type.and_then(|t| OpDelsetDoRequest::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpDelsetDoRequest<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDelsetDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpDelsetDoRequest::Table(val) => fmt.field("Table", &val),
                OpDelsetDoRequest::Name(val) => fmt.field("Name", &val),
                OpDelsetDoRequest::Flags(val) => {
                    fmt.field("Flags", &FormatFlags(val.into(), SetFlags::from_value))
                }
                OpDelsetDoRequest::KeyType(val) => fmt.field("KeyType", &val),
                OpDelsetDoRequest::KeyLen(val) => fmt.field("KeyLen", &val),
                OpDelsetDoRequest::DataType(val) => fmt.field("DataType", &val),
                OpDelsetDoRequest::DataLen(val) => fmt.field("DataLen", &val),
                OpDelsetDoRequest::Policy(val) => fmt.field("Policy", &val),
                OpDelsetDoRequest::Desc(val) => fmt.field("Desc", &val),
                OpDelsetDoRequest::Id(val) => fmt.field("Id", &val),
                OpDelsetDoRequest::Timeout(val) => fmt.field("Timeout", &val),
                OpDelsetDoRequest::GcInterval(val) => fmt.field("GcInterval", &val),
                OpDelsetDoRequest::Userdata(val) => fmt.field("Userdata", &val),
                OpDelsetDoRequest::Pad(val) => fmt.field("Pad", &val),
                OpDelsetDoRequest::ObjType(val) => fmt.field("ObjType", &val),
                OpDelsetDoRequest::Handle(val) => fmt.field("Handle", &val),
                OpDelsetDoRequest::Expr(val) => fmt.field("Expr", &val),
                OpDelsetDoRequest::Expressions(val) => fmt.field("Expressions", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpDelsetDoRequest<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpDelsetDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDelsetDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpDelsetDoRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpDelsetDoRequest::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpDelsetDoRequest::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                OpDelsetDoRequest::KeyType(val) => {
                    if last_off == offset {
                        stack.push(("KeyType", last_off));
                        break;
                    }
                }
                OpDelsetDoRequest::KeyLen(val) => {
                    if last_off == offset {
                        stack.push(("KeyLen", last_off));
                        break;
                    }
                }
                OpDelsetDoRequest::DataType(val) => {
                    if last_off == offset {
                        stack.push(("DataType", last_off));
                        break;
                    }
                }
                OpDelsetDoRequest::DataLen(val) => {
                    if last_off == offset {
                        stack.push(("DataLen", last_off));
                        break;
                    }
                }
                OpDelsetDoRequest::Policy(val) => {
                    if last_off == offset {
                        stack.push(("Policy", last_off));
                        break;
                    }
                }
                OpDelsetDoRequest::Desc(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpDelsetDoRequest::Id(val) => {
                    if last_off == offset {
                        stack.push(("Id", last_off));
                        break;
                    }
                }
                OpDelsetDoRequest::Timeout(val) => {
                    if last_off == offset {
                        stack.push(("Timeout", last_off));
                        break;
                    }
                }
                OpDelsetDoRequest::GcInterval(val) => {
                    if last_off == offset {
                        stack.push(("GcInterval", last_off));
                        break;
                    }
                }
                OpDelsetDoRequest::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                OpDelsetDoRequest::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                OpDelsetDoRequest::ObjType(val) => {
                    if last_off == offset {
                        stack.push(("ObjType", last_off));
                        break;
                    }
                }
                OpDelsetDoRequest::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpDelsetDoRequest::Expr(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpDelsetDoRequest::Expressions(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpDelsetDoRequest", cur));
        }
        (stack, missing)
    }
}
#[doc = "Delete an existing set."]
pub struct PushOpDelsetDoReply<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDelsetDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDelsetDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "table name"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "table name"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "set name"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "set name"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "bitmask of enum nft_set_flags\nAssociated type: \"SetFlags\" (enum)"]
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "key data type, informational purpose only"]
    pub fn push_key_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "key data length"]
    pub fn push_key_len(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "mapping data type"]
    pub fn push_data_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "mapping data length"]
    pub fn push_data_len(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 7u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "selection policy"]
    pub fn push_policy(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 8u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "set description"]
    pub fn nested_desc(mut self) -> PushSetDescAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 9u16);
        PushSetDescAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "uniquely identifies a set in a transaction"]
    pub fn push_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 10u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "default timeout value"]
    pub fn push_timeout(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 11u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "garbage collection interval"]
    pub fn push_gc_interval(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 12u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 13u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 14u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    #[doc = "stateful object type"]
    pub fn push_obj_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 15u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "set handle"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 16u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "set expression\nAttribute may repeat multiple times (treat it as array)"]
    pub fn nested_expr(mut self) -> PushExprAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 17u16);
        PushExprAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "list of expressions"]
    pub fn nested_expressions(mut self) -> PushSetListAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 18u16);
        PushSetListAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushOpDelsetDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete an existing set."]
#[doc = "Original name: \"op-delset-do-reply\""]
#[derive(Clone)]
pub enum OpDelsetDoReply<'a> {
    #[doc = "table name"]
    Table(&'a CStr),
    #[doc = "set name"]
    Name(&'a CStr),
    #[doc = "bitmask of enum nft_set_flags\nAssociated type: \"SetFlags\" (enum)"]
    Flags(u32),
    #[doc = "key data type, informational purpose only"]
    KeyType(u32),
    #[doc = "key data length"]
    KeyLen(u32),
    #[doc = "mapping data type"]
    DataType(u32),
    #[doc = "mapping data length"]
    DataLen(u32),
    #[doc = "selection policy"]
    Policy(u32),
    #[doc = "set description"]
    Desc(Iterable<'a, SetDescAttrs<'a>>),
    #[doc = "uniquely identifies a set in a transaction"]
    Id(u32),
    #[doc = "default timeout value"]
    Timeout(u64),
    #[doc = "garbage collection interval"]
    GcInterval(u32),
    #[doc = "user data"]
    Userdata(&'a [u8]),
    Pad(&'a [u8]),
    #[doc = "stateful object type"]
    ObjType(u32),
    #[doc = "set handle"]
    Handle(u64),
    #[doc = "set expression\nAttribute may repeat multiple times (treat it as array)"]
    Expr(Iterable<'a, ExprAttrs<'a>>),
    #[doc = "list of expressions"]
    Expressions(Iterable<'a, SetListAttrs<'a>>),
}
impl<'a> Iterable<'a, OpDelsetDoReply<'a>> {
    #[doc = "table name"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelsetDoReply::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelsetDoReply", "Table"))
    }
    #[doc = "set name"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelsetDoReply::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelsetDoReply", "Name"))
    }
    #[doc = "bitmask of enum nft_set_flags\nAssociated type: \"SetFlags\" (enum)"]
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelsetDoReply::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelsetDoReply", "Flags"))
    }
    #[doc = "key data type, informational purpose only"]
    pub fn get_key_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelsetDoReply::KeyType(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelsetDoReply", "KeyType"))
    }
    #[doc = "key data length"]
    pub fn get_key_len(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelsetDoReply::KeyLen(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelsetDoReply", "KeyLen"))
    }
    #[doc = "mapping data type"]
    pub fn get_data_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelsetDoReply::DataType(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelsetDoReply", "DataType"))
    }
    #[doc = "mapping data length"]
    pub fn get_data_len(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelsetDoReply::DataLen(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelsetDoReply", "DataLen"))
    }
    #[doc = "selection policy"]
    pub fn get_policy(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelsetDoReply::Policy(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelsetDoReply", "Policy"))
    }
    #[doc = "set description"]
    pub fn get_desc(&self) -> Result<Iterable<'a, SetDescAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelsetDoReply::Desc(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelsetDoReply", "Desc"))
    }
    #[doc = "uniquely identifies a set in a transaction"]
    pub fn get_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelsetDoReply::Id(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelsetDoReply", "Id"))
    }
    #[doc = "default timeout value"]
    pub fn get_timeout(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelsetDoReply::Timeout(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelsetDoReply", "Timeout"))
    }
    #[doc = "garbage collection interval"]
    pub fn get_gc_interval(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelsetDoReply::GcInterval(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelsetDoReply", "GcInterval"))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelsetDoReply::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelsetDoReply", "Userdata"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelsetDoReply::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelsetDoReply", "Pad"))
    }
    #[doc = "stateful object type"]
    pub fn get_obj_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelsetDoReply::ObjType(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelsetDoReply", "ObjType"))
    }
    #[doc = "set handle"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelsetDoReply::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelsetDoReply", "Handle"))
    }
    #[doc = "set expression\nAttribute may repeat multiple times (treat it as array)"]
    pub fn get_expr(
        &self,
    ) -> MultiAttrIterable<Self, OpDelsetDoReply<'a>, Iterable<'a, ExprAttrs<'a>>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let OpDelsetDoReply::Expr(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
    #[doc = "list of expressions"]
    pub fn get_expressions(&self) -> Result<Iterable<'a, SetListAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelsetDoReply::Expressions(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelsetDoReply", "Expressions"))
    }
}
impl<'a> OpDelsetDoReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpDelsetDoReply<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        SetAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpDelsetDoReply<'a>> {
    type Item = Result<OpDelsetDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpDelsetDoReply::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpDelsetDoReply::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpDelsetDoReply::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpDelsetDoReply::KeyType({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpDelsetDoReply::KeyLen({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpDelsetDoReply::DataType({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpDelsetDoReply::DataLen({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpDelsetDoReply::Policy({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => OpDelsetDoReply::Desc({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => OpDelsetDoReply::Id({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => OpDelsetDoReply::Timeout({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                12u16 => OpDelsetDoReply::GcInterval({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                13u16 => OpDelsetDoReply::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                14u16 => OpDelsetDoReply::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                15u16 => OpDelsetDoReply::ObjType({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                16u16 => OpDelsetDoReply::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                17u16 => OpDelsetDoReply::Expr({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                18u16 => OpDelsetDoReply::Expressions({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpDelsetDoReply",
            r#type.and_then(|t| OpDelsetDoReply::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpDelsetDoReply<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDelsetDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpDelsetDoReply::Table(val) => fmt.field("Table", &val),
                OpDelsetDoReply::Name(val) => fmt.field("Name", &val),
                OpDelsetDoReply::Flags(val) => {
                    fmt.field("Flags", &FormatFlags(val.into(), SetFlags::from_value))
                }
                OpDelsetDoReply::KeyType(val) => fmt.field("KeyType", &val),
                OpDelsetDoReply::KeyLen(val) => fmt.field("KeyLen", &val),
                OpDelsetDoReply::DataType(val) => fmt.field("DataType", &val),
                OpDelsetDoReply::DataLen(val) => fmt.field("DataLen", &val),
                OpDelsetDoReply::Policy(val) => fmt.field("Policy", &val),
                OpDelsetDoReply::Desc(val) => fmt.field("Desc", &val),
                OpDelsetDoReply::Id(val) => fmt.field("Id", &val),
                OpDelsetDoReply::Timeout(val) => fmt.field("Timeout", &val),
                OpDelsetDoReply::GcInterval(val) => fmt.field("GcInterval", &val),
                OpDelsetDoReply::Userdata(val) => fmt.field("Userdata", &val),
                OpDelsetDoReply::Pad(val) => fmt.field("Pad", &val),
                OpDelsetDoReply::ObjType(val) => fmt.field("ObjType", &val),
                OpDelsetDoReply::Handle(val) => fmt.field("Handle", &val),
                OpDelsetDoReply::Expr(val) => fmt.field("Expr", &val),
                OpDelsetDoReply::Expressions(val) => fmt.field("Expressions", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpDelsetDoReply<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpDelsetDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDelsetDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpDelsetDoReply::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpDelsetDoReply::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpDelsetDoReply::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                OpDelsetDoReply::KeyType(val) => {
                    if last_off == offset {
                        stack.push(("KeyType", last_off));
                        break;
                    }
                }
                OpDelsetDoReply::KeyLen(val) => {
                    if last_off == offset {
                        stack.push(("KeyLen", last_off));
                        break;
                    }
                }
                OpDelsetDoReply::DataType(val) => {
                    if last_off == offset {
                        stack.push(("DataType", last_off));
                        break;
                    }
                }
                OpDelsetDoReply::DataLen(val) => {
                    if last_off == offset {
                        stack.push(("DataLen", last_off));
                        break;
                    }
                }
                OpDelsetDoReply::Policy(val) => {
                    if last_off == offset {
                        stack.push(("Policy", last_off));
                        break;
                    }
                }
                OpDelsetDoReply::Desc(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpDelsetDoReply::Id(val) => {
                    if last_off == offset {
                        stack.push(("Id", last_off));
                        break;
                    }
                }
                OpDelsetDoReply::Timeout(val) => {
                    if last_off == offset {
                        stack.push(("Timeout", last_off));
                        break;
                    }
                }
                OpDelsetDoReply::GcInterval(val) => {
                    if last_off == offset {
                        stack.push(("GcInterval", last_off));
                        break;
                    }
                }
                OpDelsetDoReply::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                OpDelsetDoReply::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                OpDelsetDoReply::ObjType(val) => {
                    if last_off == offset {
                        stack.push(("ObjType", last_off));
                        break;
                    }
                }
                OpDelsetDoReply::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpDelsetDoReply::Expr(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpDelsetDoReply::Expressions(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpDelsetDoReply", cur));
        }
        (stack, missing)
    }
}
#[derive(Debug)]
pub struct RequestOpDelsetDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpDelsetDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpDelsetDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpDelsetDoRequest<&mut Vec<u8>> {
        PushOpDelsetDoRequest::new_without_header(self.request.buf_mut())
    }
}
impl NetlinkRequest for RequestOpDelsetDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, Iterable<'buf, OpDelsetDoReply<'buf>>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2571u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpDelsetDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpDelsetDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Delete an existing set with destroy semantics (ignoring ENOENT errors).\n"]
pub struct PushOpDestroysetDoRequest<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDestroysetDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDestroysetDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "table name"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "table name"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "set name"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "set name"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "bitmask of enum nft_set_flags\nAssociated type: \"SetFlags\" (enum)"]
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "key data type, informational purpose only"]
    pub fn push_key_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "key data length"]
    pub fn push_key_len(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "mapping data type"]
    pub fn push_data_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "mapping data length"]
    pub fn push_data_len(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 7u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "selection policy"]
    pub fn push_policy(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 8u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "set description"]
    pub fn nested_desc(mut self) -> PushSetDescAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 9u16);
        PushSetDescAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "uniquely identifies a set in a transaction"]
    pub fn push_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 10u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "default timeout value"]
    pub fn push_timeout(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 11u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "garbage collection interval"]
    pub fn push_gc_interval(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 12u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 13u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 14u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    #[doc = "stateful object type"]
    pub fn push_obj_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 15u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "set handle"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 16u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "set expression\nAttribute may repeat multiple times (treat it as array)"]
    pub fn nested_expr(mut self) -> PushExprAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 17u16);
        PushExprAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "list of expressions"]
    pub fn nested_expressions(mut self) -> PushSetListAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 18u16);
        PushSetListAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushOpDestroysetDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete an existing set with destroy semantics (ignoring ENOENT errors).\n"]
#[doc = "Original name: \"op-destroyset-do-request\""]
#[derive(Clone)]
pub enum OpDestroysetDoRequest<'a> {
    #[doc = "table name"]
    Table(&'a CStr),
    #[doc = "set name"]
    Name(&'a CStr),
    #[doc = "bitmask of enum nft_set_flags\nAssociated type: \"SetFlags\" (enum)"]
    Flags(u32),
    #[doc = "key data type, informational purpose only"]
    KeyType(u32),
    #[doc = "key data length"]
    KeyLen(u32),
    #[doc = "mapping data type"]
    DataType(u32),
    #[doc = "mapping data length"]
    DataLen(u32),
    #[doc = "selection policy"]
    Policy(u32),
    #[doc = "set description"]
    Desc(Iterable<'a, SetDescAttrs<'a>>),
    #[doc = "uniquely identifies a set in a transaction"]
    Id(u32),
    #[doc = "default timeout value"]
    Timeout(u64),
    #[doc = "garbage collection interval"]
    GcInterval(u32),
    #[doc = "user data"]
    Userdata(&'a [u8]),
    Pad(&'a [u8]),
    #[doc = "stateful object type"]
    ObjType(u32),
    #[doc = "set handle"]
    Handle(u64),
    #[doc = "set expression\nAttribute may repeat multiple times (treat it as array)"]
    Expr(Iterable<'a, ExprAttrs<'a>>),
    #[doc = "list of expressions"]
    Expressions(Iterable<'a, SetListAttrs<'a>>),
}
impl<'a> Iterable<'a, OpDestroysetDoRequest<'a>> {
    #[doc = "table name"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroysetDoRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroysetDoRequest", "Table"))
    }
    #[doc = "set name"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroysetDoRequest::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroysetDoRequest", "Name"))
    }
    #[doc = "bitmask of enum nft_set_flags\nAssociated type: \"SetFlags\" (enum)"]
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroysetDoRequest::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroysetDoRequest", "Flags"))
    }
    #[doc = "key data type, informational purpose only"]
    pub fn get_key_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroysetDoRequest::KeyType(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroysetDoRequest", "KeyType"))
    }
    #[doc = "key data length"]
    pub fn get_key_len(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroysetDoRequest::KeyLen(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroysetDoRequest", "KeyLen"))
    }
    #[doc = "mapping data type"]
    pub fn get_data_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroysetDoRequest::DataType(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroysetDoRequest", "DataType"))
    }
    #[doc = "mapping data length"]
    pub fn get_data_len(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroysetDoRequest::DataLen(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroysetDoRequest", "DataLen"))
    }
    #[doc = "selection policy"]
    pub fn get_policy(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroysetDoRequest::Policy(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroysetDoRequest", "Policy"))
    }
    #[doc = "set description"]
    pub fn get_desc(&self) -> Result<Iterable<'a, SetDescAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroysetDoRequest::Desc(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroysetDoRequest", "Desc"))
    }
    #[doc = "uniquely identifies a set in a transaction"]
    pub fn get_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroysetDoRequest::Id(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroysetDoRequest", "Id"))
    }
    #[doc = "default timeout value"]
    pub fn get_timeout(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroysetDoRequest::Timeout(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroysetDoRequest", "Timeout"))
    }
    #[doc = "garbage collection interval"]
    pub fn get_gc_interval(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroysetDoRequest::GcInterval(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroysetDoRequest", "GcInterval"))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroysetDoRequest::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroysetDoRequest", "Userdata"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroysetDoRequest::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroysetDoRequest", "Pad"))
    }
    #[doc = "stateful object type"]
    pub fn get_obj_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroysetDoRequest::ObjType(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroysetDoRequest", "ObjType"))
    }
    #[doc = "set handle"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroysetDoRequest::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroysetDoRequest", "Handle"))
    }
    #[doc = "set expression\nAttribute may repeat multiple times (treat it as array)"]
    pub fn get_expr(
        &self,
    ) -> MultiAttrIterable<Self, OpDestroysetDoRequest<'a>, Iterable<'a, ExprAttrs<'a>>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let OpDestroysetDoRequest::Expr(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
    #[doc = "list of expressions"]
    pub fn get_expressions(&self) -> Result<Iterable<'a, SetListAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroysetDoRequest::Expressions(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroysetDoRequest", "Expressions"))
    }
}
impl<'a> OpDestroysetDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpDestroysetDoRequest<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        SetAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpDestroysetDoRequest<'a>> {
    type Item = Result<OpDestroysetDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpDestroysetDoRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpDestroysetDoRequest::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpDestroysetDoRequest::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpDestroysetDoRequest::KeyType({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpDestroysetDoRequest::KeyLen({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpDestroysetDoRequest::DataType({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpDestroysetDoRequest::DataLen({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpDestroysetDoRequest::Policy({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => OpDestroysetDoRequest::Desc({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => OpDestroysetDoRequest::Id({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => OpDestroysetDoRequest::Timeout({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                12u16 => OpDestroysetDoRequest::GcInterval({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                13u16 => OpDestroysetDoRequest::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                14u16 => OpDestroysetDoRequest::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                15u16 => OpDestroysetDoRequest::ObjType({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                16u16 => OpDestroysetDoRequest::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                17u16 => OpDestroysetDoRequest::Expr({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                18u16 => OpDestroysetDoRequest::Expressions({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpDestroysetDoRequest",
            r#type.and_then(|t| OpDestroysetDoRequest::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpDestroysetDoRequest<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDestroysetDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpDestroysetDoRequest::Table(val) => fmt.field("Table", &val),
                OpDestroysetDoRequest::Name(val) => fmt.field("Name", &val),
                OpDestroysetDoRequest::Flags(val) => {
                    fmt.field("Flags", &FormatFlags(val.into(), SetFlags::from_value))
                }
                OpDestroysetDoRequest::KeyType(val) => fmt.field("KeyType", &val),
                OpDestroysetDoRequest::KeyLen(val) => fmt.field("KeyLen", &val),
                OpDestroysetDoRequest::DataType(val) => fmt.field("DataType", &val),
                OpDestroysetDoRequest::DataLen(val) => fmt.field("DataLen", &val),
                OpDestroysetDoRequest::Policy(val) => fmt.field("Policy", &val),
                OpDestroysetDoRequest::Desc(val) => fmt.field("Desc", &val),
                OpDestroysetDoRequest::Id(val) => fmt.field("Id", &val),
                OpDestroysetDoRequest::Timeout(val) => fmt.field("Timeout", &val),
                OpDestroysetDoRequest::GcInterval(val) => fmt.field("GcInterval", &val),
                OpDestroysetDoRequest::Userdata(val) => fmt.field("Userdata", &val),
                OpDestroysetDoRequest::Pad(val) => fmt.field("Pad", &val),
                OpDestroysetDoRequest::ObjType(val) => fmt.field("ObjType", &val),
                OpDestroysetDoRequest::Handle(val) => fmt.field("Handle", &val),
                OpDestroysetDoRequest::Expr(val) => fmt.field("Expr", &val),
                OpDestroysetDoRequest::Expressions(val) => fmt.field("Expressions", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpDestroysetDoRequest<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpDestroysetDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDestroysetDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpDestroysetDoRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpDestroysetDoRequest::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpDestroysetDoRequest::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                OpDestroysetDoRequest::KeyType(val) => {
                    if last_off == offset {
                        stack.push(("KeyType", last_off));
                        break;
                    }
                }
                OpDestroysetDoRequest::KeyLen(val) => {
                    if last_off == offset {
                        stack.push(("KeyLen", last_off));
                        break;
                    }
                }
                OpDestroysetDoRequest::DataType(val) => {
                    if last_off == offset {
                        stack.push(("DataType", last_off));
                        break;
                    }
                }
                OpDestroysetDoRequest::DataLen(val) => {
                    if last_off == offset {
                        stack.push(("DataLen", last_off));
                        break;
                    }
                }
                OpDestroysetDoRequest::Policy(val) => {
                    if last_off == offset {
                        stack.push(("Policy", last_off));
                        break;
                    }
                }
                OpDestroysetDoRequest::Desc(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpDestroysetDoRequest::Id(val) => {
                    if last_off == offset {
                        stack.push(("Id", last_off));
                        break;
                    }
                }
                OpDestroysetDoRequest::Timeout(val) => {
                    if last_off == offset {
                        stack.push(("Timeout", last_off));
                        break;
                    }
                }
                OpDestroysetDoRequest::GcInterval(val) => {
                    if last_off == offset {
                        stack.push(("GcInterval", last_off));
                        break;
                    }
                }
                OpDestroysetDoRequest::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                OpDestroysetDoRequest::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                OpDestroysetDoRequest::ObjType(val) => {
                    if last_off == offset {
                        stack.push(("ObjType", last_off));
                        break;
                    }
                }
                OpDestroysetDoRequest::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpDestroysetDoRequest::Expr(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpDestroysetDoRequest::Expressions(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpDestroysetDoRequest", cur));
        }
        (stack, missing)
    }
}
#[doc = "Delete an existing set with destroy semantics (ignoring ENOENT errors).\n"]
pub struct PushOpDestroysetDoReply<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDestroysetDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDestroysetDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "table name"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "table name"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "set name"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "set name"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "bitmask of enum nft_set_flags\nAssociated type: \"SetFlags\" (enum)"]
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "key data type, informational purpose only"]
    pub fn push_key_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "key data length"]
    pub fn push_key_len(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "mapping data type"]
    pub fn push_data_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "mapping data length"]
    pub fn push_data_len(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 7u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "selection policy"]
    pub fn push_policy(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 8u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "set description"]
    pub fn nested_desc(mut self) -> PushSetDescAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 9u16);
        PushSetDescAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "uniquely identifies a set in a transaction"]
    pub fn push_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 10u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "default timeout value"]
    pub fn push_timeout(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 11u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "garbage collection interval"]
    pub fn push_gc_interval(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 12u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 13u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 14u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    #[doc = "stateful object type"]
    pub fn push_obj_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 15u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "set handle"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 16u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "set expression\nAttribute may repeat multiple times (treat it as array)"]
    pub fn nested_expr(mut self) -> PushExprAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 17u16);
        PushExprAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "list of expressions"]
    pub fn nested_expressions(mut self) -> PushSetListAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 18u16);
        PushSetListAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushOpDestroysetDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete an existing set with destroy semantics (ignoring ENOENT errors).\n"]
#[doc = "Original name: \"op-destroyset-do-reply\""]
#[derive(Clone)]
pub enum OpDestroysetDoReply<'a> {
    #[doc = "table name"]
    Table(&'a CStr),
    #[doc = "set name"]
    Name(&'a CStr),
    #[doc = "bitmask of enum nft_set_flags\nAssociated type: \"SetFlags\" (enum)"]
    Flags(u32),
    #[doc = "key data type, informational purpose only"]
    KeyType(u32),
    #[doc = "key data length"]
    KeyLen(u32),
    #[doc = "mapping data type"]
    DataType(u32),
    #[doc = "mapping data length"]
    DataLen(u32),
    #[doc = "selection policy"]
    Policy(u32),
    #[doc = "set description"]
    Desc(Iterable<'a, SetDescAttrs<'a>>),
    #[doc = "uniquely identifies a set in a transaction"]
    Id(u32),
    #[doc = "default timeout value"]
    Timeout(u64),
    #[doc = "garbage collection interval"]
    GcInterval(u32),
    #[doc = "user data"]
    Userdata(&'a [u8]),
    Pad(&'a [u8]),
    #[doc = "stateful object type"]
    ObjType(u32),
    #[doc = "set handle"]
    Handle(u64),
    #[doc = "set expression\nAttribute may repeat multiple times (treat it as array)"]
    Expr(Iterable<'a, ExprAttrs<'a>>),
    #[doc = "list of expressions"]
    Expressions(Iterable<'a, SetListAttrs<'a>>),
}
impl<'a> Iterable<'a, OpDestroysetDoReply<'a>> {
    #[doc = "table name"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroysetDoReply::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroysetDoReply", "Table"))
    }
    #[doc = "set name"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroysetDoReply::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroysetDoReply", "Name"))
    }
    #[doc = "bitmask of enum nft_set_flags\nAssociated type: \"SetFlags\" (enum)"]
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroysetDoReply::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroysetDoReply", "Flags"))
    }
    #[doc = "key data type, informational purpose only"]
    pub fn get_key_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroysetDoReply::KeyType(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroysetDoReply", "KeyType"))
    }
    #[doc = "key data length"]
    pub fn get_key_len(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroysetDoReply::KeyLen(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroysetDoReply", "KeyLen"))
    }
    #[doc = "mapping data type"]
    pub fn get_data_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroysetDoReply::DataType(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroysetDoReply", "DataType"))
    }
    #[doc = "mapping data length"]
    pub fn get_data_len(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroysetDoReply::DataLen(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroysetDoReply", "DataLen"))
    }
    #[doc = "selection policy"]
    pub fn get_policy(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroysetDoReply::Policy(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroysetDoReply", "Policy"))
    }
    #[doc = "set description"]
    pub fn get_desc(&self) -> Result<Iterable<'a, SetDescAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroysetDoReply::Desc(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroysetDoReply", "Desc"))
    }
    #[doc = "uniquely identifies a set in a transaction"]
    pub fn get_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroysetDoReply::Id(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroysetDoReply", "Id"))
    }
    #[doc = "default timeout value"]
    pub fn get_timeout(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroysetDoReply::Timeout(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroysetDoReply", "Timeout"))
    }
    #[doc = "garbage collection interval"]
    pub fn get_gc_interval(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroysetDoReply::GcInterval(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroysetDoReply", "GcInterval"))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroysetDoReply::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroysetDoReply", "Userdata"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroysetDoReply::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroysetDoReply", "Pad"))
    }
    #[doc = "stateful object type"]
    pub fn get_obj_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroysetDoReply::ObjType(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroysetDoReply", "ObjType"))
    }
    #[doc = "set handle"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroysetDoReply::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroysetDoReply", "Handle"))
    }
    #[doc = "set expression\nAttribute may repeat multiple times (treat it as array)"]
    pub fn get_expr(
        &self,
    ) -> MultiAttrIterable<Self, OpDestroysetDoReply<'a>, Iterable<'a, ExprAttrs<'a>>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let OpDestroysetDoReply::Expr(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
    #[doc = "list of expressions"]
    pub fn get_expressions(&self) -> Result<Iterable<'a, SetListAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroysetDoReply::Expressions(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroysetDoReply", "Expressions"))
    }
}
impl<'a> OpDestroysetDoReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpDestroysetDoReply<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        SetAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpDestroysetDoReply<'a>> {
    type Item = Result<OpDestroysetDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpDestroysetDoReply::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpDestroysetDoReply::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpDestroysetDoReply::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpDestroysetDoReply::KeyType({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpDestroysetDoReply::KeyLen({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpDestroysetDoReply::DataType({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpDestroysetDoReply::DataLen({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpDestroysetDoReply::Policy({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => OpDestroysetDoReply::Desc({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => OpDestroysetDoReply::Id({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => OpDestroysetDoReply::Timeout({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                12u16 => OpDestroysetDoReply::GcInterval({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                13u16 => OpDestroysetDoReply::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                14u16 => OpDestroysetDoReply::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                15u16 => OpDestroysetDoReply::ObjType({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                16u16 => OpDestroysetDoReply::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                17u16 => OpDestroysetDoReply::Expr({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                18u16 => OpDestroysetDoReply::Expressions({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpDestroysetDoReply",
            r#type.and_then(|t| OpDestroysetDoReply::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpDestroysetDoReply<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDestroysetDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpDestroysetDoReply::Table(val) => fmt.field("Table", &val),
                OpDestroysetDoReply::Name(val) => fmt.field("Name", &val),
                OpDestroysetDoReply::Flags(val) => {
                    fmt.field("Flags", &FormatFlags(val.into(), SetFlags::from_value))
                }
                OpDestroysetDoReply::KeyType(val) => fmt.field("KeyType", &val),
                OpDestroysetDoReply::KeyLen(val) => fmt.field("KeyLen", &val),
                OpDestroysetDoReply::DataType(val) => fmt.field("DataType", &val),
                OpDestroysetDoReply::DataLen(val) => fmt.field("DataLen", &val),
                OpDestroysetDoReply::Policy(val) => fmt.field("Policy", &val),
                OpDestroysetDoReply::Desc(val) => fmt.field("Desc", &val),
                OpDestroysetDoReply::Id(val) => fmt.field("Id", &val),
                OpDestroysetDoReply::Timeout(val) => fmt.field("Timeout", &val),
                OpDestroysetDoReply::GcInterval(val) => fmt.field("GcInterval", &val),
                OpDestroysetDoReply::Userdata(val) => fmt.field("Userdata", &val),
                OpDestroysetDoReply::Pad(val) => fmt.field("Pad", &val),
                OpDestroysetDoReply::ObjType(val) => fmt.field("ObjType", &val),
                OpDestroysetDoReply::Handle(val) => fmt.field("Handle", &val),
                OpDestroysetDoReply::Expr(val) => fmt.field("Expr", &val),
                OpDestroysetDoReply::Expressions(val) => fmt.field("Expressions", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpDestroysetDoReply<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpDestroysetDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDestroysetDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpDestroysetDoReply::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpDestroysetDoReply::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpDestroysetDoReply::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                OpDestroysetDoReply::KeyType(val) => {
                    if last_off == offset {
                        stack.push(("KeyType", last_off));
                        break;
                    }
                }
                OpDestroysetDoReply::KeyLen(val) => {
                    if last_off == offset {
                        stack.push(("KeyLen", last_off));
                        break;
                    }
                }
                OpDestroysetDoReply::DataType(val) => {
                    if last_off == offset {
                        stack.push(("DataType", last_off));
                        break;
                    }
                }
                OpDestroysetDoReply::DataLen(val) => {
                    if last_off == offset {
                        stack.push(("DataLen", last_off));
                        break;
                    }
                }
                OpDestroysetDoReply::Policy(val) => {
                    if last_off == offset {
                        stack.push(("Policy", last_off));
                        break;
                    }
                }
                OpDestroysetDoReply::Desc(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpDestroysetDoReply::Id(val) => {
                    if last_off == offset {
                        stack.push(("Id", last_off));
                        break;
                    }
                }
                OpDestroysetDoReply::Timeout(val) => {
                    if last_off == offset {
                        stack.push(("Timeout", last_off));
                        break;
                    }
                }
                OpDestroysetDoReply::GcInterval(val) => {
                    if last_off == offset {
                        stack.push(("GcInterval", last_off));
                        break;
                    }
                }
                OpDestroysetDoReply::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                OpDestroysetDoReply::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                OpDestroysetDoReply::ObjType(val) => {
                    if last_off == offset {
                        stack.push(("ObjType", last_off));
                        break;
                    }
                }
                OpDestroysetDoReply::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpDestroysetDoReply::Expr(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpDestroysetDoReply::Expressions(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpDestroysetDoReply", cur));
        }
        (stack, missing)
    }
}
#[derive(Debug)]
pub struct RequestOpDestroysetDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpDestroysetDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpDestroysetDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpDestroysetDoRequest<&mut Vec<u8>> {
        PushOpDestroysetDoRequest::new_without_header(self.request.buf_mut())
    }
}
impl NetlinkRequest for RequestOpDestroysetDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, Iterable<'buf, OpDestroysetDoReply<'buf>>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2589u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpDestroysetDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpDestroysetDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Create a new set element."]
pub struct PushOpNewsetelemDoRequest<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpNewsetelemDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpNewsetelemDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_set(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_set_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn nested_elements(mut self) -> PushSetelemListElemAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 3u16);
        PushSetelemListElemAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_set_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpNewsetelemDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Create a new set element."]
#[doc = "Original name: \"op-newsetelem-do-request\""]
#[derive(Clone)]
pub enum OpNewsetelemDoRequest<'a> {
    Table(&'a CStr),
    Set(&'a CStr),
    Elements(Iterable<'a, SetelemListElemAttrs<'a>>),
    SetId(u32),
}
impl<'a> Iterable<'a, OpNewsetelemDoRequest<'a>> {
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewsetelemDoRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewsetelemDoRequest", "Table"))
    }
    pub fn get_set(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewsetelemDoRequest::Set(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewsetelemDoRequest", "Set"))
    }
    pub fn get_elements(&self) -> Result<Iterable<'a, SetelemListElemAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewsetelemDoRequest::Elements(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewsetelemDoRequest", "Elements"))
    }
    pub fn get_set_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewsetelemDoRequest::SetId(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewsetelemDoRequest", "SetId"))
    }
}
impl<'a> OpNewsetelemDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpNewsetelemDoRequest<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        SetelemListAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpNewsetelemDoRequest<'a>> {
    type Item = Result<OpNewsetelemDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpNewsetelemDoRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpNewsetelemDoRequest::Set({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpNewsetelemDoRequest::Elements({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpNewsetelemDoRequest::SetId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpNewsetelemDoRequest",
            r#type.and_then(|t| OpNewsetelemDoRequest::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpNewsetelemDoRequest<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpNewsetelemDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpNewsetelemDoRequest::Table(val) => fmt.field("Table", &val),
                OpNewsetelemDoRequest::Set(val) => fmt.field("Set", &val),
                OpNewsetelemDoRequest::Elements(val) => fmt.field("Elements", &val),
                OpNewsetelemDoRequest::SetId(val) => fmt.field("SetId", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpNewsetelemDoRequest<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpNewsetelemDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpNewsetelemDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpNewsetelemDoRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpNewsetelemDoRequest::Set(val) => {
                    if last_off == offset {
                        stack.push(("Set", last_off));
                        break;
                    }
                }
                OpNewsetelemDoRequest::Elements(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpNewsetelemDoRequest::SetId(val) => {
                    if last_off == offset {
                        stack.push(("SetId", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpNewsetelemDoRequest", cur));
        }
        (stack, missing)
    }
}
#[doc = "Create a new set element."]
pub struct PushOpNewsetelemDoReply<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpNewsetelemDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpNewsetelemDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_set(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_set_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn nested_elements(mut self) -> PushSetelemListElemAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 3u16);
        PushSetelemListElemAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_set_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpNewsetelemDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Create a new set element."]
#[doc = "Original name: \"op-newsetelem-do-reply\""]
#[derive(Clone)]
pub enum OpNewsetelemDoReply<'a> {
    Table(&'a CStr),
    Set(&'a CStr),
    Elements(Iterable<'a, SetelemListElemAttrs<'a>>),
    SetId(u32),
}
impl<'a> Iterable<'a, OpNewsetelemDoReply<'a>> {
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewsetelemDoReply::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewsetelemDoReply", "Table"))
    }
    pub fn get_set(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewsetelemDoReply::Set(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewsetelemDoReply", "Set"))
    }
    pub fn get_elements(&self) -> Result<Iterable<'a, SetelemListElemAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewsetelemDoReply::Elements(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewsetelemDoReply", "Elements"))
    }
    pub fn get_set_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewsetelemDoReply::SetId(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewsetelemDoReply", "SetId"))
    }
}
impl<'a> OpNewsetelemDoReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpNewsetelemDoReply<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        SetelemListAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpNewsetelemDoReply<'a>> {
    type Item = Result<OpNewsetelemDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpNewsetelemDoReply::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpNewsetelemDoReply::Set({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpNewsetelemDoReply::Elements({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpNewsetelemDoReply::SetId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpNewsetelemDoReply",
            r#type.and_then(|t| OpNewsetelemDoReply::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpNewsetelemDoReply<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpNewsetelemDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpNewsetelemDoReply::Table(val) => fmt.field("Table", &val),
                OpNewsetelemDoReply::Set(val) => fmt.field("Set", &val),
                OpNewsetelemDoReply::Elements(val) => fmt.field("Elements", &val),
                OpNewsetelemDoReply::SetId(val) => fmt.field("SetId", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpNewsetelemDoReply<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpNewsetelemDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpNewsetelemDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpNewsetelemDoReply::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpNewsetelemDoReply::Set(val) => {
                    if last_off == offset {
                        stack.push(("Set", last_off));
                        break;
                    }
                }
                OpNewsetelemDoReply::Elements(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpNewsetelemDoReply::SetId(val) => {
                    if last_off == offset {
                        stack.push(("SetId", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpNewsetelemDoReply", cur));
        }
        (stack, missing)
    }
}
#[derive(Debug)]
pub struct RequestOpNewsetelemDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpNewsetelemDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpNewsetelemDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpNewsetelemDoRequest<&mut Vec<u8>> {
        PushOpNewsetelemDoRequest::new_without_header(self.request.buf_mut())
    }
}
impl NetlinkRequest for RequestOpNewsetelemDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, Iterable<'buf, OpNewsetelemDoReply<'buf>>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2572u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpNewsetelemDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpNewsetelemDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Get / dump set elements."]
pub struct PushOpGetsetelemDumpRequest<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetsetelemDumpRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetsetelemDumpRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_set(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_set_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn nested_elements(mut self) -> PushSetelemListElemAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 3u16);
        PushSetelemListElemAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_set_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetsetelemDumpRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump set elements."]
#[doc = "Original name: \"op-getsetelem-dump-request\""]
#[derive(Clone)]
pub enum OpGetsetelemDumpRequest<'a> {
    Table(&'a CStr),
    Set(&'a CStr),
    Elements(Iterable<'a, SetelemListElemAttrs<'a>>),
    SetId(u32),
}
impl<'a> Iterable<'a, OpGetsetelemDumpRequest<'a>> {
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetelemDumpRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetelemDumpRequest", "Table"))
    }
    pub fn get_set(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetelemDumpRequest::Set(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetelemDumpRequest", "Set"))
    }
    pub fn get_elements(&self) -> Result<Iterable<'a, SetelemListElemAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetelemDumpRequest::Elements(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetelemDumpRequest", "Elements"))
    }
    pub fn get_set_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetelemDumpRequest::SetId(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetelemDumpRequest", "SetId"))
    }
}
impl<'a> OpGetsetelemDumpRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpGetsetelemDumpRequest<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        SetelemListAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpGetsetelemDumpRequest<'a>> {
    type Item = Result<OpGetsetelemDumpRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetsetelemDumpRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetsetelemDumpRequest::Set({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetsetelemDumpRequest::Elements({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpGetsetelemDumpRequest::SetId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpGetsetelemDumpRequest",
            r#type.and_then(|t| OpGetsetelemDumpRequest::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpGetsetelemDumpRequest<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetsetelemDumpRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetsetelemDumpRequest::Table(val) => fmt.field("Table", &val),
                OpGetsetelemDumpRequest::Set(val) => fmt.field("Set", &val),
                OpGetsetelemDumpRequest::Elements(val) => fmt.field("Elements", &val),
                OpGetsetelemDumpRequest::SetId(val) => fmt.field("SetId", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpGetsetelemDumpRequest<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetsetelemDumpRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetsetelemDumpRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetsetelemDumpRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpGetsetelemDumpRequest::Set(val) => {
                    if last_off == offset {
                        stack.push(("Set", last_off));
                        break;
                    }
                }
                OpGetsetelemDumpRequest::Elements(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetsetelemDumpRequest::SetId(val) => {
                    if last_off == offset {
                        stack.push(("SetId", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetsetelemDumpRequest", cur));
        }
        (stack, missing)
    }
}
#[doc = "Get / dump set elements."]
pub struct PushOpGetsetelemDumpReply<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetsetelemDumpReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetsetelemDumpReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_set(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_set_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn nested_elements(mut self) -> PushSetelemListElemAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 3u16);
        PushSetelemListElemAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_set_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetsetelemDumpReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump set elements."]
#[doc = "Original name: \"op-getsetelem-dump-reply\""]
#[derive(Clone)]
pub enum OpGetsetelemDumpReply<'a> {
    Table(&'a CStr),
    Set(&'a CStr),
    Elements(Iterable<'a, SetelemListElemAttrs<'a>>),
    SetId(u32),
}
impl<'a> Iterable<'a, OpGetsetelemDumpReply<'a>> {
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetelemDumpReply::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetelemDumpReply", "Table"))
    }
    pub fn get_set(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetelemDumpReply::Set(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetelemDumpReply", "Set"))
    }
    pub fn get_elements(&self) -> Result<Iterable<'a, SetelemListElemAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetelemDumpReply::Elements(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetelemDumpReply", "Elements"))
    }
    pub fn get_set_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetelemDumpReply::SetId(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetelemDumpReply", "SetId"))
    }
}
impl<'a> OpGetsetelemDumpReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpGetsetelemDumpReply<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        SetelemListAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpGetsetelemDumpReply<'a>> {
    type Item = Result<OpGetsetelemDumpReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetsetelemDumpReply::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetsetelemDumpReply::Set({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetsetelemDumpReply::Elements({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpGetsetelemDumpReply::SetId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpGetsetelemDumpReply",
            r#type.and_then(|t| OpGetsetelemDumpReply::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpGetsetelemDumpReply<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetsetelemDumpReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetsetelemDumpReply::Table(val) => fmt.field("Table", &val),
                OpGetsetelemDumpReply::Set(val) => fmt.field("Set", &val),
                OpGetsetelemDumpReply::Elements(val) => fmt.field("Elements", &val),
                OpGetsetelemDumpReply::SetId(val) => fmt.field("SetId", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpGetsetelemDumpReply<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetsetelemDumpReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetsetelemDumpReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetsetelemDumpReply::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpGetsetelemDumpReply::Set(val) => {
                    if last_off == offset {
                        stack.push(("Set", last_off));
                        break;
                    }
                }
                OpGetsetelemDumpReply::Elements(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetsetelemDumpReply::SetId(val) => {
                    if last_off == offset {
                        stack.push(("SetId", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetsetelemDumpReply", cur));
        }
        (stack, missing)
    }
}
#[derive(Debug)]
pub struct RequestOpGetsetelemDumpRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpGetsetelemDumpRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpGetsetelemDumpRequest::write_header(&mut request.buf_mut(), header);
        Self {
            request: request.set_dump(),
        }
    }
    pub fn encode(&mut self) -> PushOpGetsetelemDumpRequest<&mut Vec<u8>> {
        PushOpGetsetelemDumpRequest::new_without_header(self.request.buf_mut())
    }
}
impl NetlinkRequest for RequestOpGetsetelemDumpRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, Iterable<'buf, OpGetsetelemDumpReply<'buf>>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2573u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpGetsetelemDumpReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpGetsetelemDumpRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Get / dump set elements."]
pub struct PushOpGetsetelemDoRequest<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetsetelemDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetsetelemDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_set(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_set_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn nested_elements(mut self) -> PushSetelemListElemAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 3u16);
        PushSetelemListElemAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_set_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetsetelemDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump set elements."]
#[doc = "Original name: \"op-getsetelem-do-request\""]
#[derive(Clone)]
pub enum OpGetsetelemDoRequest<'a> {
    Table(&'a CStr),
    Set(&'a CStr),
    Elements(Iterable<'a, SetelemListElemAttrs<'a>>),
    SetId(u32),
}
impl<'a> Iterable<'a, OpGetsetelemDoRequest<'a>> {
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetelemDoRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetelemDoRequest", "Table"))
    }
    pub fn get_set(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetelemDoRequest::Set(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetelemDoRequest", "Set"))
    }
    pub fn get_elements(&self) -> Result<Iterable<'a, SetelemListElemAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetelemDoRequest::Elements(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetelemDoRequest", "Elements"))
    }
    pub fn get_set_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetelemDoRequest::SetId(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetelemDoRequest", "SetId"))
    }
}
impl<'a> OpGetsetelemDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpGetsetelemDoRequest<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        SetelemListAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpGetsetelemDoRequest<'a>> {
    type Item = Result<OpGetsetelemDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetsetelemDoRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetsetelemDoRequest::Set({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetsetelemDoRequest::Elements({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpGetsetelemDoRequest::SetId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpGetsetelemDoRequest",
            r#type.and_then(|t| OpGetsetelemDoRequest::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpGetsetelemDoRequest<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetsetelemDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetsetelemDoRequest::Table(val) => fmt.field("Table", &val),
                OpGetsetelemDoRequest::Set(val) => fmt.field("Set", &val),
                OpGetsetelemDoRequest::Elements(val) => fmt.field("Elements", &val),
                OpGetsetelemDoRequest::SetId(val) => fmt.field("SetId", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpGetsetelemDoRequest<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetsetelemDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetsetelemDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetsetelemDoRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpGetsetelemDoRequest::Set(val) => {
                    if last_off == offset {
                        stack.push(("Set", last_off));
                        break;
                    }
                }
                OpGetsetelemDoRequest::Elements(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetsetelemDoRequest::SetId(val) => {
                    if last_off == offset {
                        stack.push(("SetId", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetsetelemDoRequest", cur));
        }
        (stack, missing)
    }
}
#[doc = "Get / dump set elements."]
pub struct PushOpGetsetelemDoReply<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetsetelemDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetsetelemDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_set(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_set_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn nested_elements(mut self) -> PushSetelemListElemAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 3u16);
        PushSetelemListElemAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_set_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetsetelemDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump set elements."]
#[doc = "Original name: \"op-getsetelem-do-reply\""]
#[derive(Clone)]
pub enum OpGetsetelemDoReply<'a> {
    Table(&'a CStr),
    Set(&'a CStr),
    Elements(Iterable<'a, SetelemListElemAttrs<'a>>),
    SetId(u32),
}
impl<'a> Iterable<'a, OpGetsetelemDoReply<'a>> {
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetelemDoReply::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetelemDoReply", "Table"))
    }
    pub fn get_set(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetelemDoReply::Set(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetelemDoReply", "Set"))
    }
    pub fn get_elements(&self) -> Result<Iterable<'a, SetelemListElemAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetelemDoReply::Elements(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetelemDoReply", "Elements"))
    }
    pub fn get_set_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetelemDoReply::SetId(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetelemDoReply", "SetId"))
    }
}
impl<'a> OpGetsetelemDoReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpGetsetelemDoReply<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        SetelemListAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpGetsetelemDoReply<'a>> {
    type Item = Result<OpGetsetelemDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetsetelemDoReply::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetsetelemDoReply::Set({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetsetelemDoReply::Elements({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpGetsetelemDoReply::SetId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpGetsetelemDoReply",
            r#type.and_then(|t| OpGetsetelemDoReply::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpGetsetelemDoReply<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetsetelemDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetsetelemDoReply::Table(val) => fmt.field("Table", &val),
                OpGetsetelemDoReply::Set(val) => fmt.field("Set", &val),
                OpGetsetelemDoReply::Elements(val) => fmt.field("Elements", &val),
                OpGetsetelemDoReply::SetId(val) => fmt.field("SetId", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpGetsetelemDoReply<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetsetelemDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetsetelemDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetsetelemDoReply::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpGetsetelemDoReply::Set(val) => {
                    if last_off == offset {
                        stack.push(("Set", last_off));
                        break;
                    }
                }
                OpGetsetelemDoReply::Elements(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetsetelemDoReply::SetId(val) => {
                    if last_off == offset {
                        stack.push(("SetId", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetsetelemDoReply", cur));
        }
        (stack, missing)
    }
}
#[derive(Debug)]
pub struct RequestOpGetsetelemDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpGetsetelemDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpGetsetelemDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpGetsetelemDoRequest<&mut Vec<u8>> {
        PushOpGetsetelemDoRequest::new_without_header(self.request.buf_mut())
    }
}
impl NetlinkRequest for RequestOpGetsetelemDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, Iterable<'buf, OpGetsetelemDoReply<'buf>>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2573u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpGetsetelemDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpGetsetelemDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Get / dump set elements and reset stateful expressions."]
pub struct PushOpGetsetelemResetDumpRequest<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetsetelemResetDumpRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetsetelemResetDumpRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_set(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_set_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn nested_elements(mut self) -> PushSetelemListElemAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 3u16);
        PushSetelemListElemAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_set_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetsetelemResetDumpRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump set elements and reset stateful expressions."]
#[doc = "Original name: \"op-getsetelem-reset-dump-request\""]
#[derive(Clone)]
pub enum OpGetsetelemResetDumpRequest<'a> {
    Table(&'a CStr),
    Set(&'a CStr),
    Elements(Iterable<'a, SetelemListElemAttrs<'a>>),
    SetId(u32),
}
impl<'a> Iterable<'a, OpGetsetelemResetDumpRequest<'a>> {
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetelemResetDumpRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetelemResetDumpRequest", "Table"))
    }
    pub fn get_set(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetelemResetDumpRequest::Set(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetelemResetDumpRequest", "Set"))
    }
    pub fn get_elements(&self) -> Result<Iterable<'a, SetelemListElemAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetelemResetDumpRequest::Elements(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetelemResetDumpRequest", "Elements"))
    }
    pub fn get_set_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetelemResetDumpRequest::SetId(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetelemResetDumpRequest", "SetId"))
    }
}
impl<'a> OpGetsetelemResetDumpRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpGetsetelemResetDumpRequest<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        SetelemListAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpGetsetelemResetDumpRequest<'a>> {
    type Item = Result<OpGetsetelemResetDumpRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetsetelemResetDumpRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetsetelemResetDumpRequest::Set({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetsetelemResetDumpRequest::Elements({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpGetsetelemResetDumpRequest::SetId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpGetsetelemResetDumpRequest",
            r#type.and_then(|t| OpGetsetelemResetDumpRequest::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpGetsetelemResetDumpRequest<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetsetelemResetDumpRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetsetelemResetDumpRequest::Table(val) => fmt.field("Table", &val),
                OpGetsetelemResetDumpRequest::Set(val) => fmt.field("Set", &val),
                OpGetsetelemResetDumpRequest::Elements(val) => fmt.field("Elements", &val),
                OpGetsetelemResetDumpRequest::SetId(val) => fmt.field("SetId", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpGetsetelemResetDumpRequest<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetsetelemResetDumpRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetsetelemResetDumpRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetsetelemResetDumpRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpGetsetelemResetDumpRequest::Set(val) => {
                    if last_off == offset {
                        stack.push(("Set", last_off));
                        break;
                    }
                }
                OpGetsetelemResetDumpRequest::Elements(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetsetelemResetDumpRequest::SetId(val) => {
                    if last_off == offset {
                        stack.push(("SetId", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetsetelemResetDumpRequest", cur));
        }
        (stack, missing)
    }
}
#[doc = "Get / dump set elements and reset stateful expressions."]
pub struct PushOpGetsetelemResetDumpReply<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetsetelemResetDumpReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetsetelemResetDumpReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_set(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_set_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn nested_elements(mut self) -> PushSetelemListElemAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 3u16);
        PushSetelemListElemAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_set_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetsetelemResetDumpReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump set elements and reset stateful expressions."]
#[doc = "Original name: \"op-getsetelem-reset-dump-reply\""]
#[derive(Clone)]
pub enum OpGetsetelemResetDumpReply<'a> {
    Table(&'a CStr),
    Set(&'a CStr),
    Elements(Iterable<'a, SetelemListElemAttrs<'a>>),
    SetId(u32),
}
impl<'a> Iterable<'a, OpGetsetelemResetDumpReply<'a>> {
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetelemResetDumpReply::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetelemResetDumpReply", "Table"))
    }
    pub fn get_set(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetelemResetDumpReply::Set(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetelemResetDumpReply", "Set"))
    }
    pub fn get_elements(&self) -> Result<Iterable<'a, SetelemListElemAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetelemResetDumpReply::Elements(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetelemResetDumpReply", "Elements"))
    }
    pub fn get_set_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetelemResetDumpReply::SetId(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetelemResetDumpReply", "SetId"))
    }
}
impl<'a> OpGetsetelemResetDumpReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpGetsetelemResetDumpReply<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        SetelemListAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpGetsetelemResetDumpReply<'a>> {
    type Item = Result<OpGetsetelemResetDumpReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetsetelemResetDumpReply::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetsetelemResetDumpReply::Set({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetsetelemResetDumpReply::Elements({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpGetsetelemResetDumpReply::SetId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpGetsetelemResetDumpReply",
            r#type.and_then(|t| OpGetsetelemResetDumpReply::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpGetsetelemResetDumpReply<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetsetelemResetDumpReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetsetelemResetDumpReply::Table(val) => fmt.field("Table", &val),
                OpGetsetelemResetDumpReply::Set(val) => fmt.field("Set", &val),
                OpGetsetelemResetDumpReply::Elements(val) => fmt.field("Elements", &val),
                OpGetsetelemResetDumpReply::SetId(val) => fmt.field("SetId", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpGetsetelemResetDumpReply<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetsetelemResetDumpReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetsetelemResetDumpReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetsetelemResetDumpReply::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpGetsetelemResetDumpReply::Set(val) => {
                    if last_off == offset {
                        stack.push(("Set", last_off));
                        break;
                    }
                }
                OpGetsetelemResetDumpReply::Elements(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetsetelemResetDumpReply::SetId(val) => {
                    if last_off == offset {
                        stack.push(("SetId", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetsetelemResetDumpReply", cur));
        }
        (stack, missing)
    }
}
#[derive(Debug)]
pub struct RequestOpGetsetelemResetDumpRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpGetsetelemResetDumpRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpGetsetelemResetDumpRequest::write_header(&mut request.buf_mut(), header);
        Self {
            request: request.set_dump(),
        }
    }
    pub fn encode(&mut self) -> PushOpGetsetelemResetDumpRequest<&mut Vec<u8>> {
        PushOpGetsetelemResetDumpRequest::new_without_header(self.request.buf_mut())
    }
}
impl NetlinkRequest for RequestOpGetsetelemResetDumpRequest<'_> {
    type ReplyType<'buf> = (
        PushNfgenmsg,
        Iterable<'buf, OpGetsetelemResetDumpReply<'buf>>,
    );
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2593u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpGetsetelemResetDumpReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpGetsetelemResetDumpRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Get / dump set elements and reset stateful expressions."]
pub struct PushOpGetsetelemResetDoRequest<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetsetelemResetDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetsetelemResetDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_set(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_set_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn nested_elements(mut self) -> PushSetelemListElemAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 3u16);
        PushSetelemListElemAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_set_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetsetelemResetDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump set elements and reset stateful expressions."]
#[doc = "Original name: \"op-getsetelem-reset-do-request\""]
#[derive(Clone)]
pub enum OpGetsetelemResetDoRequest<'a> {
    Table(&'a CStr),
    Set(&'a CStr),
    Elements(Iterable<'a, SetelemListElemAttrs<'a>>),
    SetId(u32),
}
impl<'a> Iterable<'a, OpGetsetelemResetDoRequest<'a>> {
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetelemResetDoRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetelemResetDoRequest", "Table"))
    }
    pub fn get_set(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetelemResetDoRequest::Set(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetelemResetDoRequest", "Set"))
    }
    pub fn get_elements(&self) -> Result<Iterable<'a, SetelemListElemAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetelemResetDoRequest::Elements(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetelemResetDoRequest", "Elements"))
    }
    pub fn get_set_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetelemResetDoRequest::SetId(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetelemResetDoRequest", "SetId"))
    }
}
impl<'a> OpGetsetelemResetDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpGetsetelemResetDoRequest<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        SetelemListAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpGetsetelemResetDoRequest<'a>> {
    type Item = Result<OpGetsetelemResetDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetsetelemResetDoRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetsetelemResetDoRequest::Set({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetsetelemResetDoRequest::Elements({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpGetsetelemResetDoRequest::SetId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpGetsetelemResetDoRequest",
            r#type.and_then(|t| OpGetsetelemResetDoRequest::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpGetsetelemResetDoRequest<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetsetelemResetDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetsetelemResetDoRequest::Table(val) => fmt.field("Table", &val),
                OpGetsetelemResetDoRequest::Set(val) => fmt.field("Set", &val),
                OpGetsetelemResetDoRequest::Elements(val) => fmt.field("Elements", &val),
                OpGetsetelemResetDoRequest::SetId(val) => fmt.field("SetId", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpGetsetelemResetDoRequest<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetsetelemResetDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetsetelemResetDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetsetelemResetDoRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpGetsetelemResetDoRequest::Set(val) => {
                    if last_off == offset {
                        stack.push(("Set", last_off));
                        break;
                    }
                }
                OpGetsetelemResetDoRequest::Elements(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetsetelemResetDoRequest::SetId(val) => {
                    if last_off == offset {
                        stack.push(("SetId", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetsetelemResetDoRequest", cur));
        }
        (stack, missing)
    }
}
#[doc = "Get / dump set elements and reset stateful expressions."]
pub struct PushOpGetsetelemResetDoReply<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetsetelemResetDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetsetelemResetDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_set(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_set_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn nested_elements(mut self) -> PushSetelemListElemAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 3u16);
        PushSetelemListElemAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_set_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetsetelemResetDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump set elements and reset stateful expressions."]
#[doc = "Original name: \"op-getsetelem-reset-do-reply\""]
#[derive(Clone)]
pub enum OpGetsetelemResetDoReply<'a> {
    Table(&'a CStr),
    Set(&'a CStr),
    Elements(Iterable<'a, SetelemListElemAttrs<'a>>),
    SetId(u32),
}
impl<'a> Iterable<'a, OpGetsetelemResetDoReply<'a>> {
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetelemResetDoReply::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetelemResetDoReply", "Table"))
    }
    pub fn get_set(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetelemResetDoReply::Set(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetelemResetDoReply", "Set"))
    }
    pub fn get_elements(&self) -> Result<Iterable<'a, SetelemListElemAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetelemResetDoReply::Elements(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetelemResetDoReply", "Elements"))
    }
    pub fn get_set_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetelemResetDoReply::SetId(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetsetelemResetDoReply", "SetId"))
    }
}
impl<'a> OpGetsetelemResetDoReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpGetsetelemResetDoReply<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        SetelemListAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpGetsetelemResetDoReply<'a>> {
    type Item = Result<OpGetsetelemResetDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetsetelemResetDoReply::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetsetelemResetDoReply::Set({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetsetelemResetDoReply::Elements({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpGetsetelemResetDoReply::SetId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpGetsetelemResetDoReply",
            r#type.and_then(|t| OpGetsetelemResetDoReply::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpGetsetelemResetDoReply<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetsetelemResetDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetsetelemResetDoReply::Table(val) => fmt.field("Table", &val),
                OpGetsetelemResetDoReply::Set(val) => fmt.field("Set", &val),
                OpGetsetelemResetDoReply::Elements(val) => fmt.field("Elements", &val),
                OpGetsetelemResetDoReply::SetId(val) => fmt.field("SetId", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpGetsetelemResetDoReply<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetsetelemResetDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetsetelemResetDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetsetelemResetDoReply::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpGetsetelemResetDoReply::Set(val) => {
                    if last_off == offset {
                        stack.push(("Set", last_off));
                        break;
                    }
                }
                OpGetsetelemResetDoReply::Elements(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetsetelemResetDoReply::SetId(val) => {
                    if last_off == offset {
                        stack.push(("SetId", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetsetelemResetDoReply", cur));
        }
        (stack, missing)
    }
}
#[derive(Debug)]
pub struct RequestOpGetsetelemResetDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpGetsetelemResetDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpGetsetelemResetDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpGetsetelemResetDoRequest<&mut Vec<u8>> {
        PushOpGetsetelemResetDoRequest::new_without_header(self.request.buf_mut())
    }
}
impl NetlinkRequest for RequestOpGetsetelemResetDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, Iterable<'buf, OpGetsetelemResetDoReply<'buf>>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2593u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpGetsetelemResetDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpGetsetelemResetDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Delete an existing set element."]
pub struct PushOpDelsetelemDoRequest<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDelsetelemDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDelsetelemDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_set(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_set_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn nested_elements(mut self) -> PushSetelemListElemAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 3u16);
        PushSetelemListElemAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_set_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpDelsetelemDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete an existing set element."]
#[doc = "Original name: \"op-delsetelem-do-request\""]
#[derive(Clone)]
pub enum OpDelsetelemDoRequest<'a> {
    Table(&'a CStr),
    Set(&'a CStr),
    Elements(Iterable<'a, SetelemListElemAttrs<'a>>),
    SetId(u32),
}
impl<'a> Iterable<'a, OpDelsetelemDoRequest<'a>> {
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelsetelemDoRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelsetelemDoRequest", "Table"))
    }
    pub fn get_set(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelsetelemDoRequest::Set(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelsetelemDoRequest", "Set"))
    }
    pub fn get_elements(&self) -> Result<Iterable<'a, SetelemListElemAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelsetelemDoRequest::Elements(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelsetelemDoRequest", "Elements"))
    }
    pub fn get_set_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelsetelemDoRequest::SetId(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelsetelemDoRequest", "SetId"))
    }
}
impl<'a> OpDelsetelemDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpDelsetelemDoRequest<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        SetelemListAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpDelsetelemDoRequest<'a>> {
    type Item = Result<OpDelsetelemDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpDelsetelemDoRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpDelsetelemDoRequest::Set({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpDelsetelemDoRequest::Elements({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpDelsetelemDoRequest::SetId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpDelsetelemDoRequest",
            r#type.and_then(|t| OpDelsetelemDoRequest::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpDelsetelemDoRequest<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDelsetelemDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpDelsetelemDoRequest::Table(val) => fmt.field("Table", &val),
                OpDelsetelemDoRequest::Set(val) => fmt.field("Set", &val),
                OpDelsetelemDoRequest::Elements(val) => fmt.field("Elements", &val),
                OpDelsetelemDoRequest::SetId(val) => fmt.field("SetId", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpDelsetelemDoRequest<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpDelsetelemDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDelsetelemDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpDelsetelemDoRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpDelsetelemDoRequest::Set(val) => {
                    if last_off == offset {
                        stack.push(("Set", last_off));
                        break;
                    }
                }
                OpDelsetelemDoRequest::Elements(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpDelsetelemDoRequest::SetId(val) => {
                    if last_off == offset {
                        stack.push(("SetId", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpDelsetelemDoRequest", cur));
        }
        (stack, missing)
    }
}
#[doc = "Delete an existing set element."]
pub struct PushOpDelsetelemDoReply<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDelsetelemDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDelsetelemDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_set(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_set_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn nested_elements(mut self) -> PushSetelemListElemAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 3u16);
        PushSetelemListElemAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_set_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpDelsetelemDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete an existing set element."]
#[doc = "Original name: \"op-delsetelem-do-reply\""]
#[derive(Clone)]
pub enum OpDelsetelemDoReply<'a> {
    Table(&'a CStr),
    Set(&'a CStr),
    Elements(Iterable<'a, SetelemListElemAttrs<'a>>),
    SetId(u32),
}
impl<'a> Iterable<'a, OpDelsetelemDoReply<'a>> {
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelsetelemDoReply::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelsetelemDoReply", "Table"))
    }
    pub fn get_set(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelsetelemDoReply::Set(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelsetelemDoReply", "Set"))
    }
    pub fn get_elements(&self) -> Result<Iterable<'a, SetelemListElemAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelsetelemDoReply::Elements(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelsetelemDoReply", "Elements"))
    }
    pub fn get_set_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelsetelemDoReply::SetId(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelsetelemDoReply", "SetId"))
    }
}
impl<'a> OpDelsetelemDoReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpDelsetelemDoReply<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        SetelemListAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpDelsetelemDoReply<'a>> {
    type Item = Result<OpDelsetelemDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpDelsetelemDoReply::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpDelsetelemDoReply::Set({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpDelsetelemDoReply::Elements({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpDelsetelemDoReply::SetId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpDelsetelemDoReply",
            r#type.and_then(|t| OpDelsetelemDoReply::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpDelsetelemDoReply<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDelsetelemDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpDelsetelemDoReply::Table(val) => fmt.field("Table", &val),
                OpDelsetelemDoReply::Set(val) => fmt.field("Set", &val),
                OpDelsetelemDoReply::Elements(val) => fmt.field("Elements", &val),
                OpDelsetelemDoReply::SetId(val) => fmt.field("SetId", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpDelsetelemDoReply<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpDelsetelemDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDelsetelemDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpDelsetelemDoReply::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpDelsetelemDoReply::Set(val) => {
                    if last_off == offset {
                        stack.push(("Set", last_off));
                        break;
                    }
                }
                OpDelsetelemDoReply::Elements(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpDelsetelemDoReply::SetId(val) => {
                    if last_off == offset {
                        stack.push(("SetId", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpDelsetelemDoReply", cur));
        }
        (stack, missing)
    }
}
#[derive(Debug)]
pub struct RequestOpDelsetelemDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpDelsetelemDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpDelsetelemDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpDelsetelemDoRequest<&mut Vec<u8>> {
        PushOpDelsetelemDoRequest::new_without_header(self.request.buf_mut())
    }
}
impl NetlinkRequest for RequestOpDelsetelemDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, Iterable<'buf, OpDelsetelemDoReply<'buf>>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2574u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpDelsetelemDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpDelsetelemDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Delete an existing set element with destroy semantics."]
pub struct PushOpDestroysetelemDoRequest<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDestroysetelemDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDestroysetelemDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_set(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_set_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn nested_elements(mut self) -> PushSetelemListElemAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 3u16);
        PushSetelemListElemAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_set_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpDestroysetelemDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete an existing set element with destroy semantics."]
#[doc = "Original name: \"op-destroysetelem-do-request\""]
#[derive(Clone)]
pub enum OpDestroysetelemDoRequest<'a> {
    Table(&'a CStr),
    Set(&'a CStr),
    Elements(Iterable<'a, SetelemListElemAttrs<'a>>),
    SetId(u32),
}
impl<'a> Iterable<'a, OpDestroysetelemDoRequest<'a>> {
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroysetelemDoRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroysetelemDoRequest", "Table"))
    }
    pub fn get_set(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroysetelemDoRequest::Set(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroysetelemDoRequest", "Set"))
    }
    pub fn get_elements(&self) -> Result<Iterable<'a, SetelemListElemAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroysetelemDoRequest::Elements(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroysetelemDoRequest", "Elements"))
    }
    pub fn get_set_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroysetelemDoRequest::SetId(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroysetelemDoRequest", "SetId"))
    }
}
impl<'a> OpDestroysetelemDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpDestroysetelemDoRequest<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        SetelemListAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpDestroysetelemDoRequest<'a>> {
    type Item = Result<OpDestroysetelemDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpDestroysetelemDoRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpDestroysetelemDoRequest::Set({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpDestroysetelemDoRequest::Elements({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpDestroysetelemDoRequest::SetId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpDestroysetelemDoRequest",
            r#type.and_then(|t| OpDestroysetelemDoRequest::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpDestroysetelemDoRequest<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDestroysetelemDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpDestroysetelemDoRequest::Table(val) => fmt.field("Table", &val),
                OpDestroysetelemDoRequest::Set(val) => fmt.field("Set", &val),
                OpDestroysetelemDoRequest::Elements(val) => fmt.field("Elements", &val),
                OpDestroysetelemDoRequest::SetId(val) => fmt.field("SetId", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpDestroysetelemDoRequest<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpDestroysetelemDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDestroysetelemDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpDestroysetelemDoRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpDestroysetelemDoRequest::Set(val) => {
                    if last_off == offset {
                        stack.push(("Set", last_off));
                        break;
                    }
                }
                OpDestroysetelemDoRequest::Elements(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpDestroysetelemDoRequest::SetId(val) => {
                    if last_off == offset {
                        stack.push(("SetId", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpDestroysetelemDoRequest", cur));
        }
        (stack, missing)
    }
}
#[doc = "Delete an existing set element with destroy semantics."]
pub struct PushOpDestroysetelemDoReply<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDestroysetelemDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDestroysetelemDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_set(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_set_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn nested_elements(mut self) -> PushSetelemListElemAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 3u16);
        PushSetelemListElemAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_set_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpDestroysetelemDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete an existing set element with destroy semantics."]
#[doc = "Original name: \"op-destroysetelem-do-reply\""]
#[derive(Clone)]
pub enum OpDestroysetelemDoReply<'a> {
    Table(&'a CStr),
    Set(&'a CStr),
    Elements(Iterable<'a, SetelemListElemAttrs<'a>>),
    SetId(u32),
}
impl<'a> Iterable<'a, OpDestroysetelemDoReply<'a>> {
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroysetelemDoReply::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroysetelemDoReply", "Table"))
    }
    pub fn get_set(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroysetelemDoReply::Set(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroysetelemDoReply", "Set"))
    }
    pub fn get_elements(&self) -> Result<Iterable<'a, SetelemListElemAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroysetelemDoReply::Elements(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroysetelemDoReply", "Elements"))
    }
    pub fn get_set_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroysetelemDoReply::SetId(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroysetelemDoReply", "SetId"))
    }
}
impl<'a> OpDestroysetelemDoReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpDestroysetelemDoReply<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        SetelemListAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpDestroysetelemDoReply<'a>> {
    type Item = Result<OpDestroysetelemDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpDestroysetelemDoReply::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpDestroysetelemDoReply::Set({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpDestroysetelemDoReply::Elements({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpDestroysetelemDoReply::SetId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpDestroysetelemDoReply",
            r#type.and_then(|t| OpDestroysetelemDoReply::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpDestroysetelemDoReply<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDestroysetelemDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpDestroysetelemDoReply::Table(val) => fmt.field("Table", &val),
                OpDestroysetelemDoReply::Set(val) => fmt.field("Set", &val),
                OpDestroysetelemDoReply::Elements(val) => fmt.field("Elements", &val),
                OpDestroysetelemDoReply::SetId(val) => fmt.field("SetId", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpDestroysetelemDoReply<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpDestroysetelemDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDestroysetelemDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpDestroysetelemDoReply::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpDestroysetelemDoReply::Set(val) => {
                    if last_off == offset {
                        stack.push(("Set", last_off));
                        break;
                    }
                }
                OpDestroysetelemDoReply::Elements(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpDestroysetelemDoReply::SetId(val) => {
                    if last_off == offset {
                        stack.push(("SetId", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpDestroysetelemDoReply", cur));
        }
        (stack, missing)
    }
}
#[derive(Debug)]
pub struct RequestOpDestroysetelemDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpDestroysetelemDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpDestroysetelemDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpDestroysetelemDoRequest<&mut Vec<u8>> {
        PushOpDestroysetelemDoRequest::new_without_header(self.request.buf_mut())
    }
}
impl NetlinkRequest for RequestOpDestroysetelemDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, Iterable<'buf, OpDestroysetelemDoReply<'buf>>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2590u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpDestroysetelemDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpDestroysetelemDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Get / dump rule-set generation."]
pub struct PushOpGetgenDumpRequest<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetgenDumpRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetgenDumpRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "ruleset generation id"]
    pub fn push_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_proc_pid(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_proc_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            3u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_proc_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 3u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetgenDumpRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump rule-set generation."]
#[doc = "Original name: \"op-getgen-dump-request\""]
#[derive(Clone)]
pub enum OpGetgenDumpRequest<'a> {
    #[doc = "ruleset generation id"]
    Id(u32),
    ProcPid(u32),
    ProcName(&'a CStr),
}
impl<'a> Iterable<'a, OpGetgenDumpRequest<'a>> {
    #[doc = "ruleset generation id"]
    pub fn get_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetgenDumpRequest::Id(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetgenDumpRequest", "Id"))
    }
    pub fn get_proc_pid(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetgenDumpRequest::ProcPid(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetgenDumpRequest", "ProcPid"))
    }
    pub fn get_proc_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetgenDumpRequest::ProcName(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetgenDumpRequest", "ProcName"))
    }
}
impl<'a> OpGetgenDumpRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpGetgenDumpRequest<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        GenAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpGetgenDumpRequest<'a>> {
    type Item = Result<OpGetgenDumpRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetgenDumpRequest::Id({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetgenDumpRequest::ProcPid({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetgenDumpRequest::ProcName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpGetgenDumpRequest",
            r#type.and_then(|t| OpGetgenDumpRequest::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpGetgenDumpRequest<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetgenDumpRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetgenDumpRequest::Id(val) => fmt.field("Id", &val),
                OpGetgenDumpRequest::ProcPid(val) => fmt.field("ProcPid", &val),
                OpGetgenDumpRequest::ProcName(val) => fmt.field("ProcName", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpGetgenDumpRequest<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetgenDumpRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetgenDumpRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetgenDumpRequest::Id(val) => {
                    if last_off == offset {
                        stack.push(("Id", last_off));
                        break;
                    }
                }
                OpGetgenDumpRequest::ProcPid(val) => {
                    if last_off == offset {
                        stack.push(("ProcPid", last_off));
                        break;
                    }
                }
                OpGetgenDumpRequest::ProcName(val) => {
                    if last_off == offset {
                        stack.push(("ProcName", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetgenDumpRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get / dump rule-set generation."]
pub struct PushOpGetgenDumpReply<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetgenDumpReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetgenDumpReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "ruleset generation id"]
    pub fn push_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_proc_pid(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_proc_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            3u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_proc_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 3u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetgenDumpReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump rule-set generation."]
#[doc = "Original name: \"op-getgen-dump-reply\""]
#[derive(Clone)]
pub enum OpGetgenDumpReply<'a> {
    #[doc = "ruleset generation id"]
    Id(u32),
    ProcPid(u32),
    ProcName(&'a CStr),
}
impl<'a> Iterable<'a, OpGetgenDumpReply<'a>> {
    #[doc = "ruleset generation id"]
    pub fn get_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetgenDumpReply::Id(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetgenDumpReply", "Id"))
    }
    pub fn get_proc_pid(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetgenDumpReply::ProcPid(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetgenDumpReply", "ProcPid"))
    }
    pub fn get_proc_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetgenDumpReply::ProcName(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetgenDumpReply", "ProcName"))
    }
}
impl<'a> OpGetgenDumpReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpGetgenDumpReply<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        GenAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpGetgenDumpReply<'a>> {
    type Item = Result<OpGetgenDumpReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetgenDumpReply::Id({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetgenDumpReply::ProcPid({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetgenDumpReply::ProcName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpGetgenDumpReply",
            r#type.and_then(|t| OpGetgenDumpReply::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpGetgenDumpReply<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetgenDumpReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetgenDumpReply::Id(val) => fmt.field("Id", &val),
                OpGetgenDumpReply::ProcPid(val) => fmt.field("ProcPid", &val),
                OpGetgenDumpReply::ProcName(val) => fmt.field("ProcName", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpGetgenDumpReply<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetgenDumpReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetgenDumpReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetgenDumpReply::Id(val) => {
                    if last_off == offset {
                        stack.push(("Id", last_off));
                        break;
                    }
                }
                OpGetgenDumpReply::ProcPid(val) => {
                    if last_off == offset {
                        stack.push(("ProcPid", last_off));
                        break;
                    }
                }
                OpGetgenDumpReply::ProcName(val) => {
                    if last_off == offset {
                        stack.push(("ProcName", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetgenDumpReply", cur));
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpGetgenDumpRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpGetgenDumpRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpGetgenDumpRequest::write_header(&mut request.buf_mut(), header);
        Self {
            request: request.set_dump(),
        }
    }
    pub fn encode(&mut self) -> PushOpGetgenDumpRequest<&mut Vec<u8>> {
        PushOpGetgenDumpRequest::new_without_header(self.request.buf_mut())
    }
}
impl NetlinkRequest for RequestOpGetgenDumpRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, Iterable<'buf, OpGetgenDumpReply<'buf>>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2576u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpGetgenDumpReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpGetgenDumpRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Get / dump rule-set generation."]
pub struct PushOpGetgenDoRequest<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetgenDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetgenDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "ruleset generation id"]
    pub fn push_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_proc_pid(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_proc_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            3u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_proc_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 3u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetgenDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump rule-set generation."]
#[doc = "Original name: \"op-getgen-do-request\""]
#[derive(Clone)]
pub enum OpGetgenDoRequest<'a> {
    #[doc = "ruleset generation id"]
    Id(u32),
    ProcPid(u32),
    ProcName(&'a CStr),
}
impl<'a> Iterable<'a, OpGetgenDoRequest<'a>> {
    #[doc = "ruleset generation id"]
    pub fn get_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetgenDoRequest::Id(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetgenDoRequest", "Id"))
    }
    pub fn get_proc_pid(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetgenDoRequest::ProcPid(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetgenDoRequest", "ProcPid"))
    }
    pub fn get_proc_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetgenDoRequest::ProcName(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetgenDoRequest", "ProcName"))
    }
}
impl<'a> OpGetgenDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpGetgenDoRequest<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        GenAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpGetgenDoRequest<'a>> {
    type Item = Result<OpGetgenDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetgenDoRequest::Id({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetgenDoRequest::ProcPid({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetgenDoRequest::ProcName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpGetgenDoRequest",
            r#type.and_then(|t| OpGetgenDoRequest::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpGetgenDoRequest<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetgenDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetgenDoRequest::Id(val) => fmt.field("Id", &val),
                OpGetgenDoRequest::ProcPid(val) => fmt.field("ProcPid", &val),
                OpGetgenDoRequest::ProcName(val) => fmt.field("ProcName", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpGetgenDoRequest<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetgenDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetgenDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetgenDoRequest::Id(val) => {
                    if last_off == offset {
                        stack.push(("Id", last_off));
                        break;
                    }
                }
                OpGetgenDoRequest::ProcPid(val) => {
                    if last_off == offset {
                        stack.push(("ProcPid", last_off));
                        break;
                    }
                }
                OpGetgenDoRequest::ProcName(val) => {
                    if last_off == offset {
                        stack.push(("ProcName", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetgenDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get / dump rule-set generation."]
pub struct PushOpGetgenDoReply<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetgenDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetgenDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "ruleset generation id"]
    pub fn push_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_proc_pid(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_proc_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            3u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_proc_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 3u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetgenDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump rule-set generation."]
#[doc = "Original name: \"op-getgen-do-reply\""]
#[derive(Clone)]
pub enum OpGetgenDoReply<'a> {
    #[doc = "ruleset generation id"]
    Id(u32),
    ProcPid(u32),
    ProcName(&'a CStr),
}
impl<'a> Iterable<'a, OpGetgenDoReply<'a>> {
    #[doc = "ruleset generation id"]
    pub fn get_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetgenDoReply::Id(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetgenDoReply", "Id"))
    }
    pub fn get_proc_pid(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetgenDoReply::ProcPid(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetgenDoReply", "ProcPid"))
    }
    pub fn get_proc_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetgenDoReply::ProcName(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetgenDoReply", "ProcName"))
    }
}
impl<'a> OpGetgenDoReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpGetgenDoReply<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        GenAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpGetgenDoReply<'a>> {
    type Item = Result<OpGetgenDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetgenDoReply::Id({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetgenDoReply::ProcPid({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetgenDoReply::ProcName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpGetgenDoReply",
            r#type.and_then(|t| OpGetgenDoReply::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpGetgenDoReply<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetgenDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetgenDoReply::Id(val) => fmt.field("Id", &val),
                OpGetgenDoReply::ProcPid(val) => fmt.field("ProcPid", &val),
                OpGetgenDoReply::ProcName(val) => fmt.field("ProcName", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpGetgenDoReply<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetgenDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetgenDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetgenDoReply::Id(val) => {
                    if last_off == offset {
                        stack.push(("Id", last_off));
                        break;
                    }
                }
                OpGetgenDoReply::ProcPid(val) => {
                    if last_off == offset {
                        stack.push(("ProcPid", last_off));
                        break;
                    }
                }
                OpGetgenDoReply::ProcName(val) => {
                    if last_off == offset {
                        stack.push(("ProcName", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetgenDoReply", cur));
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpGetgenDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpGetgenDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpGetgenDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpGetgenDoRequest<&mut Vec<u8>> {
        PushOpGetgenDoRequest::new_without_header(self.request.buf_mut())
    }
}
impl NetlinkRequest for RequestOpGetgenDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, Iterable<'buf, OpGetgenDoReply<'buf>>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2576u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpGetgenDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpGetgenDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Create a new stateful object."]
pub struct PushOpNewobjDoRequest<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpNewobjDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpNewobjDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the expression"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the expression"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "name of this expression type"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of this expression type"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "stateful object type\nAssociated type: \"ObjectType\" (enum)"]
    pub fn push_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "stateful object data"]
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn sub_nested_data_counter(mut self) -> PushCounterAttrs<Self> {
        self = self.push_type(ObjectType::Counter as u32);
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushCounterAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn sub_nested_data_quota(mut self) -> PushQuotaAttrs<Self> {
        self = self.push_type(ObjectType::Quota as u32);
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushQuotaAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "number of references to this expression"]
    pub fn push_use(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "object handle"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 6u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 7u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 8u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushOpNewobjDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Create a new stateful object."]
#[doc = "Original name: \"op-newobj-do-request\""]
#[derive(Clone)]
pub enum OpNewobjDoRequest<'a> {
    #[doc = "name of the table containing the expression"]
    Table(&'a CStr),
    #[doc = "name of this expression type"]
    Name(&'a CStr),
    #[doc = "stateful object type\nAssociated type: \"ObjectType\" (enum)"]
    Type(u32),
    #[doc = "stateful object data"]
    Data(ObjData<'a>),
    #[doc = "number of references to this expression"]
    Use(u32),
    #[doc = "object handle"]
    Handle(u64),
    Pad(&'a [u8]),
    #[doc = "user data"]
    Userdata(&'a [u8]),
}
impl<'a> Iterable<'a, OpNewobjDoRequest<'a>> {
    #[doc = "name of the table containing the expression"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewobjDoRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewobjDoRequest", "Table"))
    }
    #[doc = "name of this expression type"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewobjDoRequest::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewobjDoRequest", "Name"))
    }
    #[doc = "stateful object type\nAssociated type: \"ObjectType\" (enum)"]
    pub fn get_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewobjDoRequest::Type(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewobjDoRequest", "Type"))
    }
    #[doc = "stateful object data"]
    pub fn get_data(&self) -> Result<ObjData<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewobjDoRequest::Data(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewobjDoRequest", "Data"))
    }
    #[doc = "number of references to this expression"]
    pub fn get_use(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewobjDoRequest::Use(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewobjDoRequest", "Use"))
    }
    #[doc = "object handle"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewobjDoRequest::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewobjDoRequest", "Handle"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewobjDoRequest::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewobjDoRequest", "Pad"))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewobjDoRequest::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewobjDoRequest", "Userdata"))
    }
}
impl<'a> OpNewobjDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpNewobjDoRequest<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        ObjAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpNewobjDoRequest<'a>> {
    type Item = Result<OpNewobjDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpNewobjDoRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpNewobjDoRequest::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpNewobjDoRequest::Type({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpNewobjDoRequest::Data({
                    let res = {
                        let Ok(selector) = self.get_type() else { break };
                        ObjData::select_with_loc(selector, next, self.orig_loc)
                    };
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpNewobjDoRequest::Use({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpNewobjDoRequest::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpNewobjDoRequest::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpNewobjDoRequest::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpNewobjDoRequest",
            r#type.and_then(|t| OpNewobjDoRequest::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpNewobjDoRequest<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpNewobjDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpNewobjDoRequest::Table(val) => fmt.field("Table", &val),
                OpNewobjDoRequest::Name(val) => fmt.field("Name", &val),
                OpNewobjDoRequest::Type(val) => {
                    fmt.field("Type", &FormatEnum(val.into(), ObjectType::from_value))
                }
                OpNewobjDoRequest::Data(val) => fmt.field("Data", &val),
                OpNewobjDoRequest::Use(val) => fmt.field("Use", &val),
                OpNewobjDoRequest::Handle(val) => fmt.field("Handle", &val),
                OpNewobjDoRequest::Pad(val) => fmt.field("Pad", &val),
                OpNewobjDoRequest::Userdata(val) => fmt.field("Userdata", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpNewobjDoRequest<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpNewobjDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpNewobjDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpNewobjDoRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpNewobjDoRequest::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpNewobjDoRequest::Type(val) => {
                    if last_off == offset {
                        stack.push(("Type", last_off));
                        break;
                    }
                }
                OpNewobjDoRequest::Data(val) => {
                    if last_off == offset {
                        stack.push(("Data", last_off));
                        break;
                    }
                }
                OpNewobjDoRequest::Use(val) => {
                    if last_off == offset {
                        stack.push(("Use", last_off));
                        break;
                    }
                }
                OpNewobjDoRequest::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpNewobjDoRequest::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                OpNewobjDoRequest::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpNewobjDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Create a new stateful object."]
pub struct PushOpNewobjDoReply<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpNewobjDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpNewobjDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the expression"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the expression"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "name of this expression type"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of this expression type"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "stateful object type\nAssociated type: \"ObjectType\" (enum)"]
    pub fn push_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "stateful object data"]
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn sub_nested_data_counter(mut self) -> PushCounterAttrs<Self> {
        self = self.push_type(ObjectType::Counter as u32);
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushCounterAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn sub_nested_data_quota(mut self) -> PushQuotaAttrs<Self> {
        self = self.push_type(ObjectType::Quota as u32);
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushQuotaAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "number of references to this expression"]
    pub fn push_use(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "object handle"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 6u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 7u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 8u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushOpNewobjDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Create a new stateful object."]
#[doc = "Original name: \"op-newobj-do-reply\""]
#[derive(Clone)]
pub enum OpNewobjDoReply<'a> {
    #[doc = "name of the table containing the expression"]
    Table(&'a CStr),
    #[doc = "name of this expression type"]
    Name(&'a CStr),
    #[doc = "stateful object type\nAssociated type: \"ObjectType\" (enum)"]
    Type(u32),
    #[doc = "stateful object data"]
    Data(ObjData<'a>),
    #[doc = "number of references to this expression"]
    Use(u32),
    #[doc = "object handle"]
    Handle(u64),
    Pad(&'a [u8]),
    #[doc = "user data"]
    Userdata(&'a [u8]),
}
impl<'a> Iterable<'a, OpNewobjDoReply<'a>> {
    #[doc = "name of the table containing the expression"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewobjDoReply::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewobjDoReply", "Table"))
    }
    #[doc = "name of this expression type"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewobjDoReply::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewobjDoReply", "Name"))
    }
    #[doc = "stateful object type\nAssociated type: \"ObjectType\" (enum)"]
    pub fn get_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewobjDoReply::Type(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewobjDoReply", "Type"))
    }
    #[doc = "stateful object data"]
    pub fn get_data(&self) -> Result<ObjData<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewobjDoReply::Data(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewobjDoReply", "Data"))
    }
    #[doc = "number of references to this expression"]
    pub fn get_use(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewobjDoReply::Use(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewobjDoReply", "Use"))
    }
    #[doc = "object handle"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewobjDoReply::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewobjDoReply", "Handle"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewobjDoReply::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewobjDoReply", "Pad"))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewobjDoReply::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewobjDoReply", "Userdata"))
    }
}
impl<'a> OpNewobjDoReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpNewobjDoReply<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        ObjAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpNewobjDoReply<'a>> {
    type Item = Result<OpNewobjDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpNewobjDoReply::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpNewobjDoReply::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpNewobjDoReply::Type({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpNewobjDoReply::Data({
                    let res = {
                        let Ok(selector) = self.get_type() else { break };
                        ObjData::select_with_loc(selector, next, self.orig_loc)
                    };
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpNewobjDoReply::Use({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpNewobjDoReply::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpNewobjDoReply::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpNewobjDoReply::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpNewobjDoReply",
            r#type.and_then(|t| OpNewobjDoReply::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpNewobjDoReply<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpNewobjDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpNewobjDoReply::Table(val) => fmt.field("Table", &val),
                OpNewobjDoReply::Name(val) => fmt.field("Name", &val),
                OpNewobjDoReply::Type(val) => {
                    fmt.field("Type", &FormatEnum(val.into(), ObjectType::from_value))
                }
                OpNewobjDoReply::Data(val) => fmt.field("Data", &val),
                OpNewobjDoReply::Use(val) => fmt.field("Use", &val),
                OpNewobjDoReply::Handle(val) => fmt.field("Handle", &val),
                OpNewobjDoReply::Pad(val) => fmt.field("Pad", &val),
                OpNewobjDoReply::Userdata(val) => fmt.field("Userdata", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpNewobjDoReply<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpNewobjDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpNewobjDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpNewobjDoReply::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpNewobjDoReply::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpNewobjDoReply::Type(val) => {
                    if last_off == offset {
                        stack.push(("Type", last_off));
                        break;
                    }
                }
                OpNewobjDoReply::Data(val) => {
                    if last_off == offset {
                        stack.push(("Data", last_off));
                        break;
                    }
                }
                OpNewobjDoReply::Use(val) => {
                    if last_off == offset {
                        stack.push(("Use", last_off));
                        break;
                    }
                }
                OpNewobjDoReply::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpNewobjDoReply::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                OpNewobjDoReply::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpNewobjDoReply", cur));
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpNewobjDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpNewobjDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpNewobjDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpNewobjDoRequest<&mut Vec<u8>> {
        PushOpNewobjDoRequest::new_without_header(self.request.buf_mut())
    }
}
impl NetlinkRequest for RequestOpNewobjDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, Iterable<'buf, OpNewobjDoReply<'buf>>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2578u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpNewobjDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpNewobjDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Get / dump stateful objects."]
pub struct PushOpGetobjDumpRequest<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetobjDumpRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetobjDumpRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the expression"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the expression"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "name of this expression type"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of this expression type"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "stateful object type\nAssociated type: \"ObjectType\" (enum)"]
    pub fn push_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "stateful object data"]
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn sub_nested_data_counter(mut self) -> PushCounterAttrs<Self> {
        self = self.push_type(ObjectType::Counter as u32);
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushCounterAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn sub_nested_data_quota(mut self) -> PushQuotaAttrs<Self> {
        self = self.push_type(ObjectType::Quota as u32);
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushQuotaAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "number of references to this expression"]
    pub fn push_use(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "object handle"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 6u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 7u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 8u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetobjDumpRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump stateful objects."]
#[doc = "Original name: \"op-getobj-dump-request\""]
#[derive(Clone)]
pub enum OpGetobjDumpRequest<'a> {
    #[doc = "name of the table containing the expression"]
    Table(&'a CStr),
    #[doc = "name of this expression type"]
    Name(&'a CStr),
    #[doc = "stateful object type\nAssociated type: \"ObjectType\" (enum)"]
    Type(u32),
    #[doc = "stateful object data"]
    Data(ObjData<'a>),
    #[doc = "number of references to this expression"]
    Use(u32),
    #[doc = "object handle"]
    Handle(u64),
    Pad(&'a [u8]),
    #[doc = "user data"]
    Userdata(&'a [u8]),
}
impl<'a> Iterable<'a, OpGetobjDumpRequest<'a>> {
    #[doc = "name of the table containing the expression"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetobjDumpRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetobjDumpRequest", "Table"))
    }
    #[doc = "name of this expression type"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetobjDumpRequest::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetobjDumpRequest", "Name"))
    }
    #[doc = "stateful object type\nAssociated type: \"ObjectType\" (enum)"]
    pub fn get_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetobjDumpRequest::Type(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetobjDumpRequest", "Type"))
    }
    #[doc = "stateful object data"]
    pub fn get_data(&self) -> Result<ObjData<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetobjDumpRequest::Data(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetobjDumpRequest", "Data"))
    }
    #[doc = "number of references to this expression"]
    pub fn get_use(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetobjDumpRequest::Use(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetobjDumpRequest", "Use"))
    }
    #[doc = "object handle"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetobjDumpRequest::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetobjDumpRequest", "Handle"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetobjDumpRequest::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetobjDumpRequest", "Pad"))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetobjDumpRequest::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetobjDumpRequest", "Userdata"))
    }
}
impl<'a> OpGetobjDumpRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpGetobjDumpRequest<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        ObjAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpGetobjDumpRequest<'a>> {
    type Item = Result<OpGetobjDumpRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetobjDumpRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetobjDumpRequest::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetobjDumpRequest::Type({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpGetobjDumpRequest::Data({
                    let res = {
                        let Ok(selector) = self.get_type() else { break };
                        ObjData::select_with_loc(selector, next, self.orig_loc)
                    };
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpGetobjDumpRequest::Use({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpGetobjDumpRequest::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpGetobjDumpRequest::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpGetobjDumpRequest::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpGetobjDumpRequest",
            r#type.and_then(|t| OpGetobjDumpRequest::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpGetobjDumpRequest<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetobjDumpRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetobjDumpRequest::Table(val) => fmt.field("Table", &val),
                OpGetobjDumpRequest::Name(val) => fmt.field("Name", &val),
                OpGetobjDumpRequest::Type(val) => {
                    fmt.field("Type", &FormatEnum(val.into(), ObjectType::from_value))
                }
                OpGetobjDumpRequest::Data(val) => fmt.field("Data", &val),
                OpGetobjDumpRequest::Use(val) => fmt.field("Use", &val),
                OpGetobjDumpRequest::Handle(val) => fmt.field("Handle", &val),
                OpGetobjDumpRequest::Pad(val) => fmt.field("Pad", &val),
                OpGetobjDumpRequest::Userdata(val) => fmt.field("Userdata", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpGetobjDumpRequest<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetobjDumpRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetobjDumpRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetobjDumpRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpGetobjDumpRequest::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpGetobjDumpRequest::Type(val) => {
                    if last_off == offset {
                        stack.push(("Type", last_off));
                        break;
                    }
                }
                OpGetobjDumpRequest::Data(val) => {
                    if last_off == offset {
                        stack.push(("Data", last_off));
                        break;
                    }
                }
                OpGetobjDumpRequest::Use(val) => {
                    if last_off == offset {
                        stack.push(("Use", last_off));
                        break;
                    }
                }
                OpGetobjDumpRequest::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpGetobjDumpRequest::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                OpGetobjDumpRequest::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetobjDumpRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get / dump stateful objects."]
pub struct PushOpGetobjDumpReply<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetobjDumpReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetobjDumpReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the expression"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the expression"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "name of this expression type"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of this expression type"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "stateful object type\nAssociated type: \"ObjectType\" (enum)"]
    pub fn push_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "stateful object data"]
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn sub_nested_data_counter(mut self) -> PushCounterAttrs<Self> {
        self = self.push_type(ObjectType::Counter as u32);
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushCounterAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn sub_nested_data_quota(mut self) -> PushQuotaAttrs<Self> {
        self = self.push_type(ObjectType::Quota as u32);
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushQuotaAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "number of references to this expression"]
    pub fn push_use(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "object handle"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 6u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 7u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 8u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetobjDumpReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump stateful objects."]
#[doc = "Original name: \"op-getobj-dump-reply\""]
#[derive(Clone)]
pub enum OpGetobjDumpReply<'a> {
    #[doc = "name of the table containing the expression"]
    Table(&'a CStr),
    #[doc = "name of this expression type"]
    Name(&'a CStr),
    #[doc = "stateful object type\nAssociated type: \"ObjectType\" (enum)"]
    Type(u32),
    #[doc = "stateful object data"]
    Data(ObjData<'a>),
    #[doc = "number of references to this expression"]
    Use(u32),
    #[doc = "object handle"]
    Handle(u64),
    Pad(&'a [u8]),
    #[doc = "user data"]
    Userdata(&'a [u8]),
}
impl<'a> Iterable<'a, OpGetobjDumpReply<'a>> {
    #[doc = "name of the table containing the expression"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetobjDumpReply::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetobjDumpReply", "Table"))
    }
    #[doc = "name of this expression type"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetobjDumpReply::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetobjDumpReply", "Name"))
    }
    #[doc = "stateful object type\nAssociated type: \"ObjectType\" (enum)"]
    pub fn get_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetobjDumpReply::Type(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetobjDumpReply", "Type"))
    }
    #[doc = "stateful object data"]
    pub fn get_data(&self) -> Result<ObjData<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetobjDumpReply::Data(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetobjDumpReply", "Data"))
    }
    #[doc = "number of references to this expression"]
    pub fn get_use(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetobjDumpReply::Use(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetobjDumpReply", "Use"))
    }
    #[doc = "object handle"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetobjDumpReply::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetobjDumpReply", "Handle"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetobjDumpReply::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetobjDumpReply", "Pad"))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetobjDumpReply::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetobjDumpReply", "Userdata"))
    }
}
impl<'a> OpGetobjDumpReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpGetobjDumpReply<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        ObjAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpGetobjDumpReply<'a>> {
    type Item = Result<OpGetobjDumpReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetobjDumpReply::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetobjDumpReply::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetobjDumpReply::Type({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpGetobjDumpReply::Data({
                    let res = {
                        let Ok(selector) = self.get_type() else { break };
                        ObjData::select_with_loc(selector, next, self.orig_loc)
                    };
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpGetobjDumpReply::Use({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpGetobjDumpReply::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpGetobjDumpReply::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpGetobjDumpReply::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpGetobjDumpReply",
            r#type.and_then(|t| OpGetobjDumpReply::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpGetobjDumpReply<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetobjDumpReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetobjDumpReply::Table(val) => fmt.field("Table", &val),
                OpGetobjDumpReply::Name(val) => fmt.field("Name", &val),
                OpGetobjDumpReply::Type(val) => {
                    fmt.field("Type", &FormatEnum(val.into(), ObjectType::from_value))
                }
                OpGetobjDumpReply::Data(val) => fmt.field("Data", &val),
                OpGetobjDumpReply::Use(val) => fmt.field("Use", &val),
                OpGetobjDumpReply::Handle(val) => fmt.field("Handle", &val),
                OpGetobjDumpReply::Pad(val) => fmt.field("Pad", &val),
                OpGetobjDumpReply::Userdata(val) => fmt.field("Userdata", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpGetobjDumpReply<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetobjDumpReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetobjDumpReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetobjDumpReply::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpGetobjDumpReply::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpGetobjDumpReply::Type(val) => {
                    if last_off == offset {
                        stack.push(("Type", last_off));
                        break;
                    }
                }
                OpGetobjDumpReply::Data(val) => {
                    if last_off == offset {
                        stack.push(("Data", last_off));
                        break;
                    }
                }
                OpGetobjDumpReply::Use(val) => {
                    if last_off == offset {
                        stack.push(("Use", last_off));
                        break;
                    }
                }
                OpGetobjDumpReply::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpGetobjDumpReply::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                OpGetobjDumpReply::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetobjDumpReply", cur));
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpGetobjDumpRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpGetobjDumpRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpGetobjDumpRequest::write_header(&mut request.buf_mut(), header);
        Self {
            request: request.set_dump(),
        }
    }
    pub fn encode(&mut self) -> PushOpGetobjDumpRequest<&mut Vec<u8>> {
        PushOpGetobjDumpRequest::new_without_header(self.request.buf_mut())
    }
}
impl NetlinkRequest for RequestOpGetobjDumpRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, Iterable<'buf, OpGetobjDumpReply<'buf>>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2579u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpGetobjDumpReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpGetobjDumpRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Get / dump stateful objects."]
pub struct PushOpGetobjDoRequest<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetobjDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetobjDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the expression"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the expression"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "name of this expression type"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of this expression type"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "stateful object type\nAssociated type: \"ObjectType\" (enum)"]
    pub fn push_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "stateful object data"]
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn sub_nested_data_counter(mut self) -> PushCounterAttrs<Self> {
        self = self.push_type(ObjectType::Counter as u32);
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushCounterAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn sub_nested_data_quota(mut self) -> PushQuotaAttrs<Self> {
        self = self.push_type(ObjectType::Quota as u32);
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushQuotaAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "number of references to this expression"]
    pub fn push_use(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "object handle"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 6u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 7u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 8u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetobjDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump stateful objects."]
#[doc = "Original name: \"op-getobj-do-request\""]
#[derive(Clone)]
pub enum OpGetobjDoRequest<'a> {
    #[doc = "name of the table containing the expression"]
    Table(&'a CStr),
    #[doc = "name of this expression type"]
    Name(&'a CStr),
    #[doc = "stateful object type\nAssociated type: \"ObjectType\" (enum)"]
    Type(u32),
    #[doc = "stateful object data"]
    Data(ObjData<'a>),
    #[doc = "number of references to this expression"]
    Use(u32),
    #[doc = "object handle"]
    Handle(u64),
    Pad(&'a [u8]),
    #[doc = "user data"]
    Userdata(&'a [u8]),
}
impl<'a> Iterable<'a, OpGetobjDoRequest<'a>> {
    #[doc = "name of the table containing the expression"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetobjDoRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetobjDoRequest", "Table"))
    }
    #[doc = "name of this expression type"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetobjDoRequest::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetobjDoRequest", "Name"))
    }
    #[doc = "stateful object type\nAssociated type: \"ObjectType\" (enum)"]
    pub fn get_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetobjDoRequest::Type(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetobjDoRequest", "Type"))
    }
    #[doc = "stateful object data"]
    pub fn get_data(&self) -> Result<ObjData<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetobjDoRequest::Data(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetobjDoRequest", "Data"))
    }
    #[doc = "number of references to this expression"]
    pub fn get_use(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetobjDoRequest::Use(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetobjDoRequest", "Use"))
    }
    #[doc = "object handle"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetobjDoRequest::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetobjDoRequest", "Handle"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetobjDoRequest::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetobjDoRequest", "Pad"))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetobjDoRequest::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetobjDoRequest", "Userdata"))
    }
}
impl<'a> OpGetobjDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpGetobjDoRequest<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        ObjAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpGetobjDoRequest<'a>> {
    type Item = Result<OpGetobjDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetobjDoRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetobjDoRequest::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetobjDoRequest::Type({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpGetobjDoRequest::Data({
                    let res = {
                        let Ok(selector) = self.get_type() else { break };
                        ObjData::select_with_loc(selector, next, self.orig_loc)
                    };
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpGetobjDoRequest::Use({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpGetobjDoRequest::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpGetobjDoRequest::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpGetobjDoRequest::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpGetobjDoRequest",
            r#type.and_then(|t| OpGetobjDoRequest::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpGetobjDoRequest<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetobjDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetobjDoRequest::Table(val) => fmt.field("Table", &val),
                OpGetobjDoRequest::Name(val) => fmt.field("Name", &val),
                OpGetobjDoRequest::Type(val) => {
                    fmt.field("Type", &FormatEnum(val.into(), ObjectType::from_value))
                }
                OpGetobjDoRequest::Data(val) => fmt.field("Data", &val),
                OpGetobjDoRequest::Use(val) => fmt.field("Use", &val),
                OpGetobjDoRequest::Handle(val) => fmt.field("Handle", &val),
                OpGetobjDoRequest::Pad(val) => fmt.field("Pad", &val),
                OpGetobjDoRequest::Userdata(val) => fmt.field("Userdata", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpGetobjDoRequest<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetobjDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetobjDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetobjDoRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpGetobjDoRequest::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpGetobjDoRequest::Type(val) => {
                    if last_off == offset {
                        stack.push(("Type", last_off));
                        break;
                    }
                }
                OpGetobjDoRequest::Data(val) => {
                    if last_off == offset {
                        stack.push(("Data", last_off));
                        break;
                    }
                }
                OpGetobjDoRequest::Use(val) => {
                    if last_off == offset {
                        stack.push(("Use", last_off));
                        break;
                    }
                }
                OpGetobjDoRequest::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpGetobjDoRequest::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                OpGetobjDoRequest::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetobjDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get / dump stateful objects."]
pub struct PushOpGetobjDoReply<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetobjDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetobjDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the expression"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the expression"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "name of this expression type"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of this expression type"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "stateful object type\nAssociated type: \"ObjectType\" (enum)"]
    pub fn push_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "stateful object data"]
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn sub_nested_data_counter(mut self) -> PushCounterAttrs<Self> {
        self = self.push_type(ObjectType::Counter as u32);
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushCounterAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn sub_nested_data_quota(mut self) -> PushQuotaAttrs<Self> {
        self = self.push_type(ObjectType::Quota as u32);
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushQuotaAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "number of references to this expression"]
    pub fn push_use(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "object handle"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 6u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 7u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 8u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetobjDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump stateful objects."]
#[doc = "Original name: \"op-getobj-do-reply\""]
#[derive(Clone)]
pub enum OpGetobjDoReply<'a> {
    #[doc = "name of the table containing the expression"]
    Table(&'a CStr),
    #[doc = "name of this expression type"]
    Name(&'a CStr),
    #[doc = "stateful object type\nAssociated type: \"ObjectType\" (enum)"]
    Type(u32),
    #[doc = "stateful object data"]
    Data(ObjData<'a>),
    #[doc = "number of references to this expression"]
    Use(u32),
    #[doc = "object handle"]
    Handle(u64),
    Pad(&'a [u8]),
    #[doc = "user data"]
    Userdata(&'a [u8]),
}
impl<'a> Iterable<'a, OpGetobjDoReply<'a>> {
    #[doc = "name of the table containing the expression"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetobjDoReply::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetobjDoReply", "Table"))
    }
    #[doc = "name of this expression type"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetobjDoReply::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetobjDoReply", "Name"))
    }
    #[doc = "stateful object type\nAssociated type: \"ObjectType\" (enum)"]
    pub fn get_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetobjDoReply::Type(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetobjDoReply", "Type"))
    }
    #[doc = "stateful object data"]
    pub fn get_data(&self) -> Result<ObjData<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetobjDoReply::Data(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetobjDoReply", "Data"))
    }
    #[doc = "number of references to this expression"]
    pub fn get_use(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetobjDoReply::Use(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetobjDoReply", "Use"))
    }
    #[doc = "object handle"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetobjDoReply::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetobjDoReply", "Handle"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetobjDoReply::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetobjDoReply", "Pad"))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetobjDoReply::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetobjDoReply", "Userdata"))
    }
}
impl<'a> OpGetobjDoReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpGetobjDoReply<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        ObjAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpGetobjDoReply<'a>> {
    type Item = Result<OpGetobjDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetobjDoReply::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetobjDoReply::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetobjDoReply::Type({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpGetobjDoReply::Data({
                    let res = {
                        let Ok(selector) = self.get_type() else { break };
                        ObjData::select_with_loc(selector, next, self.orig_loc)
                    };
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpGetobjDoReply::Use({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpGetobjDoReply::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpGetobjDoReply::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpGetobjDoReply::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpGetobjDoReply",
            r#type.and_then(|t| OpGetobjDoReply::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpGetobjDoReply<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetobjDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetobjDoReply::Table(val) => fmt.field("Table", &val),
                OpGetobjDoReply::Name(val) => fmt.field("Name", &val),
                OpGetobjDoReply::Type(val) => {
                    fmt.field("Type", &FormatEnum(val.into(), ObjectType::from_value))
                }
                OpGetobjDoReply::Data(val) => fmt.field("Data", &val),
                OpGetobjDoReply::Use(val) => fmt.field("Use", &val),
                OpGetobjDoReply::Handle(val) => fmt.field("Handle", &val),
                OpGetobjDoReply::Pad(val) => fmt.field("Pad", &val),
                OpGetobjDoReply::Userdata(val) => fmt.field("Userdata", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpGetobjDoReply<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetobjDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetobjDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetobjDoReply::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpGetobjDoReply::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpGetobjDoReply::Type(val) => {
                    if last_off == offset {
                        stack.push(("Type", last_off));
                        break;
                    }
                }
                OpGetobjDoReply::Data(val) => {
                    if last_off == offset {
                        stack.push(("Data", last_off));
                        break;
                    }
                }
                OpGetobjDoReply::Use(val) => {
                    if last_off == offset {
                        stack.push(("Use", last_off));
                        break;
                    }
                }
                OpGetobjDoReply::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpGetobjDoReply::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                OpGetobjDoReply::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetobjDoReply", cur));
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpGetobjDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpGetobjDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpGetobjDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpGetobjDoRequest<&mut Vec<u8>> {
        PushOpGetobjDoRequest::new_without_header(self.request.buf_mut())
    }
}
impl NetlinkRequest for RequestOpGetobjDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, Iterable<'buf, OpGetobjDoReply<'buf>>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2579u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpGetobjDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpGetobjDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Delete an existing stateful object."]
pub struct PushOpDelobjDoRequest<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDelobjDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDelobjDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the expression"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the expression"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "name of this expression type"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of this expression type"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "stateful object type\nAssociated type: \"ObjectType\" (enum)"]
    pub fn push_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "stateful object data"]
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn sub_nested_data_counter(mut self) -> PushCounterAttrs<Self> {
        self = self.push_type(ObjectType::Counter as u32);
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushCounterAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn sub_nested_data_quota(mut self) -> PushQuotaAttrs<Self> {
        self = self.push_type(ObjectType::Quota as u32);
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushQuotaAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "number of references to this expression"]
    pub fn push_use(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "object handle"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 6u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 7u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 8u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushOpDelobjDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete an existing stateful object."]
#[doc = "Original name: \"op-delobj-do-request\""]
#[derive(Clone)]
pub enum OpDelobjDoRequest<'a> {
    #[doc = "name of the table containing the expression"]
    Table(&'a CStr),
    #[doc = "name of this expression type"]
    Name(&'a CStr),
    #[doc = "stateful object type\nAssociated type: \"ObjectType\" (enum)"]
    Type(u32),
    #[doc = "stateful object data"]
    Data(ObjData<'a>),
    #[doc = "number of references to this expression"]
    Use(u32),
    #[doc = "object handle"]
    Handle(u64),
    Pad(&'a [u8]),
    #[doc = "user data"]
    Userdata(&'a [u8]),
}
impl<'a> Iterable<'a, OpDelobjDoRequest<'a>> {
    #[doc = "name of the table containing the expression"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelobjDoRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelobjDoRequest", "Table"))
    }
    #[doc = "name of this expression type"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelobjDoRequest::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelobjDoRequest", "Name"))
    }
    #[doc = "stateful object type\nAssociated type: \"ObjectType\" (enum)"]
    pub fn get_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelobjDoRequest::Type(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelobjDoRequest", "Type"))
    }
    #[doc = "stateful object data"]
    pub fn get_data(&self) -> Result<ObjData<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelobjDoRequest::Data(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelobjDoRequest", "Data"))
    }
    #[doc = "number of references to this expression"]
    pub fn get_use(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelobjDoRequest::Use(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelobjDoRequest", "Use"))
    }
    #[doc = "object handle"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelobjDoRequest::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelobjDoRequest", "Handle"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelobjDoRequest::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelobjDoRequest", "Pad"))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelobjDoRequest::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelobjDoRequest", "Userdata"))
    }
}
impl<'a> OpDelobjDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpDelobjDoRequest<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        ObjAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpDelobjDoRequest<'a>> {
    type Item = Result<OpDelobjDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpDelobjDoRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpDelobjDoRequest::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpDelobjDoRequest::Type({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpDelobjDoRequest::Data({
                    let res = {
                        let Ok(selector) = self.get_type() else { break };
                        ObjData::select_with_loc(selector, next, self.orig_loc)
                    };
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpDelobjDoRequest::Use({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpDelobjDoRequest::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpDelobjDoRequest::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpDelobjDoRequest::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpDelobjDoRequest",
            r#type.and_then(|t| OpDelobjDoRequest::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpDelobjDoRequest<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDelobjDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpDelobjDoRequest::Table(val) => fmt.field("Table", &val),
                OpDelobjDoRequest::Name(val) => fmt.field("Name", &val),
                OpDelobjDoRequest::Type(val) => {
                    fmt.field("Type", &FormatEnum(val.into(), ObjectType::from_value))
                }
                OpDelobjDoRequest::Data(val) => fmt.field("Data", &val),
                OpDelobjDoRequest::Use(val) => fmt.field("Use", &val),
                OpDelobjDoRequest::Handle(val) => fmt.field("Handle", &val),
                OpDelobjDoRequest::Pad(val) => fmt.field("Pad", &val),
                OpDelobjDoRequest::Userdata(val) => fmt.field("Userdata", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpDelobjDoRequest<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpDelobjDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDelobjDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpDelobjDoRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpDelobjDoRequest::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpDelobjDoRequest::Type(val) => {
                    if last_off == offset {
                        stack.push(("Type", last_off));
                        break;
                    }
                }
                OpDelobjDoRequest::Data(val) => {
                    if last_off == offset {
                        stack.push(("Data", last_off));
                        break;
                    }
                }
                OpDelobjDoRequest::Use(val) => {
                    if last_off == offset {
                        stack.push(("Use", last_off));
                        break;
                    }
                }
                OpDelobjDoRequest::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpDelobjDoRequest::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                OpDelobjDoRequest::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpDelobjDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Delete an existing stateful object."]
pub struct PushOpDelobjDoReply<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDelobjDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDelobjDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the expression"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the expression"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "name of this expression type"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of this expression type"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "stateful object type\nAssociated type: \"ObjectType\" (enum)"]
    pub fn push_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "stateful object data"]
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn sub_nested_data_counter(mut self) -> PushCounterAttrs<Self> {
        self = self.push_type(ObjectType::Counter as u32);
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushCounterAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn sub_nested_data_quota(mut self) -> PushQuotaAttrs<Self> {
        self = self.push_type(ObjectType::Quota as u32);
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushQuotaAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "number of references to this expression"]
    pub fn push_use(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "object handle"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 6u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 7u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 8u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushOpDelobjDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete an existing stateful object."]
#[doc = "Original name: \"op-delobj-do-reply\""]
#[derive(Clone)]
pub enum OpDelobjDoReply<'a> {
    #[doc = "name of the table containing the expression"]
    Table(&'a CStr),
    #[doc = "name of this expression type"]
    Name(&'a CStr),
    #[doc = "stateful object type\nAssociated type: \"ObjectType\" (enum)"]
    Type(u32),
    #[doc = "stateful object data"]
    Data(ObjData<'a>),
    #[doc = "number of references to this expression"]
    Use(u32),
    #[doc = "object handle"]
    Handle(u64),
    Pad(&'a [u8]),
    #[doc = "user data"]
    Userdata(&'a [u8]),
}
impl<'a> Iterable<'a, OpDelobjDoReply<'a>> {
    #[doc = "name of the table containing the expression"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelobjDoReply::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelobjDoReply", "Table"))
    }
    #[doc = "name of this expression type"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelobjDoReply::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelobjDoReply", "Name"))
    }
    #[doc = "stateful object type\nAssociated type: \"ObjectType\" (enum)"]
    pub fn get_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelobjDoReply::Type(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelobjDoReply", "Type"))
    }
    #[doc = "stateful object data"]
    pub fn get_data(&self) -> Result<ObjData<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelobjDoReply::Data(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelobjDoReply", "Data"))
    }
    #[doc = "number of references to this expression"]
    pub fn get_use(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelobjDoReply::Use(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelobjDoReply", "Use"))
    }
    #[doc = "object handle"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelobjDoReply::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelobjDoReply", "Handle"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelobjDoReply::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelobjDoReply", "Pad"))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelobjDoReply::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelobjDoReply", "Userdata"))
    }
}
impl<'a> OpDelobjDoReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpDelobjDoReply<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        ObjAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpDelobjDoReply<'a>> {
    type Item = Result<OpDelobjDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpDelobjDoReply::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpDelobjDoReply::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpDelobjDoReply::Type({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpDelobjDoReply::Data({
                    let res = {
                        let Ok(selector) = self.get_type() else { break };
                        ObjData::select_with_loc(selector, next, self.orig_loc)
                    };
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpDelobjDoReply::Use({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpDelobjDoReply::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpDelobjDoReply::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpDelobjDoReply::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpDelobjDoReply",
            r#type.and_then(|t| OpDelobjDoReply::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpDelobjDoReply<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDelobjDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpDelobjDoReply::Table(val) => fmt.field("Table", &val),
                OpDelobjDoReply::Name(val) => fmt.field("Name", &val),
                OpDelobjDoReply::Type(val) => {
                    fmt.field("Type", &FormatEnum(val.into(), ObjectType::from_value))
                }
                OpDelobjDoReply::Data(val) => fmt.field("Data", &val),
                OpDelobjDoReply::Use(val) => fmt.field("Use", &val),
                OpDelobjDoReply::Handle(val) => fmt.field("Handle", &val),
                OpDelobjDoReply::Pad(val) => fmt.field("Pad", &val),
                OpDelobjDoReply::Userdata(val) => fmt.field("Userdata", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpDelobjDoReply<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpDelobjDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDelobjDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpDelobjDoReply::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpDelobjDoReply::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpDelobjDoReply::Type(val) => {
                    if last_off == offset {
                        stack.push(("Type", last_off));
                        break;
                    }
                }
                OpDelobjDoReply::Data(val) => {
                    if last_off == offset {
                        stack.push(("Data", last_off));
                        break;
                    }
                }
                OpDelobjDoReply::Use(val) => {
                    if last_off == offset {
                        stack.push(("Use", last_off));
                        break;
                    }
                }
                OpDelobjDoReply::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpDelobjDoReply::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                OpDelobjDoReply::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpDelobjDoReply", cur));
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpDelobjDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpDelobjDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpDelobjDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpDelobjDoRequest<&mut Vec<u8>> {
        PushOpDelobjDoRequest::new_without_header(self.request.buf_mut())
    }
}
impl NetlinkRequest for RequestOpDelobjDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, Iterable<'buf, OpDelobjDoReply<'buf>>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2580u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpDelobjDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpDelobjDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Delete an existing stateful object with destroy semantics."]
pub struct PushOpDestroyobjDoRequest<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDestroyobjDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDestroyobjDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the expression"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the expression"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "name of this expression type"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of this expression type"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "stateful object type\nAssociated type: \"ObjectType\" (enum)"]
    pub fn push_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "stateful object data"]
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn sub_nested_data_counter(mut self) -> PushCounterAttrs<Self> {
        self = self.push_type(ObjectType::Counter as u32);
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushCounterAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn sub_nested_data_quota(mut self) -> PushQuotaAttrs<Self> {
        self = self.push_type(ObjectType::Quota as u32);
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushQuotaAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "number of references to this expression"]
    pub fn push_use(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "object handle"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 6u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 7u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 8u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushOpDestroyobjDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete an existing stateful object with destroy semantics."]
#[doc = "Original name: \"op-destroyobj-do-request\""]
#[derive(Clone)]
pub enum OpDestroyobjDoRequest<'a> {
    #[doc = "name of the table containing the expression"]
    Table(&'a CStr),
    #[doc = "name of this expression type"]
    Name(&'a CStr),
    #[doc = "stateful object type\nAssociated type: \"ObjectType\" (enum)"]
    Type(u32),
    #[doc = "stateful object data"]
    Data(ObjData<'a>),
    #[doc = "number of references to this expression"]
    Use(u32),
    #[doc = "object handle"]
    Handle(u64),
    Pad(&'a [u8]),
    #[doc = "user data"]
    Userdata(&'a [u8]),
}
impl<'a> Iterable<'a, OpDestroyobjDoRequest<'a>> {
    #[doc = "name of the table containing the expression"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyobjDoRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroyobjDoRequest", "Table"))
    }
    #[doc = "name of this expression type"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyobjDoRequest::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroyobjDoRequest", "Name"))
    }
    #[doc = "stateful object type\nAssociated type: \"ObjectType\" (enum)"]
    pub fn get_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyobjDoRequest::Type(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroyobjDoRequest", "Type"))
    }
    #[doc = "stateful object data"]
    pub fn get_data(&self) -> Result<ObjData<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyobjDoRequest::Data(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroyobjDoRequest", "Data"))
    }
    #[doc = "number of references to this expression"]
    pub fn get_use(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyobjDoRequest::Use(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroyobjDoRequest", "Use"))
    }
    #[doc = "object handle"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyobjDoRequest::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroyobjDoRequest", "Handle"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyobjDoRequest::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroyobjDoRequest", "Pad"))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyobjDoRequest::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroyobjDoRequest", "Userdata"))
    }
}
impl<'a> OpDestroyobjDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpDestroyobjDoRequest<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        ObjAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpDestroyobjDoRequest<'a>> {
    type Item = Result<OpDestroyobjDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpDestroyobjDoRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpDestroyobjDoRequest::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpDestroyobjDoRequest::Type({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpDestroyobjDoRequest::Data({
                    let res = {
                        let Ok(selector) = self.get_type() else { break };
                        ObjData::select_with_loc(selector, next, self.orig_loc)
                    };
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpDestroyobjDoRequest::Use({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpDestroyobjDoRequest::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpDestroyobjDoRequest::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpDestroyobjDoRequest::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpDestroyobjDoRequest",
            r#type.and_then(|t| OpDestroyobjDoRequest::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpDestroyobjDoRequest<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDestroyobjDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpDestroyobjDoRequest::Table(val) => fmt.field("Table", &val),
                OpDestroyobjDoRequest::Name(val) => fmt.field("Name", &val),
                OpDestroyobjDoRequest::Type(val) => {
                    fmt.field("Type", &FormatEnum(val.into(), ObjectType::from_value))
                }
                OpDestroyobjDoRequest::Data(val) => fmt.field("Data", &val),
                OpDestroyobjDoRequest::Use(val) => fmt.field("Use", &val),
                OpDestroyobjDoRequest::Handle(val) => fmt.field("Handle", &val),
                OpDestroyobjDoRequest::Pad(val) => fmt.field("Pad", &val),
                OpDestroyobjDoRequest::Userdata(val) => fmt.field("Userdata", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpDestroyobjDoRequest<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpDestroyobjDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDestroyobjDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpDestroyobjDoRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpDestroyobjDoRequest::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpDestroyobjDoRequest::Type(val) => {
                    if last_off == offset {
                        stack.push(("Type", last_off));
                        break;
                    }
                }
                OpDestroyobjDoRequest::Data(val) => {
                    if last_off == offset {
                        stack.push(("Data", last_off));
                        break;
                    }
                }
                OpDestroyobjDoRequest::Use(val) => {
                    if last_off == offset {
                        stack.push(("Use", last_off));
                        break;
                    }
                }
                OpDestroyobjDoRequest::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpDestroyobjDoRequest::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                OpDestroyobjDoRequest::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpDestroyobjDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Delete an existing stateful object with destroy semantics."]
pub struct PushOpDestroyobjDoReply<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDestroyobjDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDestroyobjDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the expression"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the expression"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "name of this expression type"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of this expression type"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "stateful object type\nAssociated type: \"ObjectType\" (enum)"]
    pub fn push_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "stateful object data"]
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn sub_nested_data_counter(mut self) -> PushCounterAttrs<Self> {
        self = self.push_type(ObjectType::Counter as u32);
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushCounterAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn sub_nested_data_quota(mut self) -> PushQuotaAttrs<Self> {
        self = self.push_type(ObjectType::Quota as u32);
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushQuotaAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "number of references to this expression"]
    pub fn push_use(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "object handle"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 6u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 7u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 8u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushOpDestroyobjDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete an existing stateful object with destroy semantics."]
#[doc = "Original name: \"op-destroyobj-do-reply\""]
#[derive(Clone)]
pub enum OpDestroyobjDoReply<'a> {
    #[doc = "name of the table containing the expression"]
    Table(&'a CStr),
    #[doc = "name of this expression type"]
    Name(&'a CStr),
    #[doc = "stateful object type\nAssociated type: \"ObjectType\" (enum)"]
    Type(u32),
    #[doc = "stateful object data"]
    Data(ObjData<'a>),
    #[doc = "number of references to this expression"]
    Use(u32),
    #[doc = "object handle"]
    Handle(u64),
    Pad(&'a [u8]),
    #[doc = "user data"]
    Userdata(&'a [u8]),
}
impl<'a> Iterable<'a, OpDestroyobjDoReply<'a>> {
    #[doc = "name of the table containing the expression"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyobjDoReply::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroyobjDoReply", "Table"))
    }
    #[doc = "name of this expression type"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyobjDoReply::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroyobjDoReply", "Name"))
    }
    #[doc = "stateful object type\nAssociated type: \"ObjectType\" (enum)"]
    pub fn get_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyobjDoReply::Type(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroyobjDoReply", "Type"))
    }
    #[doc = "stateful object data"]
    pub fn get_data(&self) -> Result<ObjData<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyobjDoReply::Data(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroyobjDoReply", "Data"))
    }
    #[doc = "number of references to this expression"]
    pub fn get_use(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyobjDoReply::Use(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroyobjDoReply", "Use"))
    }
    #[doc = "object handle"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyobjDoReply::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroyobjDoReply", "Handle"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyobjDoReply::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroyobjDoReply", "Pad"))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyobjDoReply::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroyobjDoReply", "Userdata"))
    }
}
impl<'a> OpDestroyobjDoReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpDestroyobjDoReply<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        ObjAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpDestroyobjDoReply<'a>> {
    type Item = Result<OpDestroyobjDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpDestroyobjDoReply::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpDestroyobjDoReply::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpDestroyobjDoReply::Type({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpDestroyobjDoReply::Data({
                    let res = {
                        let Ok(selector) = self.get_type() else { break };
                        ObjData::select_with_loc(selector, next, self.orig_loc)
                    };
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpDestroyobjDoReply::Use({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpDestroyobjDoReply::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpDestroyobjDoReply::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpDestroyobjDoReply::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpDestroyobjDoReply",
            r#type.and_then(|t| OpDestroyobjDoReply::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpDestroyobjDoReply<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDestroyobjDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpDestroyobjDoReply::Table(val) => fmt.field("Table", &val),
                OpDestroyobjDoReply::Name(val) => fmt.field("Name", &val),
                OpDestroyobjDoReply::Type(val) => {
                    fmt.field("Type", &FormatEnum(val.into(), ObjectType::from_value))
                }
                OpDestroyobjDoReply::Data(val) => fmt.field("Data", &val),
                OpDestroyobjDoReply::Use(val) => fmt.field("Use", &val),
                OpDestroyobjDoReply::Handle(val) => fmt.field("Handle", &val),
                OpDestroyobjDoReply::Pad(val) => fmt.field("Pad", &val),
                OpDestroyobjDoReply::Userdata(val) => fmt.field("Userdata", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpDestroyobjDoReply<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpDestroyobjDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDestroyobjDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpDestroyobjDoReply::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpDestroyobjDoReply::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpDestroyobjDoReply::Type(val) => {
                    if last_off == offset {
                        stack.push(("Type", last_off));
                        break;
                    }
                }
                OpDestroyobjDoReply::Data(val) => {
                    if last_off == offset {
                        stack.push(("Data", last_off));
                        break;
                    }
                }
                OpDestroyobjDoReply::Use(val) => {
                    if last_off == offset {
                        stack.push(("Use", last_off));
                        break;
                    }
                }
                OpDestroyobjDoReply::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpDestroyobjDoReply::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                OpDestroyobjDoReply::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpDestroyobjDoReply", cur));
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpDestroyobjDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpDestroyobjDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpDestroyobjDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpDestroyobjDoRequest<&mut Vec<u8>> {
        PushOpDestroyobjDoRequest::new_without_header(self.request.buf_mut())
    }
}
impl NetlinkRequest for RequestOpDestroyobjDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, Iterable<'buf, OpDestroyobjDoReply<'buf>>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2591u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpDestroyobjDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpDestroyobjDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Create a new flow table."]
pub struct PushOpNewflowtableDoRequest<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpNewflowtableDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpNewflowtableDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn nested_hook(mut self) -> PushFlowtableHookAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 3u16);
        PushFlowtableHookAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_use(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 5u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 6u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 7u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpNewflowtableDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Create a new flow table."]
#[doc = "Original name: \"op-newflowtable-do-request\""]
#[derive(Clone)]
pub enum OpNewflowtableDoRequest<'a> {
    Table(&'a CStr),
    Name(&'a CStr),
    Hook(Iterable<'a, FlowtableHookAttrs<'a>>),
    Use(u32),
    Handle(u64),
    Pad(&'a [u8]),
    Flags(u32),
}
impl<'a> Iterable<'a, OpNewflowtableDoRequest<'a>> {
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewflowtableDoRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewflowtableDoRequest", "Table"))
    }
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewflowtableDoRequest::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewflowtableDoRequest", "Name"))
    }
    pub fn get_hook(&self) -> Result<Iterable<'a, FlowtableHookAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewflowtableDoRequest::Hook(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewflowtableDoRequest", "Hook"))
    }
    pub fn get_use(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewflowtableDoRequest::Use(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewflowtableDoRequest", "Use"))
    }
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewflowtableDoRequest::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewflowtableDoRequest", "Handle"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewflowtableDoRequest::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewflowtableDoRequest", "Pad"))
    }
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewflowtableDoRequest::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewflowtableDoRequest", "Flags"))
    }
}
impl<'a> OpNewflowtableDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpNewflowtableDoRequest<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        FlowtableAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpNewflowtableDoRequest<'a>> {
    type Item = Result<OpNewflowtableDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpNewflowtableDoRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpNewflowtableDoRequest::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpNewflowtableDoRequest::Hook({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpNewflowtableDoRequest::Use({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpNewflowtableDoRequest::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpNewflowtableDoRequest::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpNewflowtableDoRequest::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpNewflowtableDoRequest",
            r#type.and_then(|t| OpNewflowtableDoRequest::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpNewflowtableDoRequest<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpNewflowtableDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpNewflowtableDoRequest::Table(val) => fmt.field("Table", &val),
                OpNewflowtableDoRequest::Name(val) => fmt.field("Name", &val),
                OpNewflowtableDoRequest::Hook(val) => fmt.field("Hook", &val),
                OpNewflowtableDoRequest::Use(val) => fmt.field("Use", &val),
                OpNewflowtableDoRequest::Handle(val) => fmt.field("Handle", &val),
                OpNewflowtableDoRequest::Pad(val) => fmt.field("Pad", &val),
                OpNewflowtableDoRequest::Flags(val) => fmt.field("Flags", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpNewflowtableDoRequest<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpNewflowtableDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpNewflowtableDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpNewflowtableDoRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpNewflowtableDoRequest::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpNewflowtableDoRequest::Hook(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpNewflowtableDoRequest::Use(val) => {
                    if last_off == offset {
                        stack.push(("Use", last_off));
                        break;
                    }
                }
                OpNewflowtableDoRequest::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpNewflowtableDoRequest::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                OpNewflowtableDoRequest::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpNewflowtableDoRequest", cur));
        }
        (stack, missing)
    }
}
#[doc = "Create a new flow table."]
pub struct PushOpNewflowtableDoReply<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpNewflowtableDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpNewflowtableDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn nested_hook(mut self) -> PushFlowtableHookAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 3u16);
        PushFlowtableHookAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_use(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 5u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 6u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 7u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpNewflowtableDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Create a new flow table."]
#[doc = "Original name: \"op-newflowtable-do-reply\""]
#[derive(Clone)]
pub enum OpNewflowtableDoReply<'a> {
    Table(&'a CStr),
    Name(&'a CStr),
    Hook(Iterable<'a, FlowtableHookAttrs<'a>>),
    Use(u32),
    Handle(u64),
    Pad(&'a [u8]),
    Flags(u32),
}
impl<'a> Iterable<'a, OpNewflowtableDoReply<'a>> {
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewflowtableDoReply::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewflowtableDoReply", "Table"))
    }
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewflowtableDoReply::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewflowtableDoReply", "Name"))
    }
    pub fn get_hook(&self) -> Result<Iterable<'a, FlowtableHookAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewflowtableDoReply::Hook(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewflowtableDoReply", "Hook"))
    }
    pub fn get_use(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewflowtableDoReply::Use(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewflowtableDoReply", "Use"))
    }
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewflowtableDoReply::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewflowtableDoReply", "Handle"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewflowtableDoReply::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewflowtableDoReply", "Pad"))
    }
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewflowtableDoReply::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewflowtableDoReply", "Flags"))
    }
}
impl<'a> OpNewflowtableDoReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpNewflowtableDoReply<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        FlowtableAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpNewflowtableDoReply<'a>> {
    type Item = Result<OpNewflowtableDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpNewflowtableDoReply::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpNewflowtableDoReply::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpNewflowtableDoReply::Hook({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpNewflowtableDoReply::Use({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpNewflowtableDoReply::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpNewflowtableDoReply::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpNewflowtableDoReply::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpNewflowtableDoReply",
            r#type.and_then(|t| OpNewflowtableDoReply::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpNewflowtableDoReply<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpNewflowtableDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpNewflowtableDoReply::Table(val) => fmt.field("Table", &val),
                OpNewflowtableDoReply::Name(val) => fmt.field("Name", &val),
                OpNewflowtableDoReply::Hook(val) => fmt.field("Hook", &val),
                OpNewflowtableDoReply::Use(val) => fmt.field("Use", &val),
                OpNewflowtableDoReply::Handle(val) => fmt.field("Handle", &val),
                OpNewflowtableDoReply::Pad(val) => fmt.field("Pad", &val),
                OpNewflowtableDoReply::Flags(val) => fmt.field("Flags", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpNewflowtableDoReply<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpNewflowtableDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpNewflowtableDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpNewflowtableDoReply::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpNewflowtableDoReply::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpNewflowtableDoReply::Hook(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpNewflowtableDoReply::Use(val) => {
                    if last_off == offset {
                        stack.push(("Use", last_off));
                        break;
                    }
                }
                OpNewflowtableDoReply::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpNewflowtableDoReply::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                OpNewflowtableDoReply::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpNewflowtableDoReply", cur));
        }
        (stack, missing)
    }
}
#[derive(Debug)]
pub struct RequestOpNewflowtableDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpNewflowtableDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpNewflowtableDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpNewflowtableDoRequest<&mut Vec<u8>> {
        PushOpNewflowtableDoRequest::new_without_header(self.request.buf_mut())
    }
}
impl NetlinkRequest for RequestOpNewflowtableDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, Iterable<'buf, OpNewflowtableDoReply<'buf>>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2582u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpNewflowtableDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpNewflowtableDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Get / dump flow tables."]
pub struct PushOpGetflowtableDumpRequest<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetflowtableDumpRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetflowtableDumpRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn nested_hook(mut self) -> PushFlowtableHookAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 3u16);
        PushFlowtableHookAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_use(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 5u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 6u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 7u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetflowtableDumpRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump flow tables."]
#[doc = "Original name: \"op-getflowtable-dump-request\""]
#[derive(Clone)]
pub enum OpGetflowtableDumpRequest<'a> {
    Table(&'a CStr),
    Name(&'a CStr),
    Hook(Iterable<'a, FlowtableHookAttrs<'a>>),
    Use(u32),
    Handle(u64),
    Pad(&'a [u8]),
    Flags(u32),
}
impl<'a> Iterable<'a, OpGetflowtableDumpRequest<'a>> {
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetflowtableDumpRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetflowtableDumpRequest", "Table"))
    }
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetflowtableDumpRequest::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetflowtableDumpRequest", "Name"))
    }
    pub fn get_hook(&self) -> Result<Iterable<'a, FlowtableHookAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetflowtableDumpRequest::Hook(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetflowtableDumpRequest", "Hook"))
    }
    pub fn get_use(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetflowtableDumpRequest::Use(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetflowtableDumpRequest", "Use"))
    }
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetflowtableDumpRequest::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetflowtableDumpRequest", "Handle"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetflowtableDumpRequest::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetflowtableDumpRequest", "Pad"))
    }
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetflowtableDumpRequest::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetflowtableDumpRequest", "Flags"))
    }
}
impl<'a> OpGetflowtableDumpRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpGetflowtableDumpRequest<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        FlowtableAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpGetflowtableDumpRequest<'a>> {
    type Item = Result<OpGetflowtableDumpRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetflowtableDumpRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetflowtableDumpRequest::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetflowtableDumpRequest::Hook({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpGetflowtableDumpRequest::Use({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpGetflowtableDumpRequest::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpGetflowtableDumpRequest::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpGetflowtableDumpRequest::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpGetflowtableDumpRequest",
            r#type.and_then(|t| OpGetflowtableDumpRequest::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpGetflowtableDumpRequest<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetflowtableDumpRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetflowtableDumpRequest::Table(val) => fmt.field("Table", &val),
                OpGetflowtableDumpRequest::Name(val) => fmt.field("Name", &val),
                OpGetflowtableDumpRequest::Hook(val) => fmt.field("Hook", &val),
                OpGetflowtableDumpRequest::Use(val) => fmt.field("Use", &val),
                OpGetflowtableDumpRequest::Handle(val) => fmt.field("Handle", &val),
                OpGetflowtableDumpRequest::Pad(val) => fmt.field("Pad", &val),
                OpGetflowtableDumpRequest::Flags(val) => fmt.field("Flags", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpGetflowtableDumpRequest<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetflowtableDumpRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetflowtableDumpRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetflowtableDumpRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpGetflowtableDumpRequest::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpGetflowtableDumpRequest::Hook(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetflowtableDumpRequest::Use(val) => {
                    if last_off == offset {
                        stack.push(("Use", last_off));
                        break;
                    }
                }
                OpGetflowtableDumpRequest::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpGetflowtableDumpRequest::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                OpGetflowtableDumpRequest::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetflowtableDumpRequest", cur));
        }
        (stack, missing)
    }
}
#[doc = "Get / dump flow tables."]
pub struct PushOpGetflowtableDumpReply<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetflowtableDumpReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetflowtableDumpReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn nested_hook(mut self) -> PushFlowtableHookAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 3u16);
        PushFlowtableHookAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_use(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 5u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 6u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 7u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetflowtableDumpReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump flow tables."]
#[doc = "Original name: \"op-getflowtable-dump-reply\""]
#[derive(Clone)]
pub enum OpGetflowtableDumpReply<'a> {
    Table(&'a CStr),
    Name(&'a CStr),
    Hook(Iterable<'a, FlowtableHookAttrs<'a>>),
    Use(u32),
    Handle(u64),
    Pad(&'a [u8]),
    Flags(u32),
}
impl<'a> Iterable<'a, OpGetflowtableDumpReply<'a>> {
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetflowtableDumpReply::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetflowtableDumpReply", "Table"))
    }
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetflowtableDumpReply::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetflowtableDumpReply", "Name"))
    }
    pub fn get_hook(&self) -> Result<Iterable<'a, FlowtableHookAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetflowtableDumpReply::Hook(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetflowtableDumpReply", "Hook"))
    }
    pub fn get_use(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetflowtableDumpReply::Use(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetflowtableDumpReply", "Use"))
    }
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetflowtableDumpReply::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetflowtableDumpReply", "Handle"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetflowtableDumpReply::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetflowtableDumpReply", "Pad"))
    }
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetflowtableDumpReply::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetflowtableDumpReply", "Flags"))
    }
}
impl<'a> OpGetflowtableDumpReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpGetflowtableDumpReply<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        FlowtableAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpGetflowtableDumpReply<'a>> {
    type Item = Result<OpGetflowtableDumpReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetflowtableDumpReply::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetflowtableDumpReply::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetflowtableDumpReply::Hook({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpGetflowtableDumpReply::Use({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpGetflowtableDumpReply::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpGetflowtableDumpReply::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpGetflowtableDumpReply::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpGetflowtableDumpReply",
            r#type.and_then(|t| OpGetflowtableDumpReply::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpGetflowtableDumpReply<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetflowtableDumpReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetflowtableDumpReply::Table(val) => fmt.field("Table", &val),
                OpGetflowtableDumpReply::Name(val) => fmt.field("Name", &val),
                OpGetflowtableDumpReply::Hook(val) => fmt.field("Hook", &val),
                OpGetflowtableDumpReply::Use(val) => fmt.field("Use", &val),
                OpGetflowtableDumpReply::Handle(val) => fmt.field("Handle", &val),
                OpGetflowtableDumpReply::Pad(val) => fmt.field("Pad", &val),
                OpGetflowtableDumpReply::Flags(val) => fmt.field("Flags", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpGetflowtableDumpReply<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetflowtableDumpReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetflowtableDumpReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetflowtableDumpReply::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpGetflowtableDumpReply::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpGetflowtableDumpReply::Hook(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetflowtableDumpReply::Use(val) => {
                    if last_off == offset {
                        stack.push(("Use", last_off));
                        break;
                    }
                }
                OpGetflowtableDumpReply::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpGetflowtableDumpReply::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                OpGetflowtableDumpReply::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetflowtableDumpReply", cur));
        }
        (stack, missing)
    }
}
#[derive(Debug)]
pub struct RequestOpGetflowtableDumpRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpGetflowtableDumpRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpGetflowtableDumpRequest::write_header(&mut request.buf_mut(), header);
        Self {
            request: request.set_dump(),
        }
    }
    pub fn encode(&mut self) -> PushOpGetflowtableDumpRequest<&mut Vec<u8>> {
        PushOpGetflowtableDumpRequest::new_without_header(self.request.buf_mut())
    }
}
impl NetlinkRequest for RequestOpGetflowtableDumpRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, Iterable<'buf, OpGetflowtableDumpReply<'buf>>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2583u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpGetflowtableDumpReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpGetflowtableDumpRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Get / dump flow tables."]
pub struct PushOpGetflowtableDoRequest<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetflowtableDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetflowtableDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn nested_hook(mut self) -> PushFlowtableHookAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 3u16);
        PushFlowtableHookAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_use(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 5u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 6u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 7u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetflowtableDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump flow tables."]
#[doc = "Original name: \"op-getflowtable-do-request\""]
#[derive(Clone)]
pub enum OpGetflowtableDoRequest<'a> {
    Table(&'a CStr),
    Name(&'a CStr),
    Hook(Iterable<'a, FlowtableHookAttrs<'a>>),
    Use(u32),
    Handle(u64),
    Pad(&'a [u8]),
    Flags(u32),
}
impl<'a> Iterable<'a, OpGetflowtableDoRequest<'a>> {
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetflowtableDoRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetflowtableDoRequest", "Table"))
    }
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetflowtableDoRequest::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetflowtableDoRequest", "Name"))
    }
    pub fn get_hook(&self) -> Result<Iterable<'a, FlowtableHookAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetflowtableDoRequest::Hook(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetflowtableDoRequest", "Hook"))
    }
    pub fn get_use(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetflowtableDoRequest::Use(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetflowtableDoRequest", "Use"))
    }
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetflowtableDoRequest::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetflowtableDoRequest", "Handle"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetflowtableDoRequest::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetflowtableDoRequest", "Pad"))
    }
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetflowtableDoRequest::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetflowtableDoRequest", "Flags"))
    }
}
impl<'a> OpGetflowtableDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpGetflowtableDoRequest<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        FlowtableAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpGetflowtableDoRequest<'a>> {
    type Item = Result<OpGetflowtableDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetflowtableDoRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetflowtableDoRequest::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetflowtableDoRequest::Hook({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpGetflowtableDoRequest::Use({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpGetflowtableDoRequest::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpGetflowtableDoRequest::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpGetflowtableDoRequest::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpGetflowtableDoRequest",
            r#type.and_then(|t| OpGetflowtableDoRequest::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpGetflowtableDoRequest<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetflowtableDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetflowtableDoRequest::Table(val) => fmt.field("Table", &val),
                OpGetflowtableDoRequest::Name(val) => fmt.field("Name", &val),
                OpGetflowtableDoRequest::Hook(val) => fmt.field("Hook", &val),
                OpGetflowtableDoRequest::Use(val) => fmt.field("Use", &val),
                OpGetflowtableDoRequest::Handle(val) => fmt.field("Handle", &val),
                OpGetflowtableDoRequest::Pad(val) => fmt.field("Pad", &val),
                OpGetflowtableDoRequest::Flags(val) => fmt.field("Flags", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpGetflowtableDoRequest<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetflowtableDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetflowtableDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetflowtableDoRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpGetflowtableDoRequest::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpGetflowtableDoRequest::Hook(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetflowtableDoRequest::Use(val) => {
                    if last_off == offset {
                        stack.push(("Use", last_off));
                        break;
                    }
                }
                OpGetflowtableDoRequest::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpGetflowtableDoRequest::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                OpGetflowtableDoRequest::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetflowtableDoRequest", cur));
        }
        (stack, missing)
    }
}
#[doc = "Get / dump flow tables."]
pub struct PushOpGetflowtableDoReply<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetflowtableDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetflowtableDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn nested_hook(mut self) -> PushFlowtableHookAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 3u16);
        PushFlowtableHookAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_use(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 5u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 6u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 7u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetflowtableDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump flow tables."]
#[doc = "Original name: \"op-getflowtable-do-reply\""]
#[derive(Clone)]
pub enum OpGetflowtableDoReply<'a> {
    Table(&'a CStr),
    Name(&'a CStr),
    Hook(Iterable<'a, FlowtableHookAttrs<'a>>),
    Use(u32),
    Handle(u64),
    Pad(&'a [u8]),
    Flags(u32),
}
impl<'a> Iterable<'a, OpGetflowtableDoReply<'a>> {
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetflowtableDoReply::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetflowtableDoReply", "Table"))
    }
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetflowtableDoReply::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetflowtableDoReply", "Name"))
    }
    pub fn get_hook(&self) -> Result<Iterable<'a, FlowtableHookAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetflowtableDoReply::Hook(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetflowtableDoReply", "Hook"))
    }
    pub fn get_use(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetflowtableDoReply::Use(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetflowtableDoReply", "Use"))
    }
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetflowtableDoReply::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetflowtableDoReply", "Handle"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetflowtableDoReply::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetflowtableDoReply", "Pad"))
    }
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetflowtableDoReply::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetflowtableDoReply", "Flags"))
    }
}
impl<'a> OpGetflowtableDoReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpGetflowtableDoReply<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        FlowtableAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpGetflowtableDoReply<'a>> {
    type Item = Result<OpGetflowtableDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetflowtableDoReply::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetflowtableDoReply::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetflowtableDoReply::Hook({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpGetflowtableDoReply::Use({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpGetflowtableDoReply::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpGetflowtableDoReply::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpGetflowtableDoReply::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpGetflowtableDoReply",
            r#type.and_then(|t| OpGetflowtableDoReply::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpGetflowtableDoReply<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetflowtableDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetflowtableDoReply::Table(val) => fmt.field("Table", &val),
                OpGetflowtableDoReply::Name(val) => fmt.field("Name", &val),
                OpGetflowtableDoReply::Hook(val) => fmt.field("Hook", &val),
                OpGetflowtableDoReply::Use(val) => fmt.field("Use", &val),
                OpGetflowtableDoReply::Handle(val) => fmt.field("Handle", &val),
                OpGetflowtableDoReply::Pad(val) => fmt.field("Pad", &val),
                OpGetflowtableDoReply::Flags(val) => fmt.field("Flags", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpGetflowtableDoReply<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetflowtableDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetflowtableDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetflowtableDoReply::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpGetflowtableDoReply::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpGetflowtableDoReply::Hook(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetflowtableDoReply::Use(val) => {
                    if last_off == offset {
                        stack.push(("Use", last_off));
                        break;
                    }
                }
                OpGetflowtableDoReply::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpGetflowtableDoReply::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                OpGetflowtableDoReply::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetflowtableDoReply", cur));
        }
        (stack, missing)
    }
}
#[derive(Debug)]
pub struct RequestOpGetflowtableDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpGetflowtableDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpGetflowtableDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpGetflowtableDoRequest<&mut Vec<u8>> {
        PushOpGetflowtableDoRequest::new_without_header(self.request.buf_mut())
    }
}
impl NetlinkRequest for RequestOpGetflowtableDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, Iterable<'buf, OpGetflowtableDoReply<'buf>>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2583u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpGetflowtableDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpGetflowtableDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Delete an existing flow table."]
pub struct PushOpDelflowtableDoRequest<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDelflowtableDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDelflowtableDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn nested_hook(mut self) -> PushFlowtableHookAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 3u16);
        PushFlowtableHookAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_use(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 5u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 6u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 7u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpDelflowtableDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete an existing flow table."]
#[doc = "Original name: \"op-delflowtable-do-request\""]
#[derive(Clone)]
pub enum OpDelflowtableDoRequest<'a> {
    Table(&'a CStr),
    Name(&'a CStr),
    Hook(Iterable<'a, FlowtableHookAttrs<'a>>),
    Use(u32),
    Handle(u64),
    Pad(&'a [u8]),
    Flags(u32),
}
impl<'a> Iterable<'a, OpDelflowtableDoRequest<'a>> {
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelflowtableDoRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelflowtableDoRequest", "Table"))
    }
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelflowtableDoRequest::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelflowtableDoRequest", "Name"))
    }
    pub fn get_hook(&self) -> Result<Iterable<'a, FlowtableHookAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelflowtableDoRequest::Hook(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelflowtableDoRequest", "Hook"))
    }
    pub fn get_use(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelflowtableDoRequest::Use(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelflowtableDoRequest", "Use"))
    }
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelflowtableDoRequest::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelflowtableDoRequest", "Handle"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelflowtableDoRequest::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelflowtableDoRequest", "Pad"))
    }
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelflowtableDoRequest::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelflowtableDoRequest", "Flags"))
    }
}
impl<'a> OpDelflowtableDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpDelflowtableDoRequest<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        FlowtableAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpDelflowtableDoRequest<'a>> {
    type Item = Result<OpDelflowtableDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpDelflowtableDoRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpDelflowtableDoRequest::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpDelflowtableDoRequest::Hook({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpDelflowtableDoRequest::Use({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpDelflowtableDoRequest::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpDelflowtableDoRequest::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpDelflowtableDoRequest::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpDelflowtableDoRequest",
            r#type.and_then(|t| OpDelflowtableDoRequest::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpDelflowtableDoRequest<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDelflowtableDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpDelflowtableDoRequest::Table(val) => fmt.field("Table", &val),
                OpDelflowtableDoRequest::Name(val) => fmt.field("Name", &val),
                OpDelflowtableDoRequest::Hook(val) => fmt.field("Hook", &val),
                OpDelflowtableDoRequest::Use(val) => fmt.field("Use", &val),
                OpDelflowtableDoRequest::Handle(val) => fmt.field("Handle", &val),
                OpDelflowtableDoRequest::Pad(val) => fmt.field("Pad", &val),
                OpDelflowtableDoRequest::Flags(val) => fmt.field("Flags", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpDelflowtableDoRequest<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpDelflowtableDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDelflowtableDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpDelflowtableDoRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpDelflowtableDoRequest::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpDelflowtableDoRequest::Hook(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpDelflowtableDoRequest::Use(val) => {
                    if last_off == offset {
                        stack.push(("Use", last_off));
                        break;
                    }
                }
                OpDelflowtableDoRequest::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpDelflowtableDoRequest::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                OpDelflowtableDoRequest::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpDelflowtableDoRequest", cur));
        }
        (stack, missing)
    }
}
#[doc = "Delete an existing flow table."]
pub struct PushOpDelflowtableDoReply<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDelflowtableDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDelflowtableDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn nested_hook(mut self) -> PushFlowtableHookAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 3u16);
        PushFlowtableHookAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_use(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 5u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 6u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 7u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpDelflowtableDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete an existing flow table."]
#[doc = "Original name: \"op-delflowtable-do-reply\""]
#[derive(Clone)]
pub enum OpDelflowtableDoReply<'a> {
    Table(&'a CStr),
    Name(&'a CStr),
    Hook(Iterable<'a, FlowtableHookAttrs<'a>>),
    Use(u32),
    Handle(u64),
    Pad(&'a [u8]),
    Flags(u32),
}
impl<'a> Iterable<'a, OpDelflowtableDoReply<'a>> {
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelflowtableDoReply::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelflowtableDoReply", "Table"))
    }
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelflowtableDoReply::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelflowtableDoReply", "Name"))
    }
    pub fn get_hook(&self) -> Result<Iterable<'a, FlowtableHookAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelflowtableDoReply::Hook(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelflowtableDoReply", "Hook"))
    }
    pub fn get_use(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelflowtableDoReply::Use(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelflowtableDoReply", "Use"))
    }
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelflowtableDoReply::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelflowtableDoReply", "Handle"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelflowtableDoReply::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelflowtableDoReply", "Pad"))
    }
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelflowtableDoReply::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelflowtableDoReply", "Flags"))
    }
}
impl<'a> OpDelflowtableDoReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpDelflowtableDoReply<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        FlowtableAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpDelflowtableDoReply<'a>> {
    type Item = Result<OpDelflowtableDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpDelflowtableDoReply::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpDelflowtableDoReply::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpDelflowtableDoReply::Hook({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpDelflowtableDoReply::Use({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpDelflowtableDoReply::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpDelflowtableDoReply::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpDelflowtableDoReply::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpDelflowtableDoReply",
            r#type.and_then(|t| OpDelflowtableDoReply::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpDelflowtableDoReply<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDelflowtableDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpDelflowtableDoReply::Table(val) => fmt.field("Table", &val),
                OpDelflowtableDoReply::Name(val) => fmt.field("Name", &val),
                OpDelflowtableDoReply::Hook(val) => fmt.field("Hook", &val),
                OpDelflowtableDoReply::Use(val) => fmt.field("Use", &val),
                OpDelflowtableDoReply::Handle(val) => fmt.field("Handle", &val),
                OpDelflowtableDoReply::Pad(val) => fmt.field("Pad", &val),
                OpDelflowtableDoReply::Flags(val) => fmt.field("Flags", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpDelflowtableDoReply<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpDelflowtableDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDelflowtableDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpDelflowtableDoReply::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpDelflowtableDoReply::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpDelflowtableDoReply::Hook(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpDelflowtableDoReply::Use(val) => {
                    if last_off == offset {
                        stack.push(("Use", last_off));
                        break;
                    }
                }
                OpDelflowtableDoReply::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpDelflowtableDoReply::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                OpDelflowtableDoReply::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpDelflowtableDoReply", cur));
        }
        (stack, missing)
    }
}
#[derive(Debug)]
pub struct RequestOpDelflowtableDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpDelflowtableDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpDelflowtableDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpDelflowtableDoRequest<&mut Vec<u8>> {
        PushOpDelflowtableDoRequest::new_without_header(self.request.buf_mut())
    }
}
impl NetlinkRequest for RequestOpDelflowtableDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, Iterable<'buf, OpDelflowtableDoReply<'buf>>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2584u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpDelflowtableDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpDelflowtableDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Delete an existing flow table with destroy semantics."]
pub struct PushOpDestroyflowtableDoRequest<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDestroyflowtableDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDestroyflowtableDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn nested_hook(mut self) -> PushFlowtableHookAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 3u16);
        PushFlowtableHookAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_use(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 5u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 6u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 7u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpDestroyflowtableDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete an existing flow table with destroy semantics."]
#[doc = "Original name: \"op-destroyflowtable-do-request\""]
#[derive(Clone)]
pub enum OpDestroyflowtableDoRequest<'a> {
    Table(&'a CStr),
    Name(&'a CStr),
    Hook(Iterable<'a, FlowtableHookAttrs<'a>>),
    Use(u32),
    Handle(u64),
    Pad(&'a [u8]),
    Flags(u32),
}
impl<'a> Iterable<'a, OpDestroyflowtableDoRequest<'a>> {
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyflowtableDoRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroyflowtableDoRequest", "Table"))
    }
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyflowtableDoRequest::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroyflowtableDoRequest", "Name"))
    }
    pub fn get_hook(&self) -> Result<Iterable<'a, FlowtableHookAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyflowtableDoRequest::Hook(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroyflowtableDoRequest", "Hook"))
    }
    pub fn get_use(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyflowtableDoRequest::Use(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroyflowtableDoRequest", "Use"))
    }
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyflowtableDoRequest::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroyflowtableDoRequest", "Handle"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyflowtableDoRequest::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroyflowtableDoRequest", "Pad"))
    }
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyflowtableDoRequest::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroyflowtableDoRequest", "Flags"))
    }
}
impl<'a> OpDestroyflowtableDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpDestroyflowtableDoRequest<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        FlowtableAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpDestroyflowtableDoRequest<'a>> {
    type Item = Result<OpDestroyflowtableDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpDestroyflowtableDoRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpDestroyflowtableDoRequest::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpDestroyflowtableDoRequest::Hook({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpDestroyflowtableDoRequest::Use({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpDestroyflowtableDoRequest::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpDestroyflowtableDoRequest::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpDestroyflowtableDoRequest::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpDestroyflowtableDoRequest",
            r#type.and_then(|t| OpDestroyflowtableDoRequest::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpDestroyflowtableDoRequest<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDestroyflowtableDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpDestroyflowtableDoRequest::Table(val) => fmt.field("Table", &val),
                OpDestroyflowtableDoRequest::Name(val) => fmt.field("Name", &val),
                OpDestroyflowtableDoRequest::Hook(val) => fmt.field("Hook", &val),
                OpDestroyflowtableDoRequest::Use(val) => fmt.field("Use", &val),
                OpDestroyflowtableDoRequest::Handle(val) => fmt.field("Handle", &val),
                OpDestroyflowtableDoRequest::Pad(val) => fmt.field("Pad", &val),
                OpDestroyflowtableDoRequest::Flags(val) => fmt.field("Flags", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpDestroyflowtableDoRequest<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpDestroyflowtableDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDestroyflowtableDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpDestroyflowtableDoRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpDestroyflowtableDoRequest::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpDestroyflowtableDoRequest::Hook(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpDestroyflowtableDoRequest::Use(val) => {
                    if last_off == offset {
                        stack.push(("Use", last_off));
                        break;
                    }
                }
                OpDestroyflowtableDoRequest::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpDestroyflowtableDoRequest::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                OpDestroyflowtableDoRequest::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpDestroyflowtableDoRequest", cur));
        }
        (stack, missing)
    }
}
#[doc = "Delete an existing flow table with destroy semantics."]
pub struct PushOpDestroyflowtableDoReply<Prev: Rec> {
    prev: Option<Prev>,
    header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDestroyflowtableDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDestroyflowtableDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn nested_hook(mut self) -> PushFlowtableHookAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 3u16);
        PushFlowtableHookAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_use(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 5u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 6u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 7u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpDestroyflowtableDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete an existing flow table with destroy semantics."]
#[doc = "Original name: \"op-destroyflowtable-do-reply\""]
#[derive(Clone)]
pub enum OpDestroyflowtableDoReply<'a> {
    Table(&'a CStr),
    Name(&'a CStr),
    Hook(Iterable<'a, FlowtableHookAttrs<'a>>),
    Use(u32),
    Handle(u64),
    Pad(&'a [u8]),
    Flags(u32),
}
impl<'a> Iterable<'a, OpDestroyflowtableDoReply<'a>> {
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyflowtableDoReply::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroyflowtableDoReply", "Table"))
    }
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyflowtableDoReply::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroyflowtableDoReply", "Name"))
    }
    pub fn get_hook(&self) -> Result<Iterable<'a, FlowtableHookAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyflowtableDoReply::Hook(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroyflowtableDoReply", "Hook"))
    }
    pub fn get_use(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyflowtableDoReply::Use(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroyflowtableDoReply", "Use"))
    }
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyflowtableDoReply::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroyflowtableDoReply", "Handle"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyflowtableDoReply::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroyflowtableDoReply", "Pad"))
    }
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyflowtableDoReply::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDestroyflowtableDoReply", "Flags"))
    }
}
impl<'a> OpDestroyflowtableDoReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, Iterable<'a, OpDestroyflowtableDoReply<'a>>) {
        let mut header = PushNfgenmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushNfgenmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushNfgenmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        FlowtableAttrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpDestroyflowtableDoReply<'a>> {
    type Item = Result<OpDestroyflowtableDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpDestroyflowtableDoReply::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpDestroyflowtableDoReply::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpDestroyflowtableDoReply::Hook({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpDestroyflowtableDoReply::Use({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpDestroyflowtableDoReply::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpDestroyflowtableDoReply::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpDestroyflowtableDoReply::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpDestroyflowtableDoReply",
            r#type.and_then(|t| OpDestroyflowtableDoReply::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpDestroyflowtableDoReply<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDestroyflowtableDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpDestroyflowtableDoReply::Table(val) => fmt.field("Table", &val),
                OpDestroyflowtableDoReply::Name(val) => fmt.field("Name", &val),
                OpDestroyflowtableDoReply::Hook(val) => fmt.field("Hook", &val),
                OpDestroyflowtableDoReply::Use(val) => fmt.field("Use", &val),
                OpDestroyflowtableDoReply::Handle(val) => fmt.field("Handle", &val),
                OpDestroyflowtableDoReply::Pad(val) => fmt.field("Pad", &val),
                OpDestroyflowtableDoReply::Flags(val) => fmt.field("Flags", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpDestroyflowtableDoReply<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpDestroyflowtableDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDestroyflowtableDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpDestroyflowtableDoReply::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpDestroyflowtableDoReply::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpDestroyflowtableDoReply::Hook(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpDestroyflowtableDoReply::Use(val) => {
                    if last_off == offset {
                        stack.push(("Use", last_off));
                        break;
                    }
                }
                OpDestroyflowtableDoReply::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpDestroyflowtableDoReply::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                OpDestroyflowtableDoReply::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpDestroyflowtableDoReply", cur));
        }
        (stack, missing)
    }
}
#[derive(Debug)]
pub struct RequestOpDestroyflowtableDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpDestroyflowtableDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpDestroyflowtableDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpDestroyflowtableDoRequest<&mut Vec<u8>> {
        PushOpDestroyflowtableDoRequest::new_without_header(self.request.buf_mut())
    }
}
impl NetlinkRequest for RequestOpDestroyflowtableDoRequest<'_> {
    type ReplyType<'buf> = (
        PushNfgenmsg,
        Iterable<'buf, OpDestroyflowtableDoReply<'buf>>,
    );
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2592u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpDestroyflowtableDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpDestroyflowtableDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[derive(Debug)]
enum RequestBuf<'buf> {
    Ref(&'buf mut Vec<u8>),
    Own(Vec<u8>),
}
#[derive(Debug)]
pub struct Request<'buf> {
    buf: RequestBuf<'buf>,
    flags: u16,
}
impl Request<'static> {
    pub fn new() -> Self {
        Self {
            flags: 0,
            buf: RequestBuf::Own(Vec::new()),
        }
    }
    pub fn from_buf(buf: Vec<u8>) -> Self {
        Self {
            flags: 0,
            buf: RequestBuf::Own(buf),
        }
    }
    pub fn into_buf(self) -> Vec<u8> {
        match self.buf {
            RequestBuf::Own(buf) => buf,
            _ => unreachable!(),
        }
    }
}
impl<'buf> Request<'buf> {
    pub fn new_with_buf(buf: &'buf mut Vec<u8>) -> Self {
        buf.clear();
        Self {
            flags: 0,
            buf: RequestBuf::Ref(buf),
        }
    }
    fn buf(&self) -> &Vec<u8> {
        match &self.buf {
            RequestBuf::Ref(buf) => buf,
            RequestBuf::Own(buf) => buf,
        }
    }
    fn buf_mut(&mut self) -> &mut Vec<u8> {
        match &mut self.buf {
            RequestBuf::Ref(buf) => buf,
            RequestBuf::Own(buf) => buf,
        }
    }
    #[doc = "Set [`libc::NLM_F_CREATE`] flag"]
    pub fn set_create(mut self) -> Self {
        self.flags |= consts::NLM_F_CREATE as u16;
        self
    }
    #[doc = "Set [`libc::NLM_F_EXCL`] flag"]
    pub fn set_excl(mut self) -> Self {
        self.flags |= consts::NLM_F_EXCL as u16;
        self
    }
    #[doc = "Set [`libc::NLM_F_REPLACE`] flag"]
    pub fn set_replace(mut self) -> Self {
        self.flags |= consts::NLM_F_REPLACE as u16;
        self
    }
    #[doc = "Set [`libc::NLM_F_CREATE`] and [`libc::NLM_F_REPLACE`] flag"]
    pub fn set_change(self) -> Self {
        self.set_create().set_replace()
    }
    #[doc = "Set [`libc::NLM_F_APPEND`] flag"]
    pub fn set_append(mut self) -> Self {
        self.flags |= consts::NLM_F_APPEND as u16;
        self
    }
    #[doc = "Set [`libc::NLM_F_DUMP`] flag"]
    fn set_dump(mut self) -> Self {
        self.flags |= consts::NLM_F_DUMP as u16;
        self
    }
    pub fn op_compat_get_dump_request(
        self,
        header: &PushNfgenmsg,
    ) -> RequestOpCompatGetDumpRequest<'buf> {
        RequestOpCompatGetDumpRequest::new(self, header)
    }
    pub fn op_compat_get_do_request(
        self,
        header: &PushNfgenmsg,
    ) -> RequestOpCompatGetDoRequest<'buf> {
        RequestOpCompatGetDoRequest::new(self, header)
    }
    pub fn op_batch_begin_do_request(
        self,
        header: &PushNfgenmsg,
    ) -> RequestOpBatchBeginDoRequest<'buf> {
        RequestOpBatchBeginDoRequest::new(self, header)
    }
    pub fn op_batch_end_do_request(
        self,
        header: &PushNfgenmsg,
    ) -> RequestOpBatchEndDoRequest<'buf> {
        RequestOpBatchEndDoRequest::new(self, header)
    }
    pub fn op_newtable_do_request(self, header: &PushNfgenmsg) -> RequestOpNewtableDoRequest<'buf> {
        RequestOpNewtableDoRequest::new(self, header)
    }
    pub fn op_gettable_dump_request(
        self,
        header: &PushNfgenmsg,
    ) -> RequestOpGettableDumpRequest<'buf> {
        RequestOpGettableDumpRequest::new(self, header)
    }
    pub fn op_gettable_do_request(self, header: &PushNfgenmsg) -> RequestOpGettableDoRequest<'buf> {
        RequestOpGettableDoRequest::new(self, header)
    }
    pub fn op_deltable_do_request(self, header: &PushNfgenmsg) -> RequestOpDeltableDoRequest<'buf> {
        RequestOpDeltableDoRequest::new(self, header)
    }
    pub fn op_destroytable_do_request(
        self,
        header: &PushNfgenmsg,
    ) -> RequestOpDestroytableDoRequest<'buf> {
        RequestOpDestroytableDoRequest::new(self, header)
    }
    pub fn op_newchain_do_request(self, header: &PushNfgenmsg) -> RequestOpNewchainDoRequest<'buf> {
        RequestOpNewchainDoRequest::new(self, header)
    }
    pub fn op_getchain_dump_request(
        self,
        header: &PushNfgenmsg,
    ) -> RequestOpGetchainDumpRequest<'buf> {
        RequestOpGetchainDumpRequest::new(self, header)
    }
    pub fn op_getchain_do_request(self, header: &PushNfgenmsg) -> RequestOpGetchainDoRequest<'buf> {
        RequestOpGetchainDoRequest::new(self, header)
    }
    pub fn op_delchain_do_request(self, header: &PushNfgenmsg) -> RequestOpDelchainDoRequest<'buf> {
        RequestOpDelchainDoRequest::new(self, header)
    }
    pub fn op_destroychain_do_request(
        self,
        header: &PushNfgenmsg,
    ) -> RequestOpDestroychainDoRequest<'buf> {
        RequestOpDestroychainDoRequest::new(self, header)
    }
    pub fn op_newrule_do_request(self, header: &PushNfgenmsg) -> RequestOpNewruleDoRequest<'buf> {
        RequestOpNewruleDoRequest::new(self, header)
    }
    pub fn op_getrule_dump_request(
        self,
        header: &PushNfgenmsg,
    ) -> RequestOpGetruleDumpRequest<'buf> {
        RequestOpGetruleDumpRequest::new(self, header)
    }
    pub fn op_getrule_do_request(self, header: &PushNfgenmsg) -> RequestOpGetruleDoRequest<'buf> {
        RequestOpGetruleDoRequest::new(self, header)
    }
    pub fn op_getrule_reset_dump_request(
        self,
        header: &PushNfgenmsg,
    ) -> RequestOpGetruleResetDumpRequest<'buf> {
        RequestOpGetruleResetDumpRequest::new(self, header)
    }
    pub fn op_getrule_reset_do_request(
        self,
        header: &PushNfgenmsg,
    ) -> RequestOpGetruleResetDoRequest<'buf> {
        RequestOpGetruleResetDoRequest::new(self, header)
    }
    pub fn op_delrule_do_request(self, header: &PushNfgenmsg) -> RequestOpDelruleDoRequest<'buf> {
        RequestOpDelruleDoRequest::new(self, header)
    }
    pub fn op_destroyrule_do_request(
        self,
        header: &PushNfgenmsg,
    ) -> RequestOpDestroyruleDoRequest<'buf> {
        RequestOpDestroyruleDoRequest::new(self, header)
    }
    pub fn op_newset_do_request(self, header: &PushNfgenmsg) -> RequestOpNewsetDoRequest<'buf> {
        RequestOpNewsetDoRequest::new(self, header)
    }
    pub fn op_getset_dump_request(self, header: &PushNfgenmsg) -> RequestOpGetsetDumpRequest<'buf> {
        RequestOpGetsetDumpRequest::new(self, header)
    }
    pub fn op_getset_do_request(self, header: &PushNfgenmsg) -> RequestOpGetsetDoRequest<'buf> {
        RequestOpGetsetDoRequest::new(self, header)
    }
    pub fn op_delset_do_request(self, header: &PushNfgenmsg) -> RequestOpDelsetDoRequest<'buf> {
        RequestOpDelsetDoRequest::new(self, header)
    }
    pub fn op_destroyset_do_request(
        self,
        header: &PushNfgenmsg,
    ) -> RequestOpDestroysetDoRequest<'buf> {
        RequestOpDestroysetDoRequest::new(self, header)
    }
    pub fn op_newsetelem_do_request(
        self,
        header: &PushNfgenmsg,
    ) -> RequestOpNewsetelemDoRequest<'buf> {
        RequestOpNewsetelemDoRequest::new(self, header)
    }
    pub fn op_getsetelem_dump_request(
        self,
        header: &PushNfgenmsg,
    ) -> RequestOpGetsetelemDumpRequest<'buf> {
        RequestOpGetsetelemDumpRequest::new(self, header)
    }
    pub fn op_getsetelem_do_request(
        self,
        header: &PushNfgenmsg,
    ) -> RequestOpGetsetelemDoRequest<'buf> {
        RequestOpGetsetelemDoRequest::new(self, header)
    }
    pub fn op_getsetelem_reset_dump_request(
        self,
        header: &PushNfgenmsg,
    ) -> RequestOpGetsetelemResetDumpRequest<'buf> {
        RequestOpGetsetelemResetDumpRequest::new(self, header)
    }
    pub fn op_getsetelem_reset_do_request(
        self,
        header: &PushNfgenmsg,
    ) -> RequestOpGetsetelemResetDoRequest<'buf> {
        RequestOpGetsetelemResetDoRequest::new(self, header)
    }
    pub fn op_delsetelem_do_request(
        self,
        header: &PushNfgenmsg,
    ) -> RequestOpDelsetelemDoRequest<'buf> {
        RequestOpDelsetelemDoRequest::new(self, header)
    }
    pub fn op_destroysetelem_do_request(
        self,
        header: &PushNfgenmsg,
    ) -> RequestOpDestroysetelemDoRequest<'buf> {
        RequestOpDestroysetelemDoRequest::new(self, header)
    }
    pub fn op_getgen_dump_request(self, header: &PushNfgenmsg) -> RequestOpGetgenDumpRequest<'buf> {
        RequestOpGetgenDumpRequest::new(self, header)
    }
    pub fn op_getgen_do_request(self, header: &PushNfgenmsg) -> RequestOpGetgenDoRequest<'buf> {
        RequestOpGetgenDoRequest::new(self, header)
    }
    pub fn op_newobj_do_request(self, header: &PushNfgenmsg) -> RequestOpNewobjDoRequest<'buf> {
        RequestOpNewobjDoRequest::new(self, header)
    }
    pub fn op_getobj_dump_request(self, header: &PushNfgenmsg) -> RequestOpGetobjDumpRequest<'buf> {
        RequestOpGetobjDumpRequest::new(self, header)
    }
    pub fn op_getobj_do_request(self, header: &PushNfgenmsg) -> RequestOpGetobjDoRequest<'buf> {
        RequestOpGetobjDoRequest::new(self, header)
    }
    pub fn op_delobj_do_request(self, header: &PushNfgenmsg) -> RequestOpDelobjDoRequest<'buf> {
        RequestOpDelobjDoRequest::new(self, header)
    }
    pub fn op_destroyobj_do_request(
        self,
        header: &PushNfgenmsg,
    ) -> RequestOpDestroyobjDoRequest<'buf> {
        RequestOpDestroyobjDoRequest::new(self, header)
    }
    pub fn op_newflowtable_do_request(
        self,
        header: &PushNfgenmsg,
    ) -> RequestOpNewflowtableDoRequest<'buf> {
        RequestOpNewflowtableDoRequest::new(self, header)
    }
    pub fn op_getflowtable_dump_request(
        self,
        header: &PushNfgenmsg,
    ) -> RequestOpGetflowtableDumpRequest<'buf> {
        RequestOpGetflowtableDumpRequest::new(self, header)
    }
    pub fn op_getflowtable_do_request(
        self,
        header: &PushNfgenmsg,
    ) -> RequestOpGetflowtableDoRequest<'buf> {
        RequestOpGetflowtableDoRequest::new(self, header)
    }
    pub fn op_delflowtable_do_request(
        self,
        header: &PushNfgenmsg,
    ) -> RequestOpDelflowtableDoRequest<'buf> {
        RequestOpDelflowtableDoRequest::new(self, header)
    }
    pub fn op_destroyflowtable_do_request(
        self,
        header: &PushNfgenmsg,
    ) -> RequestOpDestroyflowtableDoRequest<'buf> {
        RequestOpDestroyflowtableDoRequest::new(self, header)
    }
}
