#![doc = "Netlink raw family for tc qdisc, chain, class and filter configuration over rtnetlink."]
#![allow(clippy::all)]
#![allow(unused_imports)]
#![allow(unused_assignments)]
#![allow(non_snake_case)]
#![allow(unused_variables)]
#![allow(irrefutable_let_patterns)]
#![allow(unreachable_code)]
#![allow(unreachable_patterns)]
use crate::builtin::{PushBuiltinBitfield32, PushBuiltinNfgenmsg, PushDummy, PushNlmsghdr};
use crate::consts;
use crate::utils::*;
use crate::{NetlinkRequest, Protocol};
pub const PROTONAME: &CStr = c"tc";
pub const PROTONUM: u16 = 0u16;
#[doc = "Original name: \"cls-flags\" (flags) - defines an integer enumeration, with values for each entry occupying a bit, starting from bit 0, (e.g. 1, 2, 4, 8)"]
#[derive(Debug, Clone, Copy)]
pub enum ClsFlags {
    SkipHw = 1 << 0,
    SkipSw = 1 << 1,
    InHw = 1 << 2,
    NotInNw = 1 << 3,
    Verbose = 1 << 4,
}
impl ClsFlags {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            n if n == 1 << 0 => Self::SkipHw,
            n if n == 1 << 1 => Self::SkipSw,
            n if n == 1 << 2 => Self::InHw,
            n if n == 1 << 3 => Self::NotInNw,
            n if n == 1 << 4 => Self::Verbose,
            _ => return None,
        })
    }
}
#[doc = "Original name: \"flower-key-ctrl-flags\" (flags) - defines an integer enumeration, with values for each entry occupying a bit, starting from bit 0, (e.g. 1, 2, 4, 8)"]
#[derive(Debug, Clone, Copy)]
pub enum FlowerKeyCtrlFlags {
    Frag = 1 << 0,
    Firstfrag = 1 << 1,
    Tuncsum = 1 << 2,
    Tundf = 1 << 3,
    Tunoam = 1 << 4,
    Tuncrit = 1 << 5,
}
impl FlowerKeyCtrlFlags {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            n if n == 1 << 0 => Self::Frag,
            n if n == 1 << 1 => Self::Firstfrag,
            n if n == 1 << 2 => Self::Tuncsum,
            n if n == 1 << 3 => Self::Tundf,
            n if n == 1 << 4 => Self::Tunoam,
            n if n == 1 << 5 => Self::Tuncrit,
            _ => return None,
        })
    }
}
#[doc = "Original name: \"dualpi2-drop-overload\" (enum) - defines an integer enumeration, with values for each entry incrementing by 1, (e.g. 0, 1, 2, 3)"]
#[derive(Debug, Clone, Copy)]
pub enum Dualpi2DropOverload {
    Overflow = 0,
    Drop = 1,
}
impl Dualpi2DropOverload {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            0 => Self::Overflow,
            1 => Self::Drop,
            _ => return None,
        })
    }
}
#[doc = "Original name: \"dualpi2-drop-early\" (enum) - defines an integer enumeration, with values for each entry incrementing by 1, (e.g. 0, 1, 2, 3)"]
#[derive(Debug, Clone, Copy)]
pub enum Dualpi2DropEarly {
    DropDequeue = 0,
    DropEnqueue = 1,
}
impl Dualpi2DropEarly {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            0 => Self::DropDequeue,
            1 => Self::DropEnqueue,
            _ => return None,
        })
    }
}
#[doc = "Original name: \"dualpi2-ecn-mask\" (enum) - defines an integer enumeration, with values for each entry incrementing by 1, (e.g. 0, 1, 2, 3)"]
#[derive(Debug, Clone, Copy)]
pub enum Dualpi2EcnMask {
    L4sEct = 1,
    ClaEct = 2,
    AnyEct = 3,
}
impl Dualpi2EcnMask {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            1 => Self::L4sEct,
            2 => Self::ClaEct,
            3 => Self::AnyEct,
            _ => return None,
        })
    }
}
#[doc = "Original name: \"dualpi2-split-gso\" (enum) - defines an integer enumeration, with values for each entry incrementing by 1, (e.g. 0, 1, 2, 3)"]
#[derive(Debug, Clone, Copy)]
pub enum Dualpi2SplitGso {
    NoSplitGso = 0,
    SplitGso = 1,
}
impl Dualpi2SplitGso {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            0 => Self::NoSplitGso,
            1 => Self::SplitGso,
            _ => return None,
        })
    }
}
#[doc = "State transition probabilities for 4 state model"]
#[doc = "Gilbert-Elliot models"]
#[doc = "Original name: \"attrs\""]
#[derive(Clone)]
pub enum Attrs<'a> {
    Kind(&'a CStr),
    Options(OptionsMsg<'a>),
    Stats(PushTcStats),
    Xstats(TcaStatsAppMsg<'a>),
    Rate(PushGnetEstimator),
    Fcnt(u32),
    Stats2(Iterable<'a, TcaStatsAttrs<'a>>),
    Stab(Iterable<'a, TcaStabAttrs<'a>>),
    Pad(&'a [u8]),
    DumpInvisible(()),
    Chain(u32),
    HwOffload(u8),
    IngressBlock(u32),
    EgressBlock(u32),
    DumpFlags(PushBuiltinBitfield32),
    ExtWarnMsg(&'a CStr),
}
impl<'a> Iterable<'a, Attrs<'a>> {
    pub fn get_kind(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Attrs::Kind(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("Attrs", "Kind"))
    }
    pub fn get_options(&self) -> Result<OptionsMsg<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Attrs::Options(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("Attrs", "Options"))
    }
    pub fn get_stats(&self) -> Result<PushTcStats, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Attrs::Stats(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("Attrs", "Stats"))
    }
    pub fn get_xstats(&self) -> Result<TcaStatsAppMsg<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Attrs::Xstats(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("Attrs", "Xstats"))
    }
    pub fn get_rate(&self) -> Result<PushGnetEstimator, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Attrs::Rate(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("Attrs", "Rate"))
    }
    pub fn get_fcnt(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Attrs::Fcnt(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("Attrs", "Fcnt"))
    }
    pub fn get_stats2(&self) -> Result<Iterable<'a, TcaStatsAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Attrs::Stats2(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("Attrs", "Stats2"))
    }
    pub fn get_stab(&self) -> Result<Iterable<'a, TcaStabAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Attrs::Stab(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("Attrs", "Stab"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Attrs::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("Attrs", "Pad"))
    }
    pub fn get_dump_invisible(&self) -> Result<(), ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Attrs::DumpInvisible(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("Attrs", "DumpInvisible"))
    }
    pub fn get_chain(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Attrs::Chain(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("Attrs", "Chain"))
    }
    pub fn get_hw_offload(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Attrs::HwOffload(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("Attrs", "HwOffload"))
    }
    pub fn get_ingress_block(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Attrs::IngressBlock(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("Attrs", "IngressBlock"))
    }
    pub fn get_egress_block(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Attrs::EgressBlock(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("Attrs", "EgressBlock"))
    }
    pub fn get_dump_flags(&self) -> Result<PushBuiltinBitfield32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Attrs::DumpFlags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("Attrs", "DumpFlags"))
    }
    pub fn get_ext_warn_msg(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Attrs::ExtWarnMsg(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("Attrs", "ExtWarnMsg"))
    }
}
#[doc = "Original name: \"options-msg\""]
#[derive(Debug, Clone)]
pub enum OptionsMsg<'a> {
    Basic(Iterable<'a, BasicAttrs<'a>>),
    Bpf(Iterable<'a, BpfAttrs<'a>>),
    Bfifo(PushTcFifoQopt),
    Cake(Iterable<'a, CakeAttrs<'a>>),
    Cbs(Iterable<'a, CbsAttrs>),
    Cgroup(Iterable<'a, CgroupAttrs<'a>>),
    Choke(Iterable<'a, ChokeAttrs<'a>>),
    Clsact(),
    Codel(Iterable<'a, CodelAttrs>),
    Drr(Iterable<'a, DrrAttrs>),
    Dualpi2(Iterable<'a, Dualpi2Attrs>),
    Etf(Iterable<'a, EtfAttrs>),
    Ets(Iterable<'a, EtsAttrs<'a>>),
    Flow(Iterable<'a, FlowAttrs<'a>>),
    Flower(Iterable<'a, FlowerAttrs<'a>>),
    Fq(Iterable<'a, FqAttrs<'a>>),
    FqCodel(Iterable<'a, FqCodelAttrs>),
    FqPie(Iterable<'a, FqPieAttrs>),
    Fw(Iterable<'a, FwAttrs<'a>>),
    Gred(Iterable<'a, GredAttrs<'a>>),
    Hfsc(PushTcHfscQopt),
    Hhf(Iterable<'a, HhfAttrs>),
    Htb(Iterable<'a, HtbAttrs<'a>>),
    Ingress(),
    Matchall(Iterable<'a, MatchallAttrs<'a>>),
    Mq(),
    Mqprio(PushTcMqprioQopt),
    Multiq(PushTcMultiqQopt),
    Netem(PushTcNetemQopt, Iterable<'a, NetemAttrs<'a>>),
    Pfifo(PushTcFifoQopt),
    PfifoFast(PushTcPrioQopt),
    PfifoHeadDrop(PushTcFifoQopt),
    Pie(Iterable<'a, PieAttrs>),
    Plug(PushTcPlugQopt),
    Prio(PushTcPrioQopt),
    Qfq(Iterable<'a, QfqAttrs>),
    Red(Iterable<'a, RedAttrs<'a>>),
    Route(Iterable<'a, RouteAttrs<'a>>),
    Sfb(PushTcSfbQopt),
    Sfq(PushTcSfqQoptV1),
    Taprio(Iterable<'a, TaprioAttrs<'a>>),
    Tbf(Iterable<'a, TbfAttrs<'a>>),
    U32(Iterable<'a, U32Attrs<'a>>),
}
impl<'a> OptionsMsg<'a> {
    fn select_with_loc(selector: &'a CStr, buf: &'a [u8], loc: usize) -> Option<Self> {
        match selector.to_bytes() {
            b"basic" => Some(OptionsMsg::Basic(Iterable::with_loc(buf, loc))),
            b"bpf" => Some(OptionsMsg::Bpf(Iterable::with_loc(buf, loc))),
            b"bfifo" => Some(OptionsMsg::Bfifo(PushTcFifoQopt::new_from_slice(buf)?)),
            b"cake" => Some(OptionsMsg::Cake(Iterable::with_loc(buf, loc))),
            b"cbs" => Some(OptionsMsg::Cbs(Iterable::with_loc(buf, loc))),
            b"cgroup" => Some(OptionsMsg::Cgroup(Iterable::with_loc(buf, loc))),
            b"choke" => Some(OptionsMsg::Choke(Iterable::with_loc(buf, loc))),
            b"codel" => Some(OptionsMsg::Codel(Iterable::with_loc(buf, loc))),
            b"drr" => Some(OptionsMsg::Drr(Iterable::with_loc(buf, loc))),
            b"dualpi2" => Some(OptionsMsg::Dualpi2(Iterable::with_loc(buf, loc))),
            b"etf" => Some(OptionsMsg::Etf(Iterable::with_loc(buf, loc))),
            b"ets" => Some(OptionsMsg::Ets(Iterable::with_loc(buf, loc))),
            b"flow" => Some(OptionsMsg::Flow(Iterable::with_loc(buf, loc))),
            b"flower" => Some(OptionsMsg::Flower(Iterable::with_loc(buf, loc))),
            b"fq" => Some(OptionsMsg::Fq(Iterable::with_loc(buf, loc))),
            b"fq_codel" => Some(OptionsMsg::FqCodel(Iterable::with_loc(buf, loc))),
            b"fq_pie" => Some(OptionsMsg::FqPie(Iterable::with_loc(buf, loc))),
            b"fw" => Some(OptionsMsg::Fw(Iterable::with_loc(buf, loc))),
            b"gred" => Some(OptionsMsg::Gred(Iterable::with_loc(buf, loc))),
            b"hfsc" => Some(OptionsMsg::Hfsc(PushTcHfscQopt::new_from_slice(buf)?)),
            b"hhf" => Some(OptionsMsg::Hhf(Iterable::with_loc(buf, loc))),
            b"htb" => Some(OptionsMsg::Htb(Iterable::with_loc(buf, loc))),
            b"matchall" => Some(OptionsMsg::Matchall(Iterable::with_loc(buf, loc))),
            b"mqprio" => Some(OptionsMsg::Mqprio(PushTcMqprioQopt::new_from_slice(buf)?)),
            b"multiq" => Some(OptionsMsg::Multiq(PushTcMultiqQopt::new_from_slice(buf)?)),
            b"netem" => Some(OptionsMsg::Netem(
                PushTcNetemQopt::new_from_slice(&buf[..PushTcNetemQopt::len()])?,
                Iterable::with_loc(&buf[PushTcNetemQopt::len()..], loc),
            )),
            b"pfifo" => Some(OptionsMsg::Pfifo(PushTcFifoQopt::new_from_slice(buf)?)),
            b"pfifo_fast" => Some(OptionsMsg::PfifoFast(PushTcPrioQopt::new_from_slice(buf)?)),
            b"pfifo_head_drop" => Some(OptionsMsg::PfifoHeadDrop(PushTcFifoQopt::new_from_slice(
                buf,
            )?)),
            b"pie" => Some(OptionsMsg::Pie(Iterable::with_loc(buf, loc))),
            b"plug" => Some(OptionsMsg::Plug(PushTcPlugQopt::new_from_slice(buf)?)),
            b"prio" => Some(OptionsMsg::Prio(PushTcPrioQopt::new_from_slice(buf)?)),
            b"qfq" => Some(OptionsMsg::Qfq(Iterable::with_loc(buf, loc))),
            b"red" => Some(OptionsMsg::Red(Iterable::with_loc(buf, loc))),
            b"route" => Some(OptionsMsg::Route(Iterable::with_loc(buf, loc))),
            b"sfb" => Some(OptionsMsg::Sfb(PushTcSfbQopt::new_from_slice(buf)?)),
            b"sfq" => Some(OptionsMsg::Sfq(PushTcSfqQoptV1::new_from_slice(buf)?)),
            b"taprio" => Some(OptionsMsg::Taprio(Iterable::with_loc(buf, loc))),
            b"tbf" => Some(OptionsMsg::Tbf(Iterable::with_loc(buf, loc))),
            b"u32" => Some(OptionsMsg::U32(Iterable::with_loc(buf, loc))),
            _ => None,
        }
    }
}
#[doc = "Original name: \"tca-stats-app-msg\""]
#[derive(Debug, Clone)]
pub enum TcaStatsAppMsg<'a> {
    Cake(Iterable<'a, CakeStatsAttrs<'a>>),
    Choke(PushTcChokeXstats),
    Codel(PushTcCodelXstats),
    Dualpi2(PushTcDualpi2Xstats),
    Fq(PushTcFqQdStats),
    FqCodel(PushTcFqCodelXstats),
    FqPie(PushTcFqPieXstats),
    Hhf(PushTcHhfXstats),
    Pie(PushTcPieXstats),
    Red(PushTcRedXstats),
    Sfb(PushTcSfbXstats),
    Sfq(PushTcSfqXstats),
}
impl<'a> TcaStatsAppMsg<'a> {
    fn select_with_loc(selector: &'a CStr, buf: &'a [u8], loc: usize) -> Option<Self> {
        match selector.to_bytes() {
            b"cake" => Some(TcaStatsAppMsg::Cake(Iterable::with_loc(buf, loc))),
            b"choke" => Some(TcaStatsAppMsg::Choke(PushTcChokeXstats::new_from_slice(
                buf,
            )?)),
            b"codel" => Some(TcaStatsAppMsg::Codel(PushTcCodelXstats::new_from_slice(
                buf,
            )?)),
            b"dualpi2" => Some(TcaStatsAppMsg::Dualpi2(
                PushTcDualpi2Xstats::new_from_slice(buf)?,
            )),
            b"fq" => Some(TcaStatsAppMsg::Fq(PushTcFqQdStats::new_from_slice(buf)?)),
            b"fq_codel" => Some(TcaStatsAppMsg::FqCodel(
                PushTcFqCodelXstats::new_from_slice(buf)?,
            )),
            b"fq_pie" => Some(TcaStatsAppMsg::FqPie(PushTcFqPieXstats::new_from_slice(
                buf,
            )?)),
            b"hhf" => Some(TcaStatsAppMsg::Hhf(PushTcHhfXstats::new_from_slice(buf)?)),
            b"pie" => Some(TcaStatsAppMsg::Pie(PushTcPieXstats::new_from_slice(buf)?)),
            b"red" => Some(TcaStatsAppMsg::Red(PushTcRedXstats::new_from_slice(buf)?)),
            b"sfb" => Some(TcaStatsAppMsg::Sfb(PushTcSfbXstats::new_from_slice(buf)?)),
            b"sfq" => Some(TcaStatsAppMsg::Sfq(PushTcSfqXstats::new_from_slice(buf)?)),
            _ => None,
        }
    }
}
impl<'a> Attrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, Attrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Kind",
            2u16 => "Options",
            3u16 => "Stats",
            4u16 => "Xstats",
            5u16 => "Rate",
            6u16 => "Fcnt",
            7u16 => "Stats2",
            8u16 => "Stab",
            9u16 => "Pad",
            10u16 => "DumpInvisible",
            11u16 => "Chain",
            12u16 => "HwOffload",
            13u16 => "IngressBlock",
            14u16 => "EgressBlock",
            15u16 => "DumpFlags",
            16u16 => "ExtWarnMsg",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, Attrs<'a>> {
    type Item = Result<Attrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => Attrs::Kind({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => Attrs::Options({
                    let res = {
                        let Ok(selector) = self.get_kind() else { break };
                        OptionsMsg::select_with_loc(selector, next, self.orig_loc)
                    };
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => Attrs::Stats({
                    let res = PushTcStats::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => Attrs::Xstats({
                    let res = {
                        let Ok(selector) = self.get_kind() else { break };
                        TcaStatsAppMsg::select_with_loc(selector, next, self.orig_loc)
                    };
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => Attrs::Rate({
                    let res = PushGnetEstimator::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => Attrs::Fcnt({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => Attrs::Stats2({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => Attrs::Stab({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => Attrs::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => Attrs::DumpInvisible(()),
                11u16 => Attrs::Chain({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                12u16 => Attrs::HwOffload({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                13u16 => Attrs::IngressBlock({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                14u16 => Attrs::EgressBlock({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                15u16 => Attrs::DumpFlags({
                    let res = PushBuiltinBitfield32::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                16u16 => Attrs::ExtWarnMsg({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "Attrs",
            r#type.and_then(|t| Attrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, Attrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("Attrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                Attrs::Kind(val) => fmt.field("Kind", &val),
                Attrs::Options(val) => fmt.field("Options", &val),
                Attrs::Stats(val) => fmt.field("Stats", &val),
                Attrs::Xstats(val) => fmt.field("Xstats", &val),
                Attrs::Rate(val) => fmt.field("Rate", &val),
                Attrs::Fcnt(val) => fmt.field("Fcnt", &val),
                Attrs::Stats2(val) => fmt.field("Stats2", &val),
                Attrs::Stab(val) => fmt.field("Stab", &val),
                Attrs::Pad(val) => fmt.field("Pad", &val),
                Attrs::DumpInvisible(val) => fmt.field("DumpInvisible", &val),
                Attrs::Chain(val) => fmt.field("Chain", &val),
                Attrs::HwOffload(val) => fmt.field("HwOffload", &val),
                Attrs::IngressBlock(val) => fmt.field("IngressBlock", &val),
                Attrs::EgressBlock(val) => fmt.field("EgressBlock", &val),
                Attrs::DumpFlags(val) => fmt.field("DumpFlags", &val),
                Attrs::ExtWarnMsg(val) => fmt.field("ExtWarnMsg", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, Attrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("Attrs", offset));
            return (stack, missing_type.and_then(|t| Attrs::attr_from_type(t)));
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                Attrs::Kind(val) => {
                    if last_off == offset {
                        stack.push(("Kind", last_off));
                        break;
                    }
                }
                Attrs::Options(val) => {
                    if last_off == offset {
                        stack.push(("Options", last_off));
                        break;
                    }
                }
                Attrs::Stats(val) => {
                    if last_off == offset {
                        stack.push(("Stats", last_off));
                        break;
                    }
                }
                Attrs::Xstats(val) => {
                    if last_off == offset {
                        stack.push(("Xstats", last_off));
                        break;
                    }
                }
                Attrs::Rate(val) => {
                    if last_off == offset {
                        stack.push(("Rate", last_off));
                        break;
                    }
                }
                Attrs::Fcnt(val) => {
                    if last_off == offset {
                        stack.push(("Fcnt", last_off));
                        break;
                    }
                }
                Attrs::Stats2(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                Attrs::Stab(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                Attrs::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                Attrs::DumpInvisible(val) => {
                    if last_off == offset {
                        stack.push(("DumpInvisible", last_off));
                        break;
                    }
                }
                Attrs::Chain(val) => {
                    if last_off == offset {
                        stack.push(("Chain", last_off));
                        break;
                    }
                }
                Attrs::HwOffload(val) => {
                    if last_off == offset {
                        stack.push(("HwOffload", last_off));
                        break;
                    }
                }
                Attrs::IngressBlock(val) => {
                    if last_off == offset {
                        stack.push(("IngressBlock", last_off));
                        break;
                    }
                }
                Attrs::EgressBlock(val) => {
                    if last_off == offset {
                        stack.push(("EgressBlock", last_off));
                        break;
                    }
                }
                Attrs::DumpFlags(val) => {
                    if last_off == offset {
                        stack.push(("DumpFlags", last_off));
                        break;
                    }
                }
                Attrs::ExtWarnMsg(val) => {
                    if last_off == offset {
                        stack.push(("ExtWarnMsg", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("Attrs", cur));
        }
        (stack, missing)
    }
}
#[doc = "Original name: \"act-attrs\""]
#[derive(Clone)]
pub enum ActAttrs<'a> {
    Kind(&'a CStr),
    Options(ActOptionsMsg<'a>),
    Index(u32),
    Stats(Iterable<'a, TcaStatsAttrs<'a>>),
    Pad(&'a [u8]),
    Cookie(&'a [u8]),
    Flags(PushBuiltinBitfield32),
    HwStats(PushBuiltinBitfield32),
    UsedHwStats(PushBuiltinBitfield32),
    InHwCount(u32),
}
impl<'a> Iterable<'a, ActAttrs<'a>> {
    pub fn get_kind(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActAttrs::Kind(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActAttrs", "Kind"))
    }
    pub fn get_options(&self) -> Result<ActOptionsMsg<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActAttrs::Options(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActAttrs", "Options"))
    }
    pub fn get_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActAttrs::Index(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActAttrs", "Index"))
    }
    pub fn get_stats(&self) -> Result<Iterable<'a, TcaStatsAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActAttrs::Stats(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActAttrs", "Stats"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActAttrs::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActAttrs", "Pad"))
    }
    pub fn get_cookie(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActAttrs::Cookie(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActAttrs", "Cookie"))
    }
    pub fn get_flags(&self) -> Result<PushBuiltinBitfield32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActAttrs::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActAttrs", "Flags"))
    }
    pub fn get_hw_stats(&self) -> Result<PushBuiltinBitfield32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActAttrs::HwStats(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActAttrs", "HwStats"))
    }
    pub fn get_used_hw_stats(&self) -> Result<PushBuiltinBitfield32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActAttrs::UsedHwStats(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActAttrs", "UsedHwStats"))
    }
    pub fn get_in_hw_count(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActAttrs::InHwCount(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActAttrs", "InHwCount"))
    }
}
#[doc = "Original name: \"act-options-msg\""]
#[derive(Debug, Clone)]
pub enum ActOptionsMsg<'a> {
    Bpf(Iterable<'a, ActBpfAttrs<'a>>),
    Connmark(Iterable<'a, ActConnmarkAttrs<'a>>),
    Csum(Iterable<'a, ActCsumAttrs<'a>>),
    Ct(Iterable<'a, ActCtAttrs<'a>>),
    Ctinfo(Iterable<'a, ActCtinfoAttrs<'a>>),
    Gact(Iterable<'a, ActGactAttrs<'a>>),
    Gate(Iterable<'a, ActGateAttrs<'a>>),
    Ife(Iterable<'a, ActIfeAttrs<'a>>),
    Mirred(Iterable<'a, ActMirredAttrs<'a>>),
    Mpls(Iterable<'a, ActMplsAttrs<'a>>),
    Nat(Iterable<'a, ActNatAttrs<'a>>),
    Pedit(Iterable<'a, ActPeditAttrs<'a>>),
    Police(Iterable<'a, PoliceAttrs<'a>>),
    Sample(Iterable<'a, ActSampleAttrs<'a>>),
    Simple(Iterable<'a, ActSimpleAttrs<'a>>),
    Skbedit(Iterable<'a, ActSkbeditAttrs<'a>>),
    Skbmod(Iterable<'a, ActSkbmodAttrs<'a>>),
    TunnelKey(Iterable<'a, ActTunnelKeyAttrs<'a>>),
    Vlan(Iterable<'a, ActVlanAttrs<'a>>),
}
impl<'a> ActOptionsMsg<'a> {
    fn select_with_loc(selector: &'a CStr, buf: &'a [u8], loc: usize) -> Option<Self> {
        match selector.to_bytes() {
            b"bpf" => Some(ActOptionsMsg::Bpf(Iterable::with_loc(buf, loc))),
            b"connmark" => Some(ActOptionsMsg::Connmark(Iterable::with_loc(buf, loc))),
            b"csum" => Some(ActOptionsMsg::Csum(Iterable::with_loc(buf, loc))),
            b"ct" => Some(ActOptionsMsg::Ct(Iterable::with_loc(buf, loc))),
            b"ctinfo" => Some(ActOptionsMsg::Ctinfo(Iterable::with_loc(buf, loc))),
            b"gact" => Some(ActOptionsMsg::Gact(Iterable::with_loc(buf, loc))),
            b"gate" => Some(ActOptionsMsg::Gate(Iterable::with_loc(buf, loc))),
            b"ife" => Some(ActOptionsMsg::Ife(Iterable::with_loc(buf, loc))),
            b"mirred" => Some(ActOptionsMsg::Mirred(Iterable::with_loc(buf, loc))),
            b"mpls" => Some(ActOptionsMsg::Mpls(Iterable::with_loc(buf, loc))),
            b"nat" => Some(ActOptionsMsg::Nat(Iterable::with_loc(buf, loc))),
            b"pedit" => Some(ActOptionsMsg::Pedit(Iterable::with_loc(buf, loc))),
            b"police" => Some(ActOptionsMsg::Police(Iterable::with_loc(buf, loc))),
            b"sample" => Some(ActOptionsMsg::Sample(Iterable::with_loc(buf, loc))),
            b"simple" => Some(ActOptionsMsg::Simple(Iterable::with_loc(buf, loc))),
            b"skbedit" => Some(ActOptionsMsg::Skbedit(Iterable::with_loc(buf, loc))),
            b"skbmod" => Some(ActOptionsMsg::Skbmod(Iterable::with_loc(buf, loc))),
            b"tunnel_key" => Some(ActOptionsMsg::TunnelKey(Iterable::with_loc(buf, loc))),
            b"vlan" => Some(ActOptionsMsg::Vlan(Iterable::with_loc(buf, loc))),
            _ => None,
        }
    }
}
impl<'a> ActAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, ActAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Kind",
            2u16 => "Options",
            3u16 => "Index",
            4u16 => "Stats",
            5u16 => "Pad",
            6u16 => "Cookie",
            7u16 => "Flags",
            8u16 => "HwStats",
            9u16 => "UsedHwStats",
            10u16 => "InHwCount",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, ActAttrs<'a>> {
    type Item = Result<ActAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => ActAttrs::Kind({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => ActAttrs::Options({
                    let res = {
                        let Ok(selector) = self.get_kind() else { break };
                        ActOptionsMsg::select_with_loc(selector, next, self.orig_loc)
                    };
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => ActAttrs::Index({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => ActAttrs::Stats({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => ActAttrs::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => ActAttrs::Cookie({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => ActAttrs::Flags({
                    let res = PushBuiltinBitfield32::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => ActAttrs::HwStats({
                    let res = PushBuiltinBitfield32::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => ActAttrs::UsedHwStats({
                    let res = PushBuiltinBitfield32::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => ActAttrs::InHwCount({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "ActAttrs",
            r#type.and_then(|t| ActAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, ActAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("ActAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                ActAttrs::Kind(val) => fmt.field("Kind", &val),
                ActAttrs::Options(val) => fmt.field("Options", &val),
                ActAttrs::Index(val) => fmt.field("Index", &val),
                ActAttrs::Stats(val) => fmt.field("Stats", &val),
                ActAttrs::Pad(val) => fmt.field("Pad", &val),
                ActAttrs::Cookie(val) => fmt.field("Cookie", &val),
                ActAttrs::Flags(val) => fmt.field("Flags", &val),
                ActAttrs::HwStats(val) => fmt.field("HwStats", &val),
                ActAttrs::UsedHwStats(val) => fmt.field("UsedHwStats", &val),
                ActAttrs::InHwCount(val) => fmt.field("InHwCount", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, ActAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("ActAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| ActAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                ActAttrs::Kind(val) => {
                    if last_off == offset {
                        stack.push(("Kind", last_off));
                        break;
                    }
                }
                ActAttrs::Options(val) => {
                    if last_off == offset {
                        stack.push(("Options", last_off));
                        break;
                    }
                }
                ActAttrs::Index(val) => {
                    if last_off == offset {
                        stack.push(("Index", last_off));
                        break;
                    }
                }
                ActAttrs::Stats(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                ActAttrs::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                ActAttrs::Cookie(val) => {
                    if last_off == offset {
                        stack.push(("Cookie", last_off));
                        break;
                    }
                }
                ActAttrs::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                ActAttrs::HwStats(val) => {
                    if last_off == offset {
                        stack.push(("HwStats", last_off));
                        break;
                    }
                }
                ActAttrs::UsedHwStats(val) => {
                    if last_off == offset {
                        stack.push(("UsedHwStats", last_off));
                        break;
                    }
                }
                ActAttrs::InHwCount(val) => {
                    if last_off == offset {
                        stack.push(("InHwCount", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("ActAttrs", cur));
        }
        (stack, missing)
    }
}
#[doc = "Original name: \"act-bpf-attrs\""]
#[derive(Clone)]
pub enum ActBpfAttrs<'a> {
    Tm(PushTcfT),
    Parms(&'a [u8]),
    OpsLen(u16),
    Ops(&'a [u8]),
    Fd(u32),
    Name(&'a CStr),
    Pad(&'a [u8]),
    Tag(&'a [u8]),
    Id(&'a [u8]),
}
impl<'a> Iterable<'a, ActBpfAttrs<'a>> {
    pub fn get_tm(&self) -> Result<PushTcfT, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActBpfAttrs::Tm(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActBpfAttrs", "Tm"))
    }
    pub fn get_parms(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActBpfAttrs::Parms(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActBpfAttrs", "Parms"))
    }
    pub fn get_ops_len(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActBpfAttrs::OpsLen(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActBpfAttrs", "OpsLen"))
    }
    pub fn get_ops(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActBpfAttrs::Ops(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActBpfAttrs", "Ops"))
    }
    pub fn get_fd(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActBpfAttrs::Fd(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActBpfAttrs", "Fd"))
    }
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActBpfAttrs::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActBpfAttrs", "Name"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActBpfAttrs::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActBpfAttrs", "Pad"))
    }
    pub fn get_tag(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActBpfAttrs::Tag(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActBpfAttrs", "Tag"))
    }
    pub fn get_id(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActBpfAttrs::Id(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActBpfAttrs", "Id"))
    }
}
impl<'a> ActBpfAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, ActBpfAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Tm",
            2u16 => "Parms",
            3u16 => "OpsLen",
            4u16 => "Ops",
            5u16 => "Fd",
            6u16 => "Name",
            7u16 => "Pad",
            8u16 => "Tag",
            9u16 => "Id",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, ActBpfAttrs<'a>> {
    type Item = Result<ActBpfAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => ActBpfAttrs::Tm({
                    let res = PushTcfT::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => ActBpfAttrs::Parms({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => ActBpfAttrs::OpsLen({
                    let res = parse_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => ActBpfAttrs::Ops({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => ActBpfAttrs::Fd({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => ActBpfAttrs::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => ActBpfAttrs::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => ActBpfAttrs::Tag({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => ActBpfAttrs::Id({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "ActBpfAttrs",
            r#type.and_then(|t| ActBpfAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, ActBpfAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("ActBpfAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                ActBpfAttrs::Tm(val) => fmt.field("Tm", &val),
                ActBpfAttrs::Parms(val) => fmt.field("Parms", &val),
                ActBpfAttrs::OpsLen(val) => fmt.field("OpsLen", &val),
                ActBpfAttrs::Ops(val) => fmt.field("Ops", &val),
                ActBpfAttrs::Fd(val) => fmt.field("Fd", &val),
                ActBpfAttrs::Name(val) => fmt.field("Name", &val),
                ActBpfAttrs::Pad(val) => fmt.field("Pad", &val),
                ActBpfAttrs::Tag(val) => fmt.field("Tag", &val),
                ActBpfAttrs::Id(val) => fmt.field("Id", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, ActBpfAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("ActBpfAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| ActBpfAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                ActBpfAttrs::Tm(val) => {
                    if last_off == offset {
                        stack.push(("Tm", last_off));
                        break;
                    }
                }
                ActBpfAttrs::Parms(val) => {
                    if last_off == offset {
                        stack.push(("Parms", last_off));
                        break;
                    }
                }
                ActBpfAttrs::OpsLen(val) => {
                    if last_off == offset {
                        stack.push(("OpsLen", last_off));
                        break;
                    }
                }
                ActBpfAttrs::Ops(val) => {
                    if last_off == offset {
                        stack.push(("Ops", last_off));
                        break;
                    }
                }
                ActBpfAttrs::Fd(val) => {
                    if last_off == offset {
                        stack.push(("Fd", last_off));
                        break;
                    }
                }
                ActBpfAttrs::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                ActBpfAttrs::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                ActBpfAttrs::Tag(val) => {
                    if last_off == offset {
                        stack.push(("Tag", last_off));
                        break;
                    }
                }
                ActBpfAttrs::Id(val) => {
                    if last_off == offset {
                        stack.push(("Id", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("ActBpfAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"act-connmark-attrs\""]
#[derive(Clone)]
pub enum ActConnmarkAttrs<'a> {
    Parms(&'a [u8]),
    Tm(PushTcfT),
    Pad(&'a [u8]),
}
impl<'a> Iterable<'a, ActConnmarkAttrs<'a>> {
    pub fn get_parms(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActConnmarkAttrs::Parms(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActConnmarkAttrs", "Parms"))
    }
    pub fn get_tm(&self) -> Result<PushTcfT, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActConnmarkAttrs::Tm(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActConnmarkAttrs", "Tm"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActConnmarkAttrs::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActConnmarkAttrs", "Pad"))
    }
}
impl<'a> ActConnmarkAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, ActConnmarkAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Parms",
            2u16 => "Tm",
            3u16 => "Pad",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, ActConnmarkAttrs<'a>> {
    type Item = Result<ActConnmarkAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => ActConnmarkAttrs::Parms({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => ActConnmarkAttrs::Tm({
                    let res = PushTcfT::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => ActConnmarkAttrs::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "ActConnmarkAttrs",
            r#type.and_then(|t| ActConnmarkAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, ActConnmarkAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("ActConnmarkAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                ActConnmarkAttrs::Parms(val) => fmt.field("Parms", &val),
                ActConnmarkAttrs::Tm(val) => fmt.field("Tm", &val),
                ActConnmarkAttrs::Pad(val) => fmt.field("Pad", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, ActConnmarkAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("ActConnmarkAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| ActConnmarkAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                ActConnmarkAttrs::Parms(val) => {
                    if last_off == offset {
                        stack.push(("Parms", last_off));
                        break;
                    }
                }
                ActConnmarkAttrs::Tm(val) => {
                    if last_off == offset {
                        stack.push(("Tm", last_off));
                        break;
                    }
                }
                ActConnmarkAttrs::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("ActConnmarkAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"act-csum-attrs\""]
#[derive(Clone)]
pub enum ActCsumAttrs<'a> {
    Parms(&'a [u8]),
    Tm(PushTcfT),
    Pad(&'a [u8]),
}
impl<'a> Iterable<'a, ActCsumAttrs<'a>> {
    pub fn get_parms(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActCsumAttrs::Parms(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActCsumAttrs", "Parms"))
    }
    pub fn get_tm(&self) -> Result<PushTcfT, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActCsumAttrs::Tm(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActCsumAttrs", "Tm"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActCsumAttrs::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActCsumAttrs", "Pad"))
    }
}
impl<'a> ActCsumAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, ActCsumAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Parms",
            2u16 => "Tm",
            3u16 => "Pad",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, ActCsumAttrs<'a>> {
    type Item = Result<ActCsumAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => ActCsumAttrs::Parms({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => ActCsumAttrs::Tm({
                    let res = PushTcfT::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => ActCsumAttrs::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "ActCsumAttrs",
            r#type.and_then(|t| ActCsumAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, ActCsumAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("ActCsumAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                ActCsumAttrs::Parms(val) => fmt.field("Parms", &val),
                ActCsumAttrs::Tm(val) => fmt.field("Tm", &val),
                ActCsumAttrs::Pad(val) => fmt.field("Pad", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, ActCsumAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("ActCsumAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| ActCsumAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                ActCsumAttrs::Parms(val) => {
                    if last_off == offset {
                        stack.push(("Parms", last_off));
                        break;
                    }
                }
                ActCsumAttrs::Tm(val) => {
                    if last_off == offset {
                        stack.push(("Tm", last_off));
                        break;
                    }
                }
                ActCsumAttrs::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("ActCsumAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"act-ct-attrs\""]
#[derive(Clone)]
pub enum ActCtAttrs<'a> {
    Parms(&'a [u8]),
    Tm(PushTcfT),
    Action(u16),
    Zone(u16),
    Mark(u32),
    MarkMask(u32),
    Labels(&'a [u8]),
    LabelsMask(&'a [u8]),
    NatIpv4Min(u32),
    NatIpv4Max(u32),
    NatIpv6Min(&'a [u8]),
    NatIpv6Max(&'a [u8]),
    NatPortMin(u16),
    NatPortMax(u16),
    Pad(&'a [u8]),
    HelperName(&'a CStr),
    HelperFamily(u8),
    HelperProto(u8),
}
impl<'a> Iterable<'a, ActCtAttrs<'a>> {
    pub fn get_parms(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActCtAttrs::Parms(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActCtAttrs", "Parms"))
    }
    pub fn get_tm(&self) -> Result<PushTcfT, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActCtAttrs::Tm(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActCtAttrs", "Tm"))
    }
    pub fn get_action(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActCtAttrs::Action(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActCtAttrs", "Action"))
    }
    pub fn get_zone(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActCtAttrs::Zone(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActCtAttrs", "Zone"))
    }
    pub fn get_mark(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActCtAttrs::Mark(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActCtAttrs", "Mark"))
    }
    pub fn get_mark_mask(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActCtAttrs::MarkMask(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActCtAttrs", "MarkMask"))
    }
    pub fn get_labels(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActCtAttrs::Labels(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActCtAttrs", "Labels"))
    }
    pub fn get_labels_mask(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActCtAttrs::LabelsMask(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActCtAttrs", "LabelsMask"))
    }
    pub fn get_nat_ipv4_min(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActCtAttrs::NatIpv4Min(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActCtAttrs", "NatIpv4Min"))
    }
    pub fn get_nat_ipv4_max(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActCtAttrs::NatIpv4Max(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActCtAttrs", "NatIpv4Max"))
    }
    pub fn get_nat_ipv6_min(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActCtAttrs::NatIpv6Min(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActCtAttrs", "NatIpv6Min"))
    }
    pub fn get_nat_ipv6_max(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActCtAttrs::NatIpv6Max(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActCtAttrs", "NatIpv6Max"))
    }
    pub fn get_nat_port_min(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActCtAttrs::NatPortMin(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActCtAttrs", "NatPortMin"))
    }
    pub fn get_nat_port_max(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActCtAttrs::NatPortMax(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActCtAttrs", "NatPortMax"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActCtAttrs::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActCtAttrs", "Pad"))
    }
    pub fn get_helper_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActCtAttrs::HelperName(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActCtAttrs", "HelperName"))
    }
    pub fn get_helper_family(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActCtAttrs::HelperFamily(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActCtAttrs", "HelperFamily"))
    }
    pub fn get_helper_proto(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActCtAttrs::HelperProto(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActCtAttrs", "HelperProto"))
    }
}
impl<'a> ActCtAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, ActCtAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Parms",
            2u16 => "Tm",
            3u16 => "Action",
            4u16 => "Zone",
            5u16 => "Mark",
            6u16 => "MarkMask",
            7u16 => "Labels",
            8u16 => "LabelsMask",
            9u16 => "NatIpv4Min",
            10u16 => "NatIpv4Max",
            11u16 => "NatIpv6Min",
            12u16 => "NatIpv6Max",
            13u16 => "NatPortMin",
            14u16 => "NatPortMax",
            15u16 => "Pad",
            16u16 => "HelperName",
            17u16 => "HelperFamily",
            18u16 => "HelperProto",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, ActCtAttrs<'a>> {
    type Item = Result<ActCtAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => ActCtAttrs::Parms({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => ActCtAttrs::Tm({
                    let res = PushTcfT::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => ActCtAttrs::Action({
                    let res = parse_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => ActCtAttrs::Zone({
                    let res = parse_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => ActCtAttrs::Mark({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => ActCtAttrs::MarkMask({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => ActCtAttrs::Labels({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => ActCtAttrs::LabelsMask({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => ActCtAttrs::NatIpv4Min({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => ActCtAttrs::NatIpv4Max({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => ActCtAttrs::NatIpv6Min({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                12u16 => ActCtAttrs::NatIpv6Max({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                13u16 => ActCtAttrs::NatPortMin({
                    let res = parse_be_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                14u16 => ActCtAttrs::NatPortMax({
                    let res = parse_be_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                15u16 => ActCtAttrs::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                16u16 => ActCtAttrs::HelperName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                17u16 => ActCtAttrs::HelperFamily({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                18u16 => ActCtAttrs::HelperProto({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "ActCtAttrs",
            r#type.and_then(|t| ActCtAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, ActCtAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("ActCtAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                ActCtAttrs::Parms(val) => fmt.field("Parms", &val),
                ActCtAttrs::Tm(val) => fmt.field("Tm", &val),
                ActCtAttrs::Action(val) => fmt.field("Action", &val),
                ActCtAttrs::Zone(val) => fmt.field("Zone", &val),
                ActCtAttrs::Mark(val) => fmt.field("Mark", &val),
                ActCtAttrs::MarkMask(val) => fmt.field("MarkMask", &val),
                ActCtAttrs::Labels(val) => fmt.field("Labels", &val),
                ActCtAttrs::LabelsMask(val) => fmt.field("LabelsMask", &val),
                ActCtAttrs::NatIpv4Min(val) => fmt.field("NatIpv4Min", &val),
                ActCtAttrs::NatIpv4Max(val) => fmt.field("NatIpv4Max", &val),
                ActCtAttrs::NatIpv6Min(val) => fmt.field("NatIpv6Min", &val),
                ActCtAttrs::NatIpv6Max(val) => fmt.field("NatIpv6Max", &val),
                ActCtAttrs::NatPortMin(val) => fmt.field("NatPortMin", &val),
                ActCtAttrs::NatPortMax(val) => fmt.field("NatPortMax", &val),
                ActCtAttrs::Pad(val) => fmt.field("Pad", &val),
                ActCtAttrs::HelperName(val) => fmt.field("HelperName", &val),
                ActCtAttrs::HelperFamily(val) => fmt.field("HelperFamily", &val),
                ActCtAttrs::HelperProto(val) => fmt.field("HelperProto", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, ActCtAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("ActCtAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| ActCtAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                ActCtAttrs::Parms(val) => {
                    if last_off == offset {
                        stack.push(("Parms", last_off));
                        break;
                    }
                }
                ActCtAttrs::Tm(val) => {
                    if last_off == offset {
                        stack.push(("Tm", last_off));
                        break;
                    }
                }
                ActCtAttrs::Action(val) => {
                    if last_off == offset {
                        stack.push(("Action", last_off));
                        break;
                    }
                }
                ActCtAttrs::Zone(val) => {
                    if last_off == offset {
                        stack.push(("Zone", last_off));
                        break;
                    }
                }
                ActCtAttrs::Mark(val) => {
                    if last_off == offset {
                        stack.push(("Mark", last_off));
                        break;
                    }
                }
                ActCtAttrs::MarkMask(val) => {
                    if last_off == offset {
                        stack.push(("MarkMask", last_off));
                        break;
                    }
                }
                ActCtAttrs::Labels(val) => {
                    if last_off == offset {
                        stack.push(("Labels", last_off));
                        break;
                    }
                }
                ActCtAttrs::LabelsMask(val) => {
                    if last_off == offset {
                        stack.push(("LabelsMask", last_off));
                        break;
                    }
                }
                ActCtAttrs::NatIpv4Min(val) => {
                    if last_off == offset {
                        stack.push(("NatIpv4Min", last_off));
                        break;
                    }
                }
                ActCtAttrs::NatIpv4Max(val) => {
                    if last_off == offset {
                        stack.push(("NatIpv4Max", last_off));
                        break;
                    }
                }
                ActCtAttrs::NatIpv6Min(val) => {
                    if last_off == offset {
                        stack.push(("NatIpv6Min", last_off));
                        break;
                    }
                }
                ActCtAttrs::NatIpv6Max(val) => {
                    if last_off == offset {
                        stack.push(("NatIpv6Max", last_off));
                        break;
                    }
                }
                ActCtAttrs::NatPortMin(val) => {
                    if last_off == offset {
                        stack.push(("NatPortMin", last_off));
                        break;
                    }
                }
                ActCtAttrs::NatPortMax(val) => {
                    if last_off == offset {
                        stack.push(("NatPortMax", last_off));
                        break;
                    }
                }
                ActCtAttrs::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                ActCtAttrs::HelperName(val) => {
                    if last_off == offset {
                        stack.push(("HelperName", last_off));
                        break;
                    }
                }
                ActCtAttrs::HelperFamily(val) => {
                    if last_off == offset {
                        stack.push(("HelperFamily", last_off));
                        break;
                    }
                }
                ActCtAttrs::HelperProto(val) => {
                    if last_off == offset {
                        stack.push(("HelperProto", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("ActCtAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"act-ctinfo-attrs\""]
#[derive(Clone)]
pub enum ActCtinfoAttrs<'a> {
    Pad(&'a [u8]),
    Tm(PushTcfT),
    Act(&'a [u8]),
    Zone(u16),
    ParmsDscpMask(u32),
    ParmsDscpStatemask(u32),
    ParmsCpmarkMask(u32),
    StatsDscpSet(u64),
    StatsDscpError(u64),
    StatsCpmarkSet(u64),
}
impl<'a> Iterable<'a, ActCtinfoAttrs<'a>> {
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActCtinfoAttrs::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActCtinfoAttrs", "Pad"))
    }
    pub fn get_tm(&self) -> Result<PushTcfT, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActCtinfoAttrs::Tm(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActCtinfoAttrs", "Tm"))
    }
    pub fn get_act(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActCtinfoAttrs::Act(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActCtinfoAttrs", "Act"))
    }
    pub fn get_zone(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActCtinfoAttrs::Zone(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActCtinfoAttrs", "Zone"))
    }
    pub fn get_parms_dscp_mask(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActCtinfoAttrs::ParmsDscpMask(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActCtinfoAttrs", "ParmsDscpMask"))
    }
    pub fn get_parms_dscp_statemask(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActCtinfoAttrs::ParmsDscpStatemask(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActCtinfoAttrs", "ParmsDscpStatemask"))
    }
    pub fn get_parms_cpmark_mask(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActCtinfoAttrs::ParmsCpmarkMask(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActCtinfoAttrs", "ParmsCpmarkMask"))
    }
    pub fn get_stats_dscp_set(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActCtinfoAttrs::StatsDscpSet(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActCtinfoAttrs", "StatsDscpSet"))
    }
    pub fn get_stats_dscp_error(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActCtinfoAttrs::StatsDscpError(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActCtinfoAttrs", "StatsDscpError"))
    }
    pub fn get_stats_cpmark_set(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActCtinfoAttrs::StatsCpmarkSet(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActCtinfoAttrs", "StatsCpmarkSet"))
    }
}
impl<'a> ActCtinfoAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, ActCtinfoAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Pad",
            2u16 => "Tm",
            3u16 => "Act",
            4u16 => "Zone",
            5u16 => "ParmsDscpMask",
            6u16 => "ParmsDscpStatemask",
            7u16 => "ParmsCpmarkMask",
            8u16 => "StatsDscpSet",
            9u16 => "StatsDscpError",
            10u16 => "StatsCpmarkSet",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, ActCtinfoAttrs<'a>> {
    type Item = Result<ActCtinfoAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => ActCtinfoAttrs::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => ActCtinfoAttrs::Tm({
                    let res = PushTcfT::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => ActCtinfoAttrs::Act({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => ActCtinfoAttrs::Zone({
                    let res = parse_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => ActCtinfoAttrs::ParmsDscpMask({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => ActCtinfoAttrs::ParmsDscpStatemask({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => ActCtinfoAttrs::ParmsCpmarkMask({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => ActCtinfoAttrs::StatsDscpSet({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => ActCtinfoAttrs::StatsDscpError({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => ActCtinfoAttrs::StatsCpmarkSet({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "ActCtinfoAttrs",
            r#type.and_then(|t| ActCtinfoAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, ActCtinfoAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("ActCtinfoAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                ActCtinfoAttrs::Pad(val) => fmt.field("Pad", &val),
                ActCtinfoAttrs::Tm(val) => fmt.field("Tm", &val),
                ActCtinfoAttrs::Act(val) => fmt.field("Act", &val),
                ActCtinfoAttrs::Zone(val) => fmt.field("Zone", &val),
                ActCtinfoAttrs::ParmsDscpMask(val) => fmt.field("ParmsDscpMask", &val),
                ActCtinfoAttrs::ParmsDscpStatemask(val) => fmt.field("ParmsDscpStatemask", &val),
                ActCtinfoAttrs::ParmsCpmarkMask(val) => fmt.field("ParmsCpmarkMask", &val),
                ActCtinfoAttrs::StatsDscpSet(val) => fmt.field("StatsDscpSet", &val),
                ActCtinfoAttrs::StatsDscpError(val) => fmt.field("StatsDscpError", &val),
                ActCtinfoAttrs::StatsCpmarkSet(val) => fmt.field("StatsCpmarkSet", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, ActCtinfoAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("ActCtinfoAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| ActCtinfoAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                ActCtinfoAttrs::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                ActCtinfoAttrs::Tm(val) => {
                    if last_off == offset {
                        stack.push(("Tm", last_off));
                        break;
                    }
                }
                ActCtinfoAttrs::Act(val) => {
                    if last_off == offset {
                        stack.push(("Act", last_off));
                        break;
                    }
                }
                ActCtinfoAttrs::Zone(val) => {
                    if last_off == offset {
                        stack.push(("Zone", last_off));
                        break;
                    }
                }
                ActCtinfoAttrs::ParmsDscpMask(val) => {
                    if last_off == offset {
                        stack.push(("ParmsDscpMask", last_off));
                        break;
                    }
                }
                ActCtinfoAttrs::ParmsDscpStatemask(val) => {
                    if last_off == offset {
                        stack.push(("ParmsDscpStatemask", last_off));
                        break;
                    }
                }
                ActCtinfoAttrs::ParmsCpmarkMask(val) => {
                    if last_off == offset {
                        stack.push(("ParmsCpmarkMask", last_off));
                        break;
                    }
                }
                ActCtinfoAttrs::StatsDscpSet(val) => {
                    if last_off == offset {
                        stack.push(("StatsDscpSet", last_off));
                        break;
                    }
                }
                ActCtinfoAttrs::StatsDscpError(val) => {
                    if last_off == offset {
                        stack.push(("StatsDscpError", last_off));
                        break;
                    }
                }
                ActCtinfoAttrs::StatsCpmarkSet(val) => {
                    if last_off == offset {
                        stack.push(("StatsCpmarkSet", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("ActCtinfoAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"act-gate-attrs\""]
#[derive(Clone)]
pub enum ActGateAttrs<'a> {
    Tm(PushTcfT),
    Parms(&'a [u8]),
    Pad(&'a [u8]),
    Priority(i32),
    EntryList(&'a [u8]),
    BaseTime(u64),
    CycleTime(u64),
    CycleTimeExt(u64),
    Flags(u32),
    Clockid(i32),
}
impl<'a> Iterable<'a, ActGateAttrs<'a>> {
    pub fn get_tm(&self) -> Result<PushTcfT, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActGateAttrs::Tm(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActGateAttrs", "Tm"))
    }
    pub fn get_parms(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActGateAttrs::Parms(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActGateAttrs", "Parms"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActGateAttrs::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActGateAttrs", "Pad"))
    }
    pub fn get_priority(&self) -> Result<i32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActGateAttrs::Priority(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActGateAttrs", "Priority"))
    }
    pub fn get_entry_list(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActGateAttrs::EntryList(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActGateAttrs", "EntryList"))
    }
    pub fn get_base_time(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActGateAttrs::BaseTime(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActGateAttrs", "BaseTime"))
    }
    pub fn get_cycle_time(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActGateAttrs::CycleTime(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActGateAttrs", "CycleTime"))
    }
    pub fn get_cycle_time_ext(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActGateAttrs::CycleTimeExt(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActGateAttrs", "CycleTimeExt"))
    }
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActGateAttrs::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActGateAttrs", "Flags"))
    }
    pub fn get_clockid(&self) -> Result<i32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActGateAttrs::Clockid(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActGateAttrs", "Clockid"))
    }
}
impl<'a> ActGateAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, ActGateAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Tm",
            2u16 => "Parms",
            3u16 => "Pad",
            4u16 => "Priority",
            5u16 => "EntryList",
            6u16 => "BaseTime",
            7u16 => "CycleTime",
            8u16 => "CycleTimeExt",
            9u16 => "Flags",
            10u16 => "Clockid",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, ActGateAttrs<'a>> {
    type Item = Result<ActGateAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => ActGateAttrs::Tm({
                    let res = PushTcfT::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => ActGateAttrs::Parms({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => ActGateAttrs::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => ActGateAttrs::Priority({
                    let res = parse_i32(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => ActGateAttrs::EntryList({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => ActGateAttrs::BaseTime({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => ActGateAttrs::CycleTime({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => ActGateAttrs::CycleTimeExt({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => ActGateAttrs::Flags({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => ActGateAttrs::Clockid({
                    let res = parse_i32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "ActGateAttrs",
            r#type.and_then(|t| ActGateAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, ActGateAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("ActGateAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                ActGateAttrs::Tm(val) => fmt.field("Tm", &val),
                ActGateAttrs::Parms(val) => fmt.field("Parms", &val),
                ActGateAttrs::Pad(val) => fmt.field("Pad", &val),
                ActGateAttrs::Priority(val) => fmt.field("Priority", &val),
                ActGateAttrs::EntryList(val) => fmt.field("EntryList", &val),
                ActGateAttrs::BaseTime(val) => fmt.field("BaseTime", &val),
                ActGateAttrs::CycleTime(val) => fmt.field("CycleTime", &val),
                ActGateAttrs::CycleTimeExt(val) => fmt.field("CycleTimeExt", &val),
                ActGateAttrs::Flags(val) => fmt.field("Flags", &val),
                ActGateAttrs::Clockid(val) => fmt.field("Clockid", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, ActGateAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("ActGateAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| ActGateAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                ActGateAttrs::Tm(val) => {
                    if last_off == offset {
                        stack.push(("Tm", last_off));
                        break;
                    }
                }
                ActGateAttrs::Parms(val) => {
                    if last_off == offset {
                        stack.push(("Parms", last_off));
                        break;
                    }
                }
                ActGateAttrs::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                ActGateAttrs::Priority(val) => {
                    if last_off == offset {
                        stack.push(("Priority", last_off));
                        break;
                    }
                }
                ActGateAttrs::EntryList(val) => {
                    if last_off == offset {
                        stack.push(("EntryList", last_off));
                        break;
                    }
                }
                ActGateAttrs::BaseTime(val) => {
                    if last_off == offset {
                        stack.push(("BaseTime", last_off));
                        break;
                    }
                }
                ActGateAttrs::CycleTime(val) => {
                    if last_off == offset {
                        stack.push(("CycleTime", last_off));
                        break;
                    }
                }
                ActGateAttrs::CycleTimeExt(val) => {
                    if last_off == offset {
                        stack.push(("CycleTimeExt", last_off));
                        break;
                    }
                }
                ActGateAttrs::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                ActGateAttrs::Clockid(val) => {
                    if last_off == offset {
                        stack.push(("Clockid", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("ActGateAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"act-ife-attrs\""]
#[derive(Clone)]
pub enum ActIfeAttrs<'a> {
    Parms(&'a [u8]),
    Tm(PushTcfT),
    Dmac(&'a [u8]),
    Smac(&'a [u8]),
    Type(u16),
    Metalst(&'a [u8]),
    Pad(&'a [u8]),
}
impl<'a> Iterable<'a, ActIfeAttrs<'a>> {
    pub fn get_parms(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActIfeAttrs::Parms(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActIfeAttrs", "Parms"))
    }
    pub fn get_tm(&self) -> Result<PushTcfT, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActIfeAttrs::Tm(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActIfeAttrs", "Tm"))
    }
    pub fn get_dmac(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActIfeAttrs::Dmac(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActIfeAttrs", "Dmac"))
    }
    pub fn get_smac(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActIfeAttrs::Smac(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActIfeAttrs", "Smac"))
    }
    pub fn get_type(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActIfeAttrs::Type(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActIfeAttrs", "Type"))
    }
    pub fn get_metalst(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActIfeAttrs::Metalst(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActIfeAttrs", "Metalst"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActIfeAttrs::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActIfeAttrs", "Pad"))
    }
}
impl<'a> ActIfeAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, ActIfeAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Parms",
            2u16 => "Tm",
            3u16 => "Dmac",
            4u16 => "Smac",
            5u16 => "Type",
            6u16 => "Metalst",
            7u16 => "Pad",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, ActIfeAttrs<'a>> {
    type Item = Result<ActIfeAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => ActIfeAttrs::Parms({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => ActIfeAttrs::Tm({
                    let res = PushTcfT::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => ActIfeAttrs::Dmac({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => ActIfeAttrs::Smac({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => ActIfeAttrs::Type({
                    let res = parse_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => ActIfeAttrs::Metalst({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => ActIfeAttrs::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "ActIfeAttrs",
            r#type.and_then(|t| ActIfeAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, ActIfeAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("ActIfeAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                ActIfeAttrs::Parms(val) => fmt.field("Parms", &val),
                ActIfeAttrs::Tm(val) => fmt.field("Tm", &val),
                ActIfeAttrs::Dmac(val) => fmt.field("Dmac", &val),
                ActIfeAttrs::Smac(val) => fmt.field("Smac", &val),
                ActIfeAttrs::Type(val) => fmt.field("Type", &val),
                ActIfeAttrs::Metalst(val) => fmt.field("Metalst", &val),
                ActIfeAttrs::Pad(val) => fmt.field("Pad", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, ActIfeAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("ActIfeAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| ActIfeAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                ActIfeAttrs::Parms(val) => {
                    if last_off == offset {
                        stack.push(("Parms", last_off));
                        break;
                    }
                }
                ActIfeAttrs::Tm(val) => {
                    if last_off == offset {
                        stack.push(("Tm", last_off));
                        break;
                    }
                }
                ActIfeAttrs::Dmac(val) => {
                    if last_off == offset {
                        stack.push(("Dmac", last_off));
                        break;
                    }
                }
                ActIfeAttrs::Smac(val) => {
                    if last_off == offset {
                        stack.push(("Smac", last_off));
                        break;
                    }
                }
                ActIfeAttrs::Type(val) => {
                    if last_off == offset {
                        stack.push(("Type", last_off));
                        break;
                    }
                }
                ActIfeAttrs::Metalst(val) => {
                    if last_off == offset {
                        stack.push(("Metalst", last_off));
                        break;
                    }
                }
                ActIfeAttrs::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("ActIfeAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"act-mirred-attrs\""]
#[derive(Clone)]
pub enum ActMirredAttrs<'a> {
    Tm(PushTcfT),
    Parms(&'a [u8]),
    Pad(&'a [u8]),
    Blockid(&'a [u8]),
}
impl<'a> Iterable<'a, ActMirredAttrs<'a>> {
    pub fn get_tm(&self) -> Result<PushTcfT, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActMirredAttrs::Tm(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActMirredAttrs", "Tm"))
    }
    pub fn get_parms(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActMirredAttrs::Parms(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActMirredAttrs", "Parms"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActMirredAttrs::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActMirredAttrs", "Pad"))
    }
    pub fn get_blockid(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActMirredAttrs::Blockid(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActMirredAttrs", "Blockid"))
    }
}
impl<'a> ActMirredAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, ActMirredAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Tm",
            2u16 => "Parms",
            3u16 => "Pad",
            4u16 => "Blockid",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, ActMirredAttrs<'a>> {
    type Item = Result<ActMirredAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => ActMirredAttrs::Tm({
                    let res = PushTcfT::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => ActMirredAttrs::Parms({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => ActMirredAttrs::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => ActMirredAttrs::Blockid({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "ActMirredAttrs",
            r#type.and_then(|t| ActMirredAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, ActMirredAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("ActMirredAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                ActMirredAttrs::Tm(val) => fmt.field("Tm", &val),
                ActMirredAttrs::Parms(val) => fmt.field("Parms", &val),
                ActMirredAttrs::Pad(val) => fmt.field("Pad", &val),
                ActMirredAttrs::Blockid(val) => fmt.field("Blockid", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, ActMirredAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("ActMirredAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| ActMirredAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                ActMirredAttrs::Tm(val) => {
                    if last_off == offset {
                        stack.push(("Tm", last_off));
                        break;
                    }
                }
                ActMirredAttrs::Parms(val) => {
                    if last_off == offset {
                        stack.push(("Parms", last_off));
                        break;
                    }
                }
                ActMirredAttrs::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                ActMirredAttrs::Blockid(val) => {
                    if last_off == offset {
                        stack.push(("Blockid", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("ActMirredAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"act-mpls-attrs\""]
#[derive(Clone)]
pub enum ActMplsAttrs<'a> {
    Tm(PushTcfT),
    Parms(PushTcMpls),
    Pad(&'a [u8]),
    Proto(u16),
    Label(u32),
    Tc(u8),
    Ttl(u8),
    Bos(u8),
}
impl<'a> Iterable<'a, ActMplsAttrs<'a>> {
    pub fn get_tm(&self) -> Result<PushTcfT, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActMplsAttrs::Tm(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActMplsAttrs", "Tm"))
    }
    pub fn get_parms(&self) -> Result<PushTcMpls, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActMplsAttrs::Parms(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActMplsAttrs", "Parms"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActMplsAttrs::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActMplsAttrs", "Pad"))
    }
    pub fn get_proto(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActMplsAttrs::Proto(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActMplsAttrs", "Proto"))
    }
    pub fn get_label(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActMplsAttrs::Label(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActMplsAttrs", "Label"))
    }
    pub fn get_tc(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActMplsAttrs::Tc(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActMplsAttrs", "Tc"))
    }
    pub fn get_ttl(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActMplsAttrs::Ttl(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActMplsAttrs", "Ttl"))
    }
    pub fn get_bos(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActMplsAttrs::Bos(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActMplsAttrs", "Bos"))
    }
}
impl<'a> ActMplsAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, ActMplsAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Tm",
            2u16 => "Parms",
            3u16 => "Pad",
            4u16 => "Proto",
            5u16 => "Label",
            6u16 => "Tc",
            7u16 => "Ttl",
            8u16 => "Bos",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, ActMplsAttrs<'a>> {
    type Item = Result<ActMplsAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => ActMplsAttrs::Tm({
                    let res = PushTcfT::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => ActMplsAttrs::Parms({
                    let res = PushTcMpls::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => ActMplsAttrs::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => ActMplsAttrs::Proto({
                    let res = parse_be_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => ActMplsAttrs::Label({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => ActMplsAttrs::Tc({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => ActMplsAttrs::Ttl({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => ActMplsAttrs::Bos({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "ActMplsAttrs",
            r#type.and_then(|t| ActMplsAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, ActMplsAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("ActMplsAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                ActMplsAttrs::Tm(val) => fmt.field("Tm", &val),
                ActMplsAttrs::Parms(val) => fmt.field("Parms", &val),
                ActMplsAttrs::Pad(val) => fmt.field("Pad", &val),
                ActMplsAttrs::Proto(val) => fmt.field("Proto", &val),
                ActMplsAttrs::Label(val) => fmt.field("Label", &val),
                ActMplsAttrs::Tc(val) => fmt.field("Tc", &val),
                ActMplsAttrs::Ttl(val) => fmt.field("Ttl", &val),
                ActMplsAttrs::Bos(val) => fmt.field("Bos", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, ActMplsAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("ActMplsAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| ActMplsAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                ActMplsAttrs::Tm(val) => {
                    if last_off == offset {
                        stack.push(("Tm", last_off));
                        break;
                    }
                }
                ActMplsAttrs::Parms(val) => {
                    if last_off == offset {
                        stack.push(("Parms", last_off));
                        break;
                    }
                }
                ActMplsAttrs::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                ActMplsAttrs::Proto(val) => {
                    if last_off == offset {
                        stack.push(("Proto", last_off));
                        break;
                    }
                }
                ActMplsAttrs::Label(val) => {
                    if last_off == offset {
                        stack.push(("Label", last_off));
                        break;
                    }
                }
                ActMplsAttrs::Tc(val) => {
                    if last_off == offset {
                        stack.push(("Tc", last_off));
                        break;
                    }
                }
                ActMplsAttrs::Ttl(val) => {
                    if last_off == offset {
                        stack.push(("Ttl", last_off));
                        break;
                    }
                }
                ActMplsAttrs::Bos(val) => {
                    if last_off == offset {
                        stack.push(("Bos", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("ActMplsAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"act-nat-attrs\""]
#[derive(Clone)]
pub enum ActNatAttrs<'a> {
    Parms(&'a [u8]),
    Tm(PushTcfT),
    Pad(&'a [u8]),
}
impl<'a> Iterable<'a, ActNatAttrs<'a>> {
    pub fn get_parms(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActNatAttrs::Parms(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActNatAttrs", "Parms"))
    }
    pub fn get_tm(&self) -> Result<PushTcfT, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActNatAttrs::Tm(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActNatAttrs", "Tm"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActNatAttrs::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActNatAttrs", "Pad"))
    }
}
impl<'a> ActNatAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, ActNatAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Parms",
            2u16 => "Tm",
            3u16 => "Pad",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, ActNatAttrs<'a>> {
    type Item = Result<ActNatAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => ActNatAttrs::Parms({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => ActNatAttrs::Tm({
                    let res = PushTcfT::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => ActNatAttrs::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "ActNatAttrs",
            r#type.and_then(|t| ActNatAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, ActNatAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("ActNatAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                ActNatAttrs::Parms(val) => fmt.field("Parms", &val),
                ActNatAttrs::Tm(val) => fmt.field("Tm", &val),
                ActNatAttrs::Pad(val) => fmt.field("Pad", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, ActNatAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("ActNatAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| ActNatAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                ActNatAttrs::Parms(val) => {
                    if last_off == offset {
                        stack.push(("Parms", last_off));
                        break;
                    }
                }
                ActNatAttrs::Tm(val) => {
                    if last_off == offset {
                        stack.push(("Tm", last_off));
                        break;
                    }
                }
                ActNatAttrs::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("ActNatAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"act-pedit-attrs\""]
#[derive(Clone)]
pub enum ActPeditAttrs<'a> {
    Tm(PushTcfT),
    Parms(PushTcPeditSel),
    Pad(&'a [u8]),
    ParmsEx(&'a [u8]),
    KeysEx(&'a [u8]),
    KeyEx(&'a [u8]),
}
impl<'a> Iterable<'a, ActPeditAttrs<'a>> {
    pub fn get_tm(&self) -> Result<PushTcfT, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActPeditAttrs::Tm(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActPeditAttrs", "Tm"))
    }
    pub fn get_parms(&self) -> Result<PushTcPeditSel, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActPeditAttrs::Parms(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActPeditAttrs", "Parms"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActPeditAttrs::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActPeditAttrs", "Pad"))
    }
    pub fn get_parms_ex(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActPeditAttrs::ParmsEx(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActPeditAttrs", "ParmsEx"))
    }
    pub fn get_keys_ex(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActPeditAttrs::KeysEx(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActPeditAttrs", "KeysEx"))
    }
    pub fn get_key_ex(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActPeditAttrs::KeyEx(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActPeditAttrs", "KeyEx"))
    }
}
impl<'a> ActPeditAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, ActPeditAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Tm",
            2u16 => "Parms",
            3u16 => "Pad",
            4u16 => "ParmsEx",
            5u16 => "KeysEx",
            6u16 => "KeyEx",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, ActPeditAttrs<'a>> {
    type Item = Result<ActPeditAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => ActPeditAttrs::Tm({
                    let res = PushTcfT::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => ActPeditAttrs::Parms({
                    let res = PushTcPeditSel::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => ActPeditAttrs::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => ActPeditAttrs::ParmsEx({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => ActPeditAttrs::KeysEx({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => ActPeditAttrs::KeyEx({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "ActPeditAttrs",
            r#type.and_then(|t| ActPeditAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, ActPeditAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("ActPeditAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                ActPeditAttrs::Tm(val) => fmt.field("Tm", &val),
                ActPeditAttrs::Parms(val) => fmt.field("Parms", &val),
                ActPeditAttrs::Pad(val) => fmt.field("Pad", &val),
                ActPeditAttrs::ParmsEx(val) => fmt.field("ParmsEx", &val),
                ActPeditAttrs::KeysEx(val) => fmt.field("KeysEx", &val),
                ActPeditAttrs::KeyEx(val) => fmt.field("KeyEx", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, ActPeditAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("ActPeditAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| ActPeditAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                ActPeditAttrs::Tm(val) => {
                    if last_off == offset {
                        stack.push(("Tm", last_off));
                        break;
                    }
                }
                ActPeditAttrs::Parms(val) => {
                    if last_off == offset {
                        stack.push(("Parms", last_off));
                        break;
                    }
                }
                ActPeditAttrs::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                ActPeditAttrs::ParmsEx(val) => {
                    if last_off == offset {
                        stack.push(("ParmsEx", last_off));
                        break;
                    }
                }
                ActPeditAttrs::KeysEx(val) => {
                    if last_off == offset {
                        stack.push(("KeysEx", last_off));
                        break;
                    }
                }
                ActPeditAttrs::KeyEx(val) => {
                    if last_off == offset {
                        stack.push(("KeyEx", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("ActPeditAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"act-simple-attrs\""]
#[derive(Clone)]
pub enum ActSimpleAttrs<'a> {
    Tm(PushTcfT),
    Parms(&'a [u8]),
    Data(&'a [u8]),
    Pad(&'a [u8]),
}
impl<'a> Iterable<'a, ActSimpleAttrs<'a>> {
    pub fn get_tm(&self) -> Result<PushTcfT, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActSimpleAttrs::Tm(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActSimpleAttrs", "Tm"))
    }
    pub fn get_parms(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActSimpleAttrs::Parms(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActSimpleAttrs", "Parms"))
    }
    pub fn get_data(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActSimpleAttrs::Data(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActSimpleAttrs", "Data"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActSimpleAttrs::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActSimpleAttrs", "Pad"))
    }
}
impl<'a> ActSimpleAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, ActSimpleAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Tm",
            2u16 => "Parms",
            3u16 => "Data",
            4u16 => "Pad",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, ActSimpleAttrs<'a>> {
    type Item = Result<ActSimpleAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => ActSimpleAttrs::Tm({
                    let res = PushTcfT::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => ActSimpleAttrs::Parms({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => ActSimpleAttrs::Data({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => ActSimpleAttrs::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "ActSimpleAttrs",
            r#type.and_then(|t| ActSimpleAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, ActSimpleAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("ActSimpleAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                ActSimpleAttrs::Tm(val) => fmt.field("Tm", &val),
                ActSimpleAttrs::Parms(val) => fmt.field("Parms", &val),
                ActSimpleAttrs::Data(val) => fmt.field("Data", &val),
                ActSimpleAttrs::Pad(val) => fmt.field("Pad", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, ActSimpleAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("ActSimpleAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| ActSimpleAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                ActSimpleAttrs::Tm(val) => {
                    if last_off == offset {
                        stack.push(("Tm", last_off));
                        break;
                    }
                }
                ActSimpleAttrs::Parms(val) => {
                    if last_off == offset {
                        stack.push(("Parms", last_off));
                        break;
                    }
                }
                ActSimpleAttrs::Data(val) => {
                    if last_off == offset {
                        stack.push(("Data", last_off));
                        break;
                    }
                }
                ActSimpleAttrs::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("ActSimpleAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"act-skbedit-attrs\""]
#[derive(Clone)]
pub enum ActSkbeditAttrs<'a> {
    Tm(PushTcfT),
    Parms(&'a [u8]),
    Priority(u32),
    QueueMapping(u16),
    Mark(u32),
    Pad(&'a [u8]),
    Ptype(u16),
    Mask(u32),
    Flags(u64),
    QueueMappingMax(u16),
}
impl<'a> Iterable<'a, ActSkbeditAttrs<'a>> {
    pub fn get_tm(&self) -> Result<PushTcfT, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActSkbeditAttrs::Tm(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActSkbeditAttrs", "Tm"))
    }
    pub fn get_parms(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActSkbeditAttrs::Parms(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActSkbeditAttrs", "Parms"))
    }
    pub fn get_priority(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActSkbeditAttrs::Priority(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActSkbeditAttrs", "Priority"))
    }
    pub fn get_queue_mapping(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActSkbeditAttrs::QueueMapping(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActSkbeditAttrs", "QueueMapping"))
    }
    pub fn get_mark(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActSkbeditAttrs::Mark(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActSkbeditAttrs", "Mark"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActSkbeditAttrs::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActSkbeditAttrs", "Pad"))
    }
    pub fn get_ptype(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActSkbeditAttrs::Ptype(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActSkbeditAttrs", "Ptype"))
    }
    pub fn get_mask(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActSkbeditAttrs::Mask(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActSkbeditAttrs", "Mask"))
    }
    pub fn get_flags(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActSkbeditAttrs::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActSkbeditAttrs", "Flags"))
    }
    pub fn get_queue_mapping_max(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActSkbeditAttrs::QueueMappingMax(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActSkbeditAttrs", "QueueMappingMax"))
    }
}
impl<'a> ActSkbeditAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, ActSkbeditAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Tm",
            2u16 => "Parms",
            3u16 => "Priority",
            4u16 => "QueueMapping",
            5u16 => "Mark",
            6u16 => "Pad",
            7u16 => "Ptype",
            8u16 => "Mask",
            9u16 => "Flags",
            10u16 => "QueueMappingMax",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, ActSkbeditAttrs<'a>> {
    type Item = Result<ActSkbeditAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => ActSkbeditAttrs::Tm({
                    let res = PushTcfT::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => ActSkbeditAttrs::Parms({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => ActSkbeditAttrs::Priority({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => ActSkbeditAttrs::QueueMapping({
                    let res = parse_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => ActSkbeditAttrs::Mark({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => ActSkbeditAttrs::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => ActSkbeditAttrs::Ptype({
                    let res = parse_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => ActSkbeditAttrs::Mask({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => ActSkbeditAttrs::Flags({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => ActSkbeditAttrs::QueueMappingMax({
                    let res = parse_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "ActSkbeditAttrs",
            r#type.and_then(|t| ActSkbeditAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, ActSkbeditAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("ActSkbeditAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                ActSkbeditAttrs::Tm(val) => fmt.field("Tm", &val),
                ActSkbeditAttrs::Parms(val) => fmt.field("Parms", &val),
                ActSkbeditAttrs::Priority(val) => fmt.field("Priority", &val),
                ActSkbeditAttrs::QueueMapping(val) => fmt.field("QueueMapping", &val),
                ActSkbeditAttrs::Mark(val) => fmt.field("Mark", &val),
                ActSkbeditAttrs::Pad(val) => fmt.field("Pad", &val),
                ActSkbeditAttrs::Ptype(val) => fmt.field("Ptype", &val),
                ActSkbeditAttrs::Mask(val) => fmt.field("Mask", &val),
                ActSkbeditAttrs::Flags(val) => fmt.field("Flags", &val),
                ActSkbeditAttrs::QueueMappingMax(val) => fmt.field("QueueMappingMax", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, ActSkbeditAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("ActSkbeditAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| ActSkbeditAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                ActSkbeditAttrs::Tm(val) => {
                    if last_off == offset {
                        stack.push(("Tm", last_off));
                        break;
                    }
                }
                ActSkbeditAttrs::Parms(val) => {
                    if last_off == offset {
                        stack.push(("Parms", last_off));
                        break;
                    }
                }
                ActSkbeditAttrs::Priority(val) => {
                    if last_off == offset {
                        stack.push(("Priority", last_off));
                        break;
                    }
                }
                ActSkbeditAttrs::QueueMapping(val) => {
                    if last_off == offset {
                        stack.push(("QueueMapping", last_off));
                        break;
                    }
                }
                ActSkbeditAttrs::Mark(val) => {
                    if last_off == offset {
                        stack.push(("Mark", last_off));
                        break;
                    }
                }
                ActSkbeditAttrs::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                ActSkbeditAttrs::Ptype(val) => {
                    if last_off == offset {
                        stack.push(("Ptype", last_off));
                        break;
                    }
                }
                ActSkbeditAttrs::Mask(val) => {
                    if last_off == offset {
                        stack.push(("Mask", last_off));
                        break;
                    }
                }
                ActSkbeditAttrs::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                ActSkbeditAttrs::QueueMappingMax(val) => {
                    if last_off == offset {
                        stack.push(("QueueMappingMax", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("ActSkbeditAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"act-skbmod-attrs\""]
#[derive(Clone)]
pub enum ActSkbmodAttrs<'a> {
    Tm(PushTcfT),
    Parms(&'a [u8]),
    Dmac(&'a [u8]),
    Smac(&'a [u8]),
    Etype(&'a [u8]),
    Pad(&'a [u8]),
}
impl<'a> Iterable<'a, ActSkbmodAttrs<'a>> {
    pub fn get_tm(&self) -> Result<PushTcfT, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActSkbmodAttrs::Tm(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActSkbmodAttrs", "Tm"))
    }
    pub fn get_parms(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActSkbmodAttrs::Parms(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActSkbmodAttrs", "Parms"))
    }
    pub fn get_dmac(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActSkbmodAttrs::Dmac(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActSkbmodAttrs", "Dmac"))
    }
    pub fn get_smac(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActSkbmodAttrs::Smac(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActSkbmodAttrs", "Smac"))
    }
    pub fn get_etype(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActSkbmodAttrs::Etype(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActSkbmodAttrs", "Etype"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActSkbmodAttrs::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActSkbmodAttrs", "Pad"))
    }
}
impl<'a> ActSkbmodAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, ActSkbmodAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Tm",
            2u16 => "Parms",
            3u16 => "Dmac",
            4u16 => "Smac",
            5u16 => "Etype",
            6u16 => "Pad",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, ActSkbmodAttrs<'a>> {
    type Item = Result<ActSkbmodAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => ActSkbmodAttrs::Tm({
                    let res = PushTcfT::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => ActSkbmodAttrs::Parms({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => ActSkbmodAttrs::Dmac({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => ActSkbmodAttrs::Smac({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => ActSkbmodAttrs::Etype({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => ActSkbmodAttrs::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "ActSkbmodAttrs",
            r#type.and_then(|t| ActSkbmodAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, ActSkbmodAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("ActSkbmodAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                ActSkbmodAttrs::Tm(val) => fmt.field("Tm", &val),
                ActSkbmodAttrs::Parms(val) => fmt.field("Parms", &val),
                ActSkbmodAttrs::Dmac(val) => fmt.field("Dmac", &val),
                ActSkbmodAttrs::Smac(val) => fmt.field("Smac", &val),
                ActSkbmodAttrs::Etype(val) => fmt.field("Etype", &val),
                ActSkbmodAttrs::Pad(val) => fmt.field("Pad", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, ActSkbmodAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("ActSkbmodAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| ActSkbmodAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                ActSkbmodAttrs::Tm(val) => {
                    if last_off == offset {
                        stack.push(("Tm", last_off));
                        break;
                    }
                }
                ActSkbmodAttrs::Parms(val) => {
                    if last_off == offset {
                        stack.push(("Parms", last_off));
                        break;
                    }
                }
                ActSkbmodAttrs::Dmac(val) => {
                    if last_off == offset {
                        stack.push(("Dmac", last_off));
                        break;
                    }
                }
                ActSkbmodAttrs::Smac(val) => {
                    if last_off == offset {
                        stack.push(("Smac", last_off));
                        break;
                    }
                }
                ActSkbmodAttrs::Etype(val) => {
                    if last_off == offset {
                        stack.push(("Etype", last_off));
                        break;
                    }
                }
                ActSkbmodAttrs::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("ActSkbmodAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"act-tunnel-key-attrs\""]
#[derive(Clone)]
pub enum ActTunnelKeyAttrs<'a> {
    Tm(PushTcfT),
    Parms(&'a [u8]),
    EncIpv4Src(u32),
    EncIpv4Dst(u32),
    EncIpv6Src(&'a [u8]),
    EncIpv6Dst(&'a [u8]),
    EncKeyId(u64),
    Pad(&'a [u8]),
    EncDstPort(u16),
    NoCsum(u8),
    EncOpts(&'a [u8]),
    EncTos(u8),
    EncTtl(u8),
    NoFrag(()),
}
impl<'a> Iterable<'a, ActTunnelKeyAttrs<'a>> {
    pub fn get_tm(&self) -> Result<PushTcfT, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActTunnelKeyAttrs::Tm(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActTunnelKeyAttrs", "Tm"))
    }
    pub fn get_parms(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActTunnelKeyAttrs::Parms(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActTunnelKeyAttrs", "Parms"))
    }
    pub fn get_enc_ipv4_src(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActTunnelKeyAttrs::EncIpv4Src(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActTunnelKeyAttrs", "EncIpv4Src"))
    }
    pub fn get_enc_ipv4_dst(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActTunnelKeyAttrs::EncIpv4Dst(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActTunnelKeyAttrs", "EncIpv4Dst"))
    }
    pub fn get_enc_ipv6_src(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActTunnelKeyAttrs::EncIpv6Src(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActTunnelKeyAttrs", "EncIpv6Src"))
    }
    pub fn get_enc_ipv6_dst(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActTunnelKeyAttrs::EncIpv6Dst(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActTunnelKeyAttrs", "EncIpv6Dst"))
    }
    pub fn get_enc_key_id(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActTunnelKeyAttrs::EncKeyId(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActTunnelKeyAttrs", "EncKeyId"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActTunnelKeyAttrs::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActTunnelKeyAttrs", "Pad"))
    }
    pub fn get_enc_dst_port(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActTunnelKeyAttrs::EncDstPort(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActTunnelKeyAttrs", "EncDstPort"))
    }
    pub fn get_no_csum(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActTunnelKeyAttrs::NoCsum(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActTunnelKeyAttrs", "NoCsum"))
    }
    pub fn get_enc_opts(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActTunnelKeyAttrs::EncOpts(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActTunnelKeyAttrs", "EncOpts"))
    }
    pub fn get_enc_tos(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActTunnelKeyAttrs::EncTos(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActTunnelKeyAttrs", "EncTos"))
    }
    pub fn get_enc_ttl(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActTunnelKeyAttrs::EncTtl(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActTunnelKeyAttrs", "EncTtl"))
    }
    pub fn get_no_frag(&self) -> Result<(), ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActTunnelKeyAttrs::NoFrag(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActTunnelKeyAttrs", "NoFrag"))
    }
}
impl<'a> ActTunnelKeyAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, ActTunnelKeyAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Tm",
            2u16 => "Parms",
            3u16 => "EncIpv4Src",
            4u16 => "EncIpv4Dst",
            5u16 => "EncIpv6Src",
            6u16 => "EncIpv6Dst",
            7u16 => "EncKeyId",
            8u16 => "Pad",
            9u16 => "EncDstPort",
            10u16 => "NoCsum",
            11u16 => "EncOpts",
            12u16 => "EncTos",
            13u16 => "EncTtl",
            14u16 => "NoFrag",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, ActTunnelKeyAttrs<'a>> {
    type Item = Result<ActTunnelKeyAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => ActTunnelKeyAttrs::Tm({
                    let res = PushTcfT::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => ActTunnelKeyAttrs::Parms({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => ActTunnelKeyAttrs::EncIpv4Src({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => ActTunnelKeyAttrs::EncIpv4Dst({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => ActTunnelKeyAttrs::EncIpv6Src({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => ActTunnelKeyAttrs::EncIpv6Dst({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => ActTunnelKeyAttrs::EncKeyId({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => ActTunnelKeyAttrs::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => ActTunnelKeyAttrs::EncDstPort({
                    let res = parse_be_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => ActTunnelKeyAttrs::NoCsum({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => ActTunnelKeyAttrs::EncOpts({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                12u16 => ActTunnelKeyAttrs::EncTos({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                13u16 => ActTunnelKeyAttrs::EncTtl({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                14u16 => ActTunnelKeyAttrs::NoFrag(()),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "ActTunnelKeyAttrs",
            r#type.and_then(|t| ActTunnelKeyAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, ActTunnelKeyAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("ActTunnelKeyAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                ActTunnelKeyAttrs::Tm(val) => fmt.field("Tm", &val),
                ActTunnelKeyAttrs::Parms(val) => fmt.field("Parms", &val),
                ActTunnelKeyAttrs::EncIpv4Src(val) => fmt.field("EncIpv4Src", &val),
                ActTunnelKeyAttrs::EncIpv4Dst(val) => fmt.field("EncIpv4Dst", &val),
                ActTunnelKeyAttrs::EncIpv6Src(val) => fmt.field("EncIpv6Src", &val),
                ActTunnelKeyAttrs::EncIpv6Dst(val) => fmt.field("EncIpv6Dst", &val),
                ActTunnelKeyAttrs::EncKeyId(val) => fmt.field("EncKeyId", &val),
                ActTunnelKeyAttrs::Pad(val) => fmt.field("Pad", &val),
                ActTunnelKeyAttrs::EncDstPort(val) => fmt.field("EncDstPort", &val),
                ActTunnelKeyAttrs::NoCsum(val) => fmt.field("NoCsum", &val),
                ActTunnelKeyAttrs::EncOpts(val) => fmt.field("EncOpts", &val),
                ActTunnelKeyAttrs::EncTos(val) => fmt.field("EncTos", &val),
                ActTunnelKeyAttrs::EncTtl(val) => fmt.field("EncTtl", &val),
                ActTunnelKeyAttrs::NoFrag(val) => fmt.field("NoFrag", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, ActTunnelKeyAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("ActTunnelKeyAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| ActTunnelKeyAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                ActTunnelKeyAttrs::Tm(val) => {
                    if last_off == offset {
                        stack.push(("Tm", last_off));
                        break;
                    }
                }
                ActTunnelKeyAttrs::Parms(val) => {
                    if last_off == offset {
                        stack.push(("Parms", last_off));
                        break;
                    }
                }
                ActTunnelKeyAttrs::EncIpv4Src(val) => {
                    if last_off == offset {
                        stack.push(("EncIpv4Src", last_off));
                        break;
                    }
                }
                ActTunnelKeyAttrs::EncIpv4Dst(val) => {
                    if last_off == offset {
                        stack.push(("EncIpv4Dst", last_off));
                        break;
                    }
                }
                ActTunnelKeyAttrs::EncIpv6Src(val) => {
                    if last_off == offset {
                        stack.push(("EncIpv6Src", last_off));
                        break;
                    }
                }
                ActTunnelKeyAttrs::EncIpv6Dst(val) => {
                    if last_off == offset {
                        stack.push(("EncIpv6Dst", last_off));
                        break;
                    }
                }
                ActTunnelKeyAttrs::EncKeyId(val) => {
                    if last_off == offset {
                        stack.push(("EncKeyId", last_off));
                        break;
                    }
                }
                ActTunnelKeyAttrs::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                ActTunnelKeyAttrs::EncDstPort(val) => {
                    if last_off == offset {
                        stack.push(("EncDstPort", last_off));
                        break;
                    }
                }
                ActTunnelKeyAttrs::NoCsum(val) => {
                    if last_off == offset {
                        stack.push(("NoCsum", last_off));
                        break;
                    }
                }
                ActTunnelKeyAttrs::EncOpts(val) => {
                    if last_off == offset {
                        stack.push(("EncOpts", last_off));
                        break;
                    }
                }
                ActTunnelKeyAttrs::EncTos(val) => {
                    if last_off == offset {
                        stack.push(("EncTos", last_off));
                        break;
                    }
                }
                ActTunnelKeyAttrs::EncTtl(val) => {
                    if last_off == offset {
                        stack.push(("EncTtl", last_off));
                        break;
                    }
                }
                ActTunnelKeyAttrs::NoFrag(val) => {
                    if last_off == offset {
                        stack.push(("NoFrag", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("ActTunnelKeyAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"act-vlan-attrs\""]
#[derive(Clone)]
pub enum ActVlanAttrs<'a> {
    Tm(PushTcfT),
    Parms(PushTcVlan),
    PushVlanId(u16),
    PushVlanProtocol(u16),
    Pad(&'a [u8]),
    PushVlanPriority(u8),
    PushEthDst(&'a [u8]),
    PushEthSrc(&'a [u8]),
}
impl<'a> Iterable<'a, ActVlanAttrs<'a>> {
    pub fn get_tm(&self) -> Result<PushTcfT, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActVlanAttrs::Tm(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActVlanAttrs", "Tm"))
    }
    pub fn get_parms(&self) -> Result<PushTcVlan, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActVlanAttrs::Parms(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActVlanAttrs", "Parms"))
    }
    pub fn get_push_vlan_id(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActVlanAttrs::PushVlanId(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActVlanAttrs", "PushVlanId"))
    }
    pub fn get_push_vlan_protocol(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActVlanAttrs::PushVlanProtocol(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActVlanAttrs", "PushVlanProtocol"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActVlanAttrs::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActVlanAttrs", "Pad"))
    }
    pub fn get_push_vlan_priority(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActVlanAttrs::PushVlanPriority(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActVlanAttrs", "PushVlanPriority"))
    }
    pub fn get_push_eth_dst(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActVlanAttrs::PushEthDst(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActVlanAttrs", "PushEthDst"))
    }
    pub fn get_push_eth_src(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActVlanAttrs::PushEthSrc(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActVlanAttrs", "PushEthSrc"))
    }
}
impl<'a> ActVlanAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, ActVlanAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Tm",
            2u16 => "Parms",
            3u16 => "PushVlanId",
            4u16 => "PushVlanProtocol",
            5u16 => "Pad",
            6u16 => "PushVlanPriority",
            7u16 => "PushEthDst",
            8u16 => "PushEthSrc",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, ActVlanAttrs<'a>> {
    type Item = Result<ActVlanAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => ActVlanAttrs::Tm({
                    let res = PushTcfT::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => ActVlanAttrs::Parms({
                    let res = PushTcVlan::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => ActVlanAttrs::PushVlanId({
                    let res = parse_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => ActVlanAttrs::PushVlanProtocol({
                    let res = parse_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => ActVlanAttrs::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => ActVlanAttrs::PushVlanPriority({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => ActVlanAttrs::PushEthDst({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => ActVlanAttrs::PushEthSrc({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "ActVlanAttrs",
            r#type.and_then(|t| ActVlanAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, ActVlanAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("ActVlanAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                ActVlanAttrs::Tm(val) => fmt.field("Tm", &val),
                ActVlanAttrs::Parms(val) => fmt.field("Parms", &val),
                ActVlanAttrs::PushVlanId(val) => fmt.field("PushVlanId", &val),
                ActVlanAttrs::PushVlanProtocol(val) => fmt.field("PushVlanProtocol", &val),
                ActVlanAttrs::Pad(val) => fmt.field("Pad", &val),
                ActVlanAttrs::PushVlanPriority(val) => fmt.field("PushVlanPriority", &val),
                ActVlanAttrs::PushEthDst(val) => fmt.field("PushEthDst", &val),
                ActVlanAttrs::PushEthSrc(val) => fmt.field("PushEthSrc", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, ActVlanAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("ActVlanAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| ActVlanAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                ActVlanAttrs::Tm(val) => {
                    if last_off == offset {
                        stack.push(("Tm", last_off));
                        break;
                    }
                }
                ActVlanAttrs::Parms(val) => {
                    if last_off == offset {
                        stack.push(("Parms", last_off));
                        break;
                    }
                }
                ActVlanAttrs::PushVlanId(val) => {
                    if last_off == offset {
                        stack.push(("PushVlanId", last_off));
                        break;
                    }
                }
                ActVlanAttrs::PushVlanProtocol(val) => {
                    if last_off == offset {
                        stack.push(("PushVlanProtocol", last_off));
                        break;
                    }
                }
                ActVlanAttrs::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                ActVlanAttrs::PushVlanPriority(val) => {
                    if last_off == offset {
                        stack.push(("PushVlanPriority", last_off));
                        break;
                    }
                }
                ActVlanAttrs::PushEthDst(val) => {
                    if last_off == offset {
                        stack.push(("PushEthDst", last_off));
                        break;
                    }
                }
                ActVlanAttrs::PushEthSrc(val) => {
                    if last_off == offset {
                        stack.push(("PushEthSrc", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("ActVlanAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"basic-attrs\""]
#[derive(Clone)]
pub enum BasicAttrs<'a> {
    Classid(u32),
    Ematches(Iterable<'a, EmatchAttrs<'a>>),
    Act(Iterable<'a, Iterable<'a, ActAttrs<'a>>>),
    Police(Iterable<'a, PoliceAttrs<'a>>),
    Pcnt(PushTcBasicPcnt),
    Pad(&'a [u8]),
}
impl<'a> Iterable<'a, BasicAttrs<'a>> {
    pub fn get_classid(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let BasicAttrs::Classid(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("BasicAttrs", "Classid"))
    }
    pub fn get_ematches(&self) -> Result<Iterable<'a, EmatchAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let BasicAttrs::Ematches(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("BasicAttrs", "Ematches"))
    }
    pub fn get_act(
        &self,
    ) -> Result<
        ArrayIterable<Iterable<'a, Iterable<'a, ActAttrs<'a>>>, Iterable<'a, ActAttrs<'a>>>,
        ErrorContext,
    > {
        for attr in self.clone() {
            if let BasicAttrs::Act(val) = attr? {
                return Ok(ArrayIterable::new(val));
            }
        }
        Err(self.error_missing("BasicAttrs", "Act"))
    }
    pub fn get_police(&self) -> Result<Iterable<'a, PoliceAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let BasicAttrs::Police(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("BasicAttrs", "Police"))
    }
    pub fn get_pcnt(&self) -> Result<PushTcBasicPcnt, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let BasicAttrs::Pcnt(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("BasicAttrs", "Pcnt"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let BasicAttrs::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("BasicAttrs", "Pad"))
    }
}
impl<'a> ActAttrs<'a> {
    pub fn new_array(buf: &'a [u8]) -> Iterable<'a, Iterable<'a, ActAttrs<'a>>> {
        Iterable::new(buf)
    }
}
impl<'a> Iterator for Iterable<'a, Iterable<'a, ActAttrs<'a>>> {
    type Item = Result<Iterable<'a, ActAttrs<'a>>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            {
                return Some(Ok(Iterable::with_loc(next, self.orig_loc)));
            }
        }
        Some(Err(self.error_context(
            "ActAttrs",
            None,
            self.buf.as_ptr().wrapping_add(self.pos),
        )))
    }
}
impl<'a> BasicAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, BasicAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Classid",
            2u16 => "Ematches",
            3u16 => "Act",
            4u16 => "Police",
            5u16 => "Pcnt",
            6u16 => "Pad",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, BasicAttrs<'a>> {
    type Item = Result<BasicAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => BasicAttrs::Classid({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => BasicAttrs::Ematches({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => BasicAttrs::Act({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => BasicAttrs::Police({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => BasicAttrs::Pcnt({
                    let res = PushTcBasicPcnt::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => BasicAttrs::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "BasicAttrs",
            r#type.and_then(|t| BasicAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, Iterable<'a, ActAttrs<'a>>> {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_list()
            .entries(self.clone().map(FlattenErrorContext))
            .finish()
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, BasicAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("BasicAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                BasicAttrs::Classid(val) => fmt.field("Classid", &val),
                BasicAttrs::Ematches(val) => fmt.field("Ematches", &val),
                BasicAttrs::Act(val) => fmt.field("Act", &val),
                BasicAttrs::Police(val) => fmt.field("Police", &val),
                BasicAttrs::Pcnt(val) => fmt.field("Pcnt", &val),
                BasicAttrs::Pad(val) => fmt.field("Pad", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, BasicAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("BasicAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| BasicAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                BasicAttrs::Classid(val) => {
                    if last_off == offset {
                        stack.push(("Classid", last_off));
                        break;
                    }
                }
                BasicAttrs::Ematches(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                BasicAttrs::Act(val) => {
                    for entry in val {
                        let Ok(attr) = entry else { break };
                        (stack, missing) = attr.lookup_attr(offset, missing_type);
                        if !stack.is_empty() {
                            break;
                        }
                    }
                    if !stack.is_empty() {
                        stack.push(("Act", last_off));
                        break;
                    }
                }
                BasicAttrs::Police(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                BasicAttrs::Pcnt(val) => {
                    if last_off == offset {
                        stack.push(("Pcnt", last_off));
                        break;
                    }
                }
                BasicAttrs::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("BasicAttrs", cur));
        }
        (stack, missing)
    }
}
#[doc = "Original name: \"bpf-attrs\""]
#[derive(Clone)]
pub enum BpfAttrs<'a> {
    Act(Iterable<'a, Iterable<'a, ActAttrs<'a>>>),
    Police(Iterable<'a, PoliceAttrs<'a>>),
    Classid(u32),
    OpsLen(u16),
    Ops(&'a [u8]),
    Fd(u32),
    Name(&'a CStr),
    Flags(u32),
    FlagsGen(u32),
    Tag(&'a [u8]),
    Id(u32),
}
impl<'a> Iterable<'a, BpfAttrs<'a>> {
    pub fn get_act(
        &self,
    ) -> Result<
        ArrayIterable<Iterable<'a, Iterable<'a, ActAttrs<'a>>>, Iterable<'a, ActAttrs<'a>>>,
        ErrorContext,
    > {
        for attr in self.clone() {
            if let BpfAttrs::Act(val) = attr? {
                return Ok(ArrayIterable::new(val));
            }
        }
        Err(self.error_missing("BpfAttrs", "Act"))
    }
    pub fn get_police(&self) -> Result<Iterable<'a, PoliceAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let BpfAttrs::Police(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("BpfAttrs", "Police"))
    }
    pub fn get_classid(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let BpfAttrs::Classid(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("BpfAttrs", "Classid"))
    }
    pub fn get_ops_len(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let BpfAttrs::OpsLen(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("BpfAttrs", "OpsLen"))
    }
    pub fn get_ops(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let BpfAttrs::Ops(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("BpfAttrs", "Ops"))
    }
    pub fn get_fd(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let BpfAttrs::Fd(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("BpfAttrs", "Fd"))
    }
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let BpfAttrs::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("BpfAttrs", "Name"))
    }
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let BpfAttrs::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("BpfAttrs", "Flags"))
    }
    pub fn get_flags_gen(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let BpfAttrs::FlagsGen(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("BpfAttrs", "FlagsGen"))
    }
    pub fn get_tag(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let BpfAttrs::Tag(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("BpfAttrs", "Tag"))
    }
    pub fn get_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let BpfAttrs::Id(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("BpfAttrs", "Id"))
    }
}
impl<'a> BpfAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, BpfAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Act",
            2u16 => "Police",
            3u16 => "Classid",
            4u16 => "OpsLen",
            5u16 => "Ops",
            6u16 => "Fd",
            7u16 => "Name",
            8u16 => "Flags",
            9u16 => "FlagsGen",
            10u16 => "Tag",
            11u16 => "Id",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, BpfAttrs<'a>> {
    type Item = Result<BpfAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => BpfAttrs::Act({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => BpfAttrs::Police({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => BpfAttrs::Classid({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => BpfAttrs::OpsLen({
                    let res = parse_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => BpfAttrs::Ops({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => BpfAttrs::Fd({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => BpfAttrs::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => BpfAttrs::Flags({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => BpfAttrs::FlagsGen({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => BpfAttrs::Tag({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => BpfAttrs::Id({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "BpfAttrs",
            r#type.and_then(|t| BpfAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, BpfAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("BpfAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                BpfAttrs::Act(val) => fmt.field("Act", &val),
                BpfAttrs::Police(val) => fmt.field("Police", &val),
                BpfAttrs::Classid(val) => fmt.field("Classid", &val),
                BpfAttrs::OpsLen(val) => fmt.field("OpsLen", &val),
                BpfAttrs::Ops(val) => fmt.field("Ops", &val),
                BpfAttrs::Fd(val) => fmt.field("Fd", &val),
                BpfAttrs::Name(val) => fmt.field("Name", &val),
                BpfAttrs::Flags(val) => fmt.field("Flags", &val),
                BpfAttrs::FlagsGen(val) => fmt.field("FlagsGen", &val),
                BpfAttrs::Tag(val) => fmt.field("Tag", &val),
                BpfAttrs::Id(val) => fmt.field("Id", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, BpfAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("BpfAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| BpfAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                BpfAttrs::Act(val) => {
                    for entry in val {
                        let Ok(attr) = entry else { break };
                        (stack, missing) = attr.lookup_attr(offset, missing_type);
                        if !stack.is_empty() {
                            break;
                        }
                    }
                    if !stack.is_empty() {
                        stack.push(("Act", last_off));
                        break;
                    }
                }
                BpfAttrs::Police(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                BpfAttrs::Classid(val) => {
                    if last_off == offset {
                        stack.push(("Classid", last_off));
                        break;
                    }
                }
                BpfAttrs::OpsLen(val) => {
                    if last_off == offset {
                        stack.push(("OpsLen", last_off));
                        break;
                    }
                }
                BpfAttrs::Ops(val) => {
                    if last_off == offset {
                        stack.push(("Ops", last_off));
                        break;
                    }
                }
                BpfAttrs::Fd(val) => {
                    if last_off == offset {
                        stack.push(("Fd", last_off));
                        break;
                    }
                }
                BpfAttrs::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                BpfAttrs::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                BpfAttrs::FlagsGen(val) => {
                    if last_off == offset {
                        stack.push(("FlagsGen", last_off));
                        break;
                    }
                }
                BpfAttrs::Tag(val) => {
                    if last_off == offset {
                        stack.push(("Tag", last_off));
                        break;
                    }
                }
                BpfAttrs::Id(val) => {
                    if last_off == offset {
                        stack.push(("Id", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("BpfAttrs", cur));
        }
        (stack, missing)
    }
}
#[doc = "Original name: \"cake-attrs\""]
#[derive(Clone)]
pub enum CakeAttrs<'a> {
    Pad(&'a [u8]),
    BaseRate64(u64),
    DiffservMode(u32),
    Atm(u32),
    FlowMode(u32),
    Overhead(u32),
    Rtt(u32),
    Target(u32),
    Autorate(u32),
    Memory(u32),
    Nat(u32),
    Raw(u32),
    Wash(u32),
    Mpu(u32),
    Ingress(u32),
    AckFilter(u32),
    SplitGso(u32),
    Fwmark(u32),
}
impl<'a> Iterable<'a, CakeAttrs<'a>> {
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CakeAttrs::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CakeAttrs", "Pad"))
    }
    pub fn get_base_rate64(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CakeAttrs::BaseRate64(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CakeAttrs", "BaseRate64"))
    }
    pub fn get_diffserv_mode(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CakeAttrs::DiffservMode(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CakeAttrs", "DiffservMode"))
    }
    pub fn get_atm(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CakeAttrs::Atm(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CakeAttrs", "Atm"))
    }
    pub fn get_flow_mode(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CakeAttrs::FlowMode(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CakeAttrs", "FlowMode"))
    }
    pub fn get_overhead(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CakeAttrs::Overhead(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CakeAttrs", "Overhead"))
    }
    pub fn get_rtt(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CakeAttrs::Rtt(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CakeAttrs", "Rtt"))
    }
    pub fn get_target(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CakeAttrs::Target(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CakeAttrs", "Target"))
    }
    pub fn get_autorate(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CakeAttrs::Autorate(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CakeAttrs", "Autorate"))
    }
    pub fn get_memory(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CakeAttrs::Memory(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CakeAttrs", "Memory"))
    }
    pub fn get_nat(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CakeAttrs::Nat(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CakeAttrs", "Nat"))
    }
    pub fn get_raw(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CakeAttrs::Raw(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CakeAttrs", "Raw"))
    }
    pub fn get_wash(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CakeAttrs::Wash(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CakeAttrs", "Wash"))
    }
    pub fn get_mpu(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CakeAttrs::Mpu(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CakeAttrs", "Mpu"))
    }
    pub fn get_ingress(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CakeAttrs::Ingress(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CakeAttrs", "Ingress"))
    }
    pub fn get_ack_filter(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CakeAttrs::AckFilter(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CakeAttrs", "AckFilter"))
    }
    pub fn get_split_gso(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CakeAttrs::SplitGso(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CakeAttrs", "SplitGso"))
    }
    pub fn get_fwmark(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CakeAttrs::Fwmark(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CakeAttrs", "Fwmark"))
    }
}
impl<'a> CakeAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, CakeAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Pad",
            2u16 => "BaseRate64",
            3u16 => "DiffservMode",
            4u16 => "Atm",
            5u16 => "FlowMode",
            6u16 => "Overhead",
            7u16 => "Rtt",
            8u16 => "Target",
            9u16 => "Autorate",
            10u16 => "Memory",
            11u16 => "Nat",
            12u16 => "Raw",
            13u16 => "Wash",
            14u16 => "Mpu",
            15u16 => "Ingress",
            16u16 => "AckFilter",
            17u16 => "SplitGso",
            18u16 => "Fwmark",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, CakeAttrs<'a>> {
    type Item = Result<CakeAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => CakeAttrs::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => CakeAttrs::BaseRate64({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => CakeAttrs::DiffservMode({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => CakeAttrs::Atm({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => CakeAttrs::FlowMode({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => CakeAttrs::Overhead({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => CakeAttrs::Rtt({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => CakeAttrs::Target({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => CakeAttrs::Autorate({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => CakeAttrs::Memory({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => CakeAttrs::Nat({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                12u16 => CakeAttrs::Raw({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                13u16 => CakeAttrs::Wash({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                14u16 => CakeAttrs::Mpu({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                15u16 => CakeAttrs::Ingress({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                16u16 => CakeAttrs::AckFilter({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                17u16 => CakeAttrs::SplitGso({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                18u16 => CakeAttrs::Fwmark({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "CakeAttrs",
            r#type.and_then(|t| CakeAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, CakeAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("CakeAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                CakeAttrs::Pad(val) => fmt.field("Pad", &val),
                CakeAttrs::BaseRate64(val) => fmt.field("BaseRate64", &val),
                CakeAttrs::DiffservMode(val) => fmt.field("DiffservMode", &val),
                CakeAttrs::Atm(val) => fmt.field("Atm", &val),
                CakeAttrs::FlowMode(val) => fmt.field("FlowMode", &val),
                CakeAttrs::Overhead(val) => fmt.field("Overhead", &val),
                CakeAttrs::Rtt(val) => fmt.field("Rtt", &val),
                CakeAttrs::Target(val) => fmt.field("Target", &val),
                CakeAttrs::Autorate(val) => fmt.field("Autorate", &val),
                CakeAttrs::Memory(val) => fmt.field("Memory", &val),
                CakeAttrs::Nat(val) => fmt.field("Nat", &val),
                CakeAttrs::Raw(val) => fmt.field("Raw", &val),
                CakeAttrs::Wash(val) => fmt.field("Wash", &val),
                CakeAttrs::Mpu(val) => fmt.field("Mpu", &val),
                CakeAttrs::Ingress(val) => fmt.field("Ingress", &val),
                CakeAttrs::AckFilter(val) => fmt.field("AckFilter", &val),
                CakeAttrs::SplitGso(val) => fmt.field("SplitGso", &val),
                CakeAttrs::Fwmark(val) => fmt.field("Fwmark", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, CakeAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("CakeAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| CakeAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                CakeAttrs::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                CakeAttrs::BaseRate64(val) => {
                    if last_off == offset {
                        stack.push(("BaseRate64", last_off));
                        break;
                    }
                }
                CakeAttrs::DiffservMode(val) => {
                    if last_off == offset {
                        stack.push(("DiffservMode", last_off));
                        break;
                    }
                }
                CakeAttrs::Atm(val) => {
                    if last_off == offset {
                        stack.push(("Atm", last_off));
                        break;
                    }
                }
                CakeAttrs::FlowMode(val) => {
                    if last_off == offset {
                        stack.push(("FlowMode", last_off));
                        break;
                    }
                }
                CakeAttrs::Overhead(val) => {
                    if last_off == offset {
                        stack.push(("Overhead", last_off));
                        break;
                    }
                }
                CakeAttrs::Rtt(val) => {
                    if last_off == offset {
                        stack.push(("Rtt", last_off));
                        break;
                    }
                }
                CakeAttrs::Target(val) => {
                    if last_off == offset {
                        stack.push(("Target", last_off));
                        break;
                    }
                }
                CakeAttrs::Autorate(val) => {
                    if last_off == offset {
                        stack.push(("Autorate", last_off));
                        break;
                    }
                }
                CakeAttrs::Memory(val) => {
                    if last_off == offset {
                        stack.push(("Memory", last_off));
                        break;
                    }
                }
                CakeAttrs::Nat(val) => {
                    if last_off == offset {
                        stack.push(("Nat", last_off));
                        break;
                    }
                }
                CakeAttrs::Raw(val) => {
                    if last_off == offset {
                        stack.push(("Raw", last_off));
                        break;
                    }
                }
                CakeAttrs::Wash(val) => {
                    if last_off == offset {
                        stack.push(("Wash", last_off));
                        break;
                    }
                }
                CakeAttrs::Mpu(val) => {
                    if last_off == offset {
                        stack.push(("Mpu", last_off));
                        break;
                    }
                }
                CakeAttrs::Ingress(val) => {
                    if last_off == offset {
                        stack.push(("Ingress", last_off));
                        break;
                    }
                }
                CakeAttrs::AckFilter(val) => {
                    if last_off == offset {
                        stack.push(("AckFilter", last_off));
                        break;
                    }
                }
                CakeAttrs::SplitGso(val) => {
                    if last_off == offset {
                        stack.push(("SplitGso", last_off));
                        break;
                    }
                }
                CakeAttrs::Fwmark(val) => {
                    if last_off == offset {
                        stack.push(("Fwmark", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("CakeAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"cake-stats-attrs\""]
#[derive(Clone)]
pub enum CakeStatsAttrs<'a> {
    Pad(&'a [u8]),
    CapacityEstimate64(u64),
    MemoryLimit(u32),
    MemoryUsed(u32),
    AvgNetoff(u32),
    MinNetlen(u32),
    MaxNetlen(u32),
    MinAdjlen(u32),
    MaxAdjlen(u32),
    TinStats(Iterable<'a, Iterable<'a, CakeTinStatsAttrs<'a>>>),
    Deficit(i32),
    CobaltCount(u32),
    Dropping(u32),
    DropNextUs(i32),
    PDrop(u32),
    BlueTimerUs(i32),
}
impl<'a> Iterable<'a, CakeStatsAttrs<'a>> {
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CakeStatsAttrs::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CakeStatsAttrs", "Pad"))
    }
    pub fn get_capacity_estimate64(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CakeStatsAttrs::CapacityEstimate64(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CakeStatsAttrs", "CapacityEstimate64"))
    }
    pub fn get_memory_limit(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CakeStatsAttrs::MemoryLimit(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CakeStatsAttrs", "MemoryLimit"))
    }
    pub fn get_memory_used(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CakeStatsAttrs::MemoryUsed(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CakeStatsAttrs", "MemoryUsed"))
    }
    pub fn get_avg_netoff(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CakeStatsAttrs::AvgNetoff(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CakeStatsAttrs", "AvgNetoff"))
    }
    pub fn get_min_netlen(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CakeStatsAttrs::MinNetlen(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CakeStatsAttrs", "MinNetlen"))
    }
    pub fn get_max_netlen(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CakeStatsAttrs::MaxNetlen(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CakeStatsAttrs", "MaxNetlen"))
    }
    pub fn get_min_adjlen(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CakeStatsAttrs::MinAdjlen(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CakeStatsAttrs", "MinAdjlen"))
    }
    pub fn get_max_adjlen(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CakeStatsAttrs::MaxAdjlen(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CakeStatsAttrs", "MaxAdjlen"))
    }
    pub fn get_tin_stats(
        &self,
    ) -> Result<
        ArrayIterable<
            Iterable<'a, Iterable<'a, CakeTinStatsAttrs<'a>>>,
            Iterable<'a, CakeTinStatsAttrs<'a>>,
        >,
        ErrorContext,
    > {
        for attr in self.clone() {
            if let CakeStatsAttrs::TinStats(val) = attr? {
                return Ok(ArrayIterable::new(val));
            }
        }
        Err(self.error_missing("CakeStatsAttrs", "TinStats"))
    }
    pub fn get_deficit(&self) -> Result<i32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CakeStatsAttrs::Deficit(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CakeStatsAttrs", "Deficit"))
    }
    pub fn get_cobalt_count(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CakeStatsAttrs::CobaltCount(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CakeStatsAttrs", "CobaltCount"))
    }
    pub fn get_dropping(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CakeStatsAttrs::Dropping(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CakeStatsAttrs", "Dropping"))
    }
    pub fn get_drop_next_us(&self) -> Result<i32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CakeStatsAttrs::DropNextUs(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CakeStatsAttrs", "DropNextUs"))
    }
    pub fn get_p_drop(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CakeStatsAttrs::PDrop(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CakeStatsAttrs", "PDrop"))
    }
    pub fn get_blue_timer_us(&self) -> Result<i32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CakeStatsAttrs::BlueTimerUs(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CakeStatsAttrs", "BlueTimerUs"))
    }
}
impl<'a> CakeTinStatsAttrs<'a> {
    pub fn new_array(buf: &'a [u8]) -> Iterable<'a, Iterable<'a, CakeTinStatsAttrs<'a>>> {
        Iterable::new(buf)
    }
}
impl<'a> Iterator for Iterable<'a, Iterable<'a, CakeTinStatsAttrs<'a>>> {
    type Item = Result<Iterable<'a, CakeTinStatsAttrs<'a>>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            {
                return Some(Ok(Iterable::with_loc(next, self.orig_loc)));
            }
        }
        Some(Err(self.error_context(
            "CakeTinStatsAttrs",
            None,
            self.buf.as_ptr().wrapping_add(self.pos),
        )))
    }
}
impl<'a> CakeStatsAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, CakeStatsAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Pad",
            2u16 => "CapacityEstimate64",
            3u16 => "MemoryLimit",
            4u16 => "MemoryUsed",
            5u16 => "AvgNetoff",
            6u16 => "MinNetlen",
            7u16 => "MaxNetlen",
            8u16 => "MinAdjlen",
            9u16 => "MaxAdjlen",
            10u16 => "TinStats",
            11u16 => "Deficit",
            12u16 => "CobaltCount",
            13u16 => "Dropping",
            14u16 => "DropNextUs",
            15u16 => "PDrop",
            16u16 => "BlueTimerUs",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, CakeStatsAttrs<'a>> {
    type Item = Result<CakeStatsAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => CakeStatsAttrs::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => CakeStatsAttrs::CapacityEstimate64({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => CakeStatsAttrs::MemoryLimit({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => CakeStatsAttrs::MemoryUsed({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => CakeStatsAttrs::AvgNetoff({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => CakeStatsAttrs::MinNetlen({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => CakeStatsAttrs::MaxNetlen({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => CakeStatsAttrs::MinAdjlen({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => CakeStatsAttrs::MaxAdjlen({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => CakeStatsAttrs::TinStats({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => CakeStatsAttrs::Deficit({
                    let res = parse_i32(next);
                    let Some(val) = res else { break };
                    val
                }),
                12u16 => CakeStatsAttrs::CobaltCount({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                13u16 => CakeStatsAttrs::Dropping({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                14u16 => CakeStatsAttrs::DropNextUs({
                    let res = parse_i32(next);
                    let Some(val) = res else { break };
                    val
                }),
                15u16 => CakeStatsAttrs::PDrop({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                16u16 => CakeStatsAttrs::BlueTimerUs({
                    let res = parse_i32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "CakeStatsAttrs",
            r#type.and_then(|t| CakeStatsAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, Iterable<'a, CakeTinStatsAttrs<'a>>> {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_list()
            .entries(self.clone().map(FlattenErrorContext))
            .finish()
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, CakeStatsAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("CakeStatsAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                CakeStatsAttrs::Pad(val) => fmt.field("Pad", &val),
                CakeStatsAttrs::CapacityEstimate64(val) => fmt.field("CapacityEstimate64", &val),
                CakeStatsAttrs::MemoryLimit(val) => fmt.field("MemoryLimit", &val),
                CakeStatsAttrs::MemoryUsed(val) => fmt.field("MemoryUsed", &val),
                CakeStatsAttrs::AvgNetoff(val) => fmt.field("AvgNetoff", &val),
                CakeStatsAttrs::MinNetlen(val) => fmt.field("MinNetlen", &val),
                CakeStatsAttrs::MaxNetlen(val) => fmt.field("MaxNetlen", &val),
                CakeStatsAttrs::MinAdjlen(val) => fmt.field("MinAdjlen", &val),
                CakeStatsAttrs::MaxAdjlen(val) => fmt.field("MaxAdjlen", &val),
                CakeStatsAttrs::TinStats(val) => fmt.field("TinStats", &val),
                CakeStatsAttrs::Deficit(val) => fmt.field("Deficit", &val),
                CakeStatsAttrs::CobaltCount(val) => fmt.field("CobaltCount", &val),
                CakeStatsAttrs::Dropping(val) => fmt.field("Dropping", &val),
                CakeStatsAttrs::DropNextUs(val) => fmt.field("DropNextUs", &val),
                CakeStatsAttrs::PDrop(val) => fmt.field("PDrop", &val),
                CakeStatsAttrs::BlueTimerUs(val) => fmt.field("BlueTimerUs", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, CakeStatsAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("CakeStatsAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| CakeStatsAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                CakeStatsAttrs::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                CakeStatsAttrs::CapacityEstimate64(val) => {
                    if last_off == offset {
                        stack.push(("CapacityEstimate64", last_off));
                        break;
                    }
                }
                CakeStatsAttrs::MemoryLimit(val) => {
                    if last_off == offset {
                        stack.push(("MemoryLimit", last_off));
                        break;
                    }
                }
                CakeStatsAttrs::MemoryUsed(val) => {
                    if last_off == offset {
                        stack.push(("MemoryUsed", last_off));
                        break;
                    }
                }
                CakeStatsAttrs::AvgNetoff(val) => {
                    if last_off == offset {
                        stack.push(("AvgNetoff", last_off));
                        break;
                    }
                }
                CakeStatsAttrs::MinNetlen(val) => {
                    if last_off == offset {
                        stack.push(("MinNetlen", last_off));
                        break;
                    }
                }
                CakeStatsAttrs::MaxNetlen(val) => {
                    if last_off == offset {
                        stack.push(("MaxNetlen", last_off));
                        break;
                    }
                }
                CakeStatsAttrs::MinAdjlen(val) => {
                    if last_off == offset {
                        stack.push(("MinAdjlen", last_off));
                        break;
                    }
                }
                CakeStatsAttrs::MaxAdjlen(val) => {
                    if last_off == offset {
                        stack.push(("MaxAdjlen", last_off));
                        break;
                    }
                }
                CakeStatsAttrs::TinStats(val) => {
                    for entry in val {
                        let Ok(attr) = entry else { break };
                        (stack, missing) = attr.lookup_attr(offset, missing_type);
                        if !stack.is_empty() {
                            break;
                        }
                    }
                    if !stack.is_empty() {
                        stack.push(("TinStats", last_off));
                        break;
                    }
                }
                CakeStatsAttrs::Deficit(val) => {
                    if last_off == offset {
                        stack.push(("Deficit", last_off));
                        break;
                    }
                }
                CakeStatsAttrs::CobaltCount(val) => {
                    if last_off == offset {
                        stack.push(("CobaltCount", last_off));
                        break;
                    }
                }
                CakeStatsAttrs::Dropping(val) => {
                    if last_off == offset {
                        stack.push(("Dropping", last_off));
                        break;
                    }
                }
                CakeStatsAttrs::DropNextUs(val) => {
                    if last_off == offset {
                        stack.push(("DropNextUs", last_off));
                        break;
                    }
                }
                CakeStatsAttrs::PDrop(val) => {
                    if last_off == offset {
                        stack.push(("PDrop", last_off));
                        break;
                    }
                }
                CakeStatsAttrs::BlueTimerUs(val) => {
                    if last_off == offset {
                        stack.push(("BlueTimerUs", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("CakeStatsAttrs", cur));
        }
        (stack, missing)
    }
}
#[doc = "Original name: \"cake-tin-stats-attrs\""]
#[derive(Clone)]
pub enum CakeTinStatsAttrs<'a> {
    Pad(&'a [u8]),
    SentPackets(u32),
    SentBytes64(u64),
    DroppedPackets(u32),
    DroppedBytes64(u64),
    AcksDroppedPackets(u32),
    AcksDroppedBytes64(u64),
    EcnMarkedPackets(u32),
    EcnMarkedBytes64(u64),
    BacklogPackets(u32),
    BacklogBytes(u32),
    ThresholdRate64(u64),
    TargetUs(u32),
    IntervalUs(u32),
    WayIndirectHits(u32),
    WayMisses(u32),
    WayCollisions(u32),
    PeakDelayUs(u32),
    AvgDelayUs(u32),
    BaseDelayUs(u32),
    SparseFlows(u32),
    BulkFlows(u32),
    UnresponsiveFlows(u32),
    MaxSkblen(u32),
    FlowQuantum(u32),
}
impl<'a> Iterable<'a, CakeTinStatsAttrs<'a>> {
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CakeTinStatsAttrs::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CakeTinStatsAttrs", "Pad"))
    }
    pub fn get_sent_packets(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CakeTinStatsAttrs::SentPackets(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CakeTinStatsAttrs", "SentPackets"))
    }
    pub fn get_sent_bytes64(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CakeTinStatsAttrs::SentBytes64(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CakeTinStatsAttrs", "SentBytes64"))
    }
    pub fn get_dropped_packets(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CakeTinStatsAttrs::DroppedPackets(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CakeTinStatsAttrs", "DroppedPackets"))
    }
    pub fn get_dropped_bytes64(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CakeTinStatsAttrs::DroppedBytes64(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CakeTinStatsAttrs", "DroppedBytes64"))
    }
    pub fn get_acks_dropped_packets(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CakeTinStatsAttrs::AcksDroppedPackets(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CakeTinStatsAttrs", "AcksDroppedPackets"))
    }
    pub fn get_acks_dropped_bytes64(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CakeTinStatsAttrs::AcksDroppedBytes64(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CakeTinStatsAttrs", "AcksDroppedBytes64"))
    }
    pub fn get_ecn_marked_packets(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CakeTinStatsAttrs::EcnMarkedPackets(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CakeTinStatsAttrs", "EcnMarkedPackets"))
    }
    pub fn get_ecn_marked_bytes64(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CakeTinStatsAttrs::EcnMarkedBytes64(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CakeTinStatsAttrs", "EcnMarkedBytes64"))
    }
    pub fn get_backlog_packets(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CakeTinStatsAttrs::BacklogPackets(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CakeTinStatsAttrs", "BacklogPackets"))
    }
    pub fn get_backlog_bytes(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CakeTinStatsAttrs::BacklogBytes(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CakeTinStatsAttrs", "BacklogBytes"))
    }
    pub fn get_threshold_rate64(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CakeTinStatsAttrs::ThresholdRate64(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CakeTinStatsAttrs", "ThresholdRate64"))
    }
    pub fn get_target_us(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CakeTinStatsAttrs::TargetUs(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CakeTinStatsAttrs", "TargetUs"))
    }
    pub fn get_interval_us(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CakeTinStatsAttrs::IntervalUs(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CakeTinStatsAttrs", "IntervalUs"))
    }
    pub fn get_way_indirect_hits(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CakeTinStatsAttrs::WayIndirectHits(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CakeTinStatsAttrs", "WayIndirectHits"))
    }
    pub fn get_way_misses(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CakeTinStatsAttrs::WayMisses(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CakeTinStatsAttrs", "WayMisses"))
    }
    pub fn get_way_collisions(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CakeTinStatsAttrs::WayCollisions(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CakeTinStatsAttrs", "WayCollisions"))
    }
    pub fn get_peak_delay_us(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CakeTinStatsAttrs::PeakDelayUs(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CakeTinStatsAttrs", "PeakDelayUs"))
    }
    pub fn get_avg_delay_us(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CakeTinStatsAttrs::AvgDelayUs(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CakeTinStatsAttrs", "AvgDelayUs"))
    }
    pub fn get_base_delay_us(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CakeTinStatsAttrs::BaseDelayUs(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CakeTinStatsAttrs", "BaseDelayUs"))
    }
    pub fn get_sparse_flows(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CakeTinStatsAttrs::SparseFlows(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CakeTinStatsAttrs", "SparseFlows"))
    }
    pub fn get_bulk_flows(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CakeTinStatsAttrs::BulkFlows(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CakeTinStatsAttrs", "BulkFlows"))
    }
    pub fn get_unresponsive_flows(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CakeTinStatsAttrs::UnresponsiveFlows(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CakeTinStatsAttrs", "UnresponsiveFlows"))
    }
    pub fn get_max_skblen(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CakeTinStatsAttrs::MaxSkblen(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CakeTinStatsAttrs", "MaxSkblen"))
    }
    pub fn get_flow_quantum(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CakeTinStatsAttrs::FlowQuantum(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CakeTinStatsAttrs", "FlowQuantum"))
    }
}
impl<'a> CakeTinStatsAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, CakeTinStatsAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Pad",
            2u16 => "SentPackets",
            3u16 => "SentBytes64",
            4u16 => "DroppedPackets",
            5u16 => "DroppedBytes64",
            6u16 => "AcksDroppedPackets",
            7u16 => "AcksDroppedBytes64",
            8u16 => "EcnMarkedPackets",
            9u16 => "EcnMarkedBytes64",
            10u16 => "BacklogPackets",
            11u16 => "BacklogBytes",
            12u16 => "ThresholdRate64",
            13u16 => "TargetUs",
            14u16 => "IntervalUs",
            15u16 => "WayIndirectHits",
            16u16 => "WayMisses",
            17u16 => "WayCollisions",
            18u16 => "PeakDelayUs",
            19u16 => "AvgDelayUs",
            20u16 => "BaseDelayUs",
            21u16 => "SparseFlows",
            22u16 => "BulkFlows",
            23u16 => "UnresponsiveFlows",
            24u16 => "MaxSkblen",
            25u16 => "FlowQuantum",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, CakeTinStatsAttrs<'a>> {
    type Item = Result<CakeTinStatsAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => CakeTinStatsAttrs::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => CakeTinStatsAttrs::SentPackets({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => CakeTinStatsAttrs::SentBytes64({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => CakeTinStatsAttrs::DroppedPackets({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => CakeTinStatsAttrs::DroppedBytes64({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => CakeTinStatsAttrs::AcksDroppedPackets({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => CakeTinStatsAttrs::AcksDroppedBytes64({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => CakeTinStatsAttrs::EcnMarkedPackets({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => CakeTinStatsAttrs::EcnMarkedBytes64({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => CakeTinStatsAttrs::BacklogPackets({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => CakeTinStatsAttrs::BacklogBytes({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                12u16 => CakeTinStatsAttrs::ThresholdRate64({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                13u16 => CakeTinStatsAttrs::TargetUs({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                14u16 => CakeTinStatsAttrs::IntervalUs({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                15u16 => CakeTinStatsAttrs::WayIndirectHits({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                16u16 => CakeTinStatsAttrs::WayMisses({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                17u16 => CakeTinStatsAttrs::WayCollisions({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                18u16 => CakeTinStatsAttrs::PeakDelayUs({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                19u16 => CakeTinStatsAttrs::AvgDelayUs({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                20u16 => CakeTinStatsAttrs::BaseDelayUs({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                21u16 => CakeTinStatsAttrs::SparseFlows({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                22u16 => CakeTinStatsAttrs::BulkFlows({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                23u16 => CakeTinStatsAttrs::UnresponsiveFlows({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                24u16 => CakeTinStatsAttrs::MaxSkblen({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                25u16 => CakeTinStatsAttrs::FlowQuantum({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "CakeTinStatsAttrs",
            r#type.and_then(|t| CakeTinStatsAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, CakeTinStatsAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("CakeTinStatsAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                CakeTinStatsAttrs::Pad(val) => fmt.field("Pad", &val),
                CakeTinStatsAttrs::SentPackets(val) => fmt.field("SentPackets", &val),
                CakeTinStatsAttrs::SentBytes64(val) => fmt.field("SentBytes64", &val),
                CakeTinStatsAttrs::DroppedPackets(val) => fmt.field("DroppedPackets", &val),
                CakeTinStatsAttrs::DroppedBytes64(val) => fmt.field("DroppedBytes64", &val),
                CakeTinStatsAttrs::AcksDroppedPackets(val) => fmt.field("AcksDroppedPackets", &val),
                CakeTinStatsAttrs::AcksDroppedBytes64(val) => fmt.field("AcksDroppedBytes64", &val),
                CakeTinStatsAttrs::EcnMarkedPackets(val) => fmt.field("EcnMarkedPackets", &val),
                CakeTinStatsAttrs::EcnMarkedBytes64(val) => fmt.field("EcnMarkedBytes64", &val),
                CakeTinStatsAttrs::BacklogPackets(val) => fmt.field("BacklogPackets", &val),
                CakeTinStatsAttrs::BacklogBytes(val) => fmt.field("BacklogBytes", &val),
                CakeTinStatsAttrs::ThresholdRate64(val) => fmt.field("ThresholdRate64", &val),
                CakeTinStatsAttrs::TargetUs(val) => fmt.field("TargetUs", &val),
                CakeTinStatsAttrs::IntervalUs(val) => fmt.field("IntervalUs", &val),
                CakeTinStatsAttrs::WayIndirectHits(val) => fmt.field("WayIndirectHits", &val),
                CakeTinStatsAttrs::WayMisses(val) => fmt.field("WayMisses", &val),
                CakeTinStatsAttrs::WayCollisions(val) => fmt.field("WayCollisions", &val),
                CakeTinStatsAttrs::PeakDelayUs(val) => fmt.field("PeakDelayUs", &val),
                CakeTinStatsAttrs::AvgDelayUs(val) => fmt.field("AvgDelayUs", &val),
                CakeTinStatsAttrs::BaseDelayUs(val) => fmt.field("BaseDelayUs", &val),
                CakeTinStatsAttrs::SparseFlows(val) => fmt.field("SparseFlows", &val),
                CakeTinStatsAttrs::BulkFlows(val) => fmt.field("BulkFlows", &val),
                CakeTinStatsAttrs::UnresponsiveFlows(val) => fmt.field("UnresponsiveFlows", &val),
                CakeTinStatsAttrs::MaxSkblen(val) => fmt.field("MaxSkblen", &val),
                CakeTinStatsAttrs::FlowQuantum(val) => fmt.field("FlowQuantum", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, CakeTinStatsAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("CakeTinStatsAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| CakeTinStatsAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                CakeTinStatsAttrs::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                CakeTinStatsAttrs::SentPackets(val) => {
                    if last_off == offset {
                        stack.push(("SentPackets", last_off));
                        break;
                    }
                }
                CakeTinStatsAttrs::SentBytes64(val) => {
                    if last_off == offset {
                        stack.push(("SentBytes64", last_off));
                        break;
                    }
                }
                CakeTinStatsAttrs::DroppedPackets(val) => {
                    if last_off == offset {
                        stack.push(("DroppedPackets", last_off));
                        break;
                    }
                }
                CakeTinStatsAttrs::DroppedBytes64(val) => {
                    if last_off == offset {
                        stack.push(("DroppedBytes64", last_off));
                        break;
                    }
                }
                CakeTinStatsAttrs::AcksDroppedPackets(val) => {
                    if last_off == offset {
                        stack.push(("AcksDroppedPackets", last_off));
                        break;
                    }
                }
                CakeTinStatsAttrs::AcksDroppedBytes64(val) => {
                    if last_off == offset {
                        stack.push(("AcksDroppedBytes64", last_off));
                        break;
                    }
                }
                CakeTinStatsAttrs::EcnMarkedPackets(val) => {
                    if last_off == offset {
                        stack.push(("EcnMarkedPackets", last_off));
                        break;
                    }
                }
                CakeTinStatsAttrs::EcnMarkedBytes64(val) => {
                    if last_off == offset {
                        stack.push(("EcnMarkedBytes64", last_off));
                        break;
                    }
                }
                CakeTinStatsAttrs::BacklogPackets(val) => {
                    if last_off == offset {
                        stack.push(("BacklogPackets", last_off));
                        break;
                    }
                }
                CakeTinStatsAttrs::BacklogBytes(val) => {
                    if last_off == offset {
                        stack.push(("BacklogBytes", last_off));
                        break;
                    }
                }
                CakeTinStatsAttrs::ThresholdRate64(val) => {
                    if last_off == offset {
                        stack.push(("ThresholdRate64", last_off));
                        break;
                    }
                }
                CakeTinStatsAttrs::TargetUs(val) => {
                    if last_off == offset {
                        stack.push(("TargetUs", last_off));
                        break;
                    }
                }
                CakeTinStatsAttrs::IntervalUs(val) => {
                    if last_off == offset {
                        stack.push(("IntervalUs", last_off));
                        break;
                    }
                }
                CakeTinStatsAttrs::WayIndirectHits(val) => {
                    if last_off == offset {
                        stack.push(("WayIndirectHits", last_off));
                        break;
                    }
                }
                CakeTinStatsAttrs::WayMisses(val) => {
                    if last_off == offset {
                        stack.push(("WayMisses", last_off));
                        break;
                    }
                }
                CakeTinStatsAttrs::WayCollisions(val) => {
                    if last_off == offset {
                        stack.push(("WayCollisions", last_off));
                        break;
                    }
                }
                CakeTinStatsAttrs::PeakDelayUs(val) => {
                    if last_off == offset {
                        stack.push(("PeakDelayUs", last_off));
                        break;
                    }
                }
                CakeTinStatsAttrs::AvgDelayUs(val) => {
                    if last_off == offset {
                        stack.push(("AvgDelayUs", last_off));
                        break;
                    }
                }
                CakeTinStatsAttrs::BaseDelayUs(val) => {
                    if last_off == offset {
                        stack.push(("BaseDelayUs", last_off));
                        break;
                    }
                }
                CakeTinStatsAttrs::SparseFlows(val) => {
                    if last_off == offset {
                        stack.push(("SparseFlows", last_off));
                        break;
                    }
                }
                CakeTinStatsAttrs::BulkFlows(val) => {
                    if last_off == offset {
                        stack.push(("BulkFlows", last_off));
                        break;
                    }
                }
                CakeTinStatsAttrs::UnresponsiveFlows(val) => {
                    if last_off == offset {
                        stack.push(("UnresponsiveFlows", last_off));
                        break;
                    }
                }
                CakeTinStatsAttrs::MaxSkblen(val) => {
                    if last_off == offset {
                        stack.push(("MaxSkblen", last_off));
                        break;
                    }
                }
                CakeTinStatsAttrs::FlowQuantum(val) => {
                    if last_off == offset {
                        stack.push(("FlowQuantum", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("CakeTinStatsAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"cbs-attrs\""]
#[derive(Clone)]
pub enum CbsAttrs {
    Parms(PushTcCbsQopt),
}
impl<'a> Iterable<'a, CbsAttrs> {
    pub fn get_parms(&self) -> Result<PushTcCbsQopt, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CbsAttrs::Parms(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CbsAttrs", "Parms"))
    }
}
impl CbsAttrs {
    pub fn new(buf: &'_ [u8]) -> Iterable<'_, CbsAttrs> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Parms",
            _ => return None,
        };
        Some(res)
    }
}
impl Iterator for Iterable<'_, CbsAttrs> {
    type Item = Result<CbsAttrs, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => CbsAttrs::Parms({
                    let res = PushTcCbsQopt::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "CbsAttrs",
            r#type.and_then(|t| CbsAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl std::fmt::Debug for Iterable<'_, CbsAttrs> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("CbsAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                CbsAttrs::Parms(val) => fmt.field("Parms", &val),
            };
        }
        fmt.finish()
    }
}
impl Iterable<'_, CbsAttrs> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("CbsAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| CbsAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                CbsAttrs::Parms(val) => {
                    if last_off == offset {
                        stack.push(("Parms", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("CbsAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"cgroup-attrs\""]
#[derive(Clone)]
pub enum CgroupAttrs<'a> {
    Act(Iterable<'a, Iterable<'a, ActAttrs<'a>>>),
    Police(Iterable<'a, PoliceAttrs<'a>>),
    Ematches(&'a [u8]),
}
impl<'a> Iterable<'a, CgroupAttrs<'a>> {
    pub fn get_act(
        &self,
    ) -> Result<
        ArrayIterable<Iterable<'a, Iterable<'a, ActAttrs<'a>>>, Iterable<'a, ActAttrs<'a>>>,
        ErrorContext,
    > {
        for attr in self.clone() {
            if let CgroupAttrs::Act(val) = attr? {
                return Ok(ArrayIterable::new(val));
            }
        }
        Err(self.error_missing("CgroupAttrs", "Act"))
    }
    pub fn get_police(&self) -> Result<Iterable<'a, PoliceAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CgroupAttrs::Police(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CgroupAttrs", "Police"))
    }
    pub fn get_ematches(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CgroupAttrs::Ematches(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CgroupAttrs", "Ematches"))
    }
}
impl<'a> CgroupAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, CgroupAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Act",
            2u16 => "Police",
            3u16 => "Ematches",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, CgroupAttrs<'a>> {
    type Item = Result<CgroupAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => CgroupAttrs::Act({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => CgroupAttrs::Police({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => CgroupAttrs::Ematches({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "CgroupAttrs",
            r#type.and_then(|t| CgroupAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, CgroupAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("CgroupAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                CgroupAttrs::Act(val) => fmt.field("Act", &val),
                CgroupAttrs::Police(val) => fmt.field("Police", &val),
                CgroupAttrs::Ematches(val) => fmt.field("Ematches", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, CgroupAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("CgroupAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| CgroupAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                CgroupAttrs::Act(val) => {
                    for entry in val {
                        let Ok(attr) = entry else { break };
                        (stack, missing) = attr.lookup_attr(offset, missing_type);
                        if !stack.is_empty() {
                            break;
                        }
                    }
                    if !stack.is_empty() {
                        stack.push(("Act", last_off));
                        break;
                    }
                }
                CgroupAttrs::Police(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                CgroupAttrs::Ematches(val) => {
                    if last_off == offset {
                        stack.push(("Ematches", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("CgroupAttrs", cur));
        }
        (stack, missing)
    }
}
#[doc = "Original name: \"choke-attrs\""]
#[derive(Clone)]
pub enum ChokeAttrs<'a> {
    Parms(PushTcRedQopt),
    Stab(&'a [u8]),
    MaxP(u32),
}
impl<'a> Iterable<'a, ChokeAttrs<'a>> {
    pub fn get_parms(&self) -> Result<PushTcRedQopt, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ChokeAttrs::Parms(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ChokeAttrs", "Parms"))
    }
    pub fn get_stab(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ChokeAttrs::Stab(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ChokeAttrs", "Stab"))
    }
    pub fn get_max_p(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ChokeAttrs::MaxP(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ChokeAttrs", "MaxP"))
    }
}
impl<'a> ChokeAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, ChokeAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Parms",
            2u16 => "Stab",
            3u16 => "MaxP",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, ChokeAttrs<'a>> {
    type Item = Result<ChokeAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => ChokeAttrs::Parms({
                    let res = PushTcRedQopt::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => ChokeAttrs::Stab({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => ChokeAttrs::MaxP({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "ChokeAttrs",
            r#type.and_then(|t| ChokeAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, ChokeAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("ChokeAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                ChokeAttrs::Parms(val) => fmt.field("Parms", &val),
                ChokeAttrs::Stab(val) => fmt.field("Stab", &val),
                ChokeAttrs::MaxP(val) => fmt.field("MaxP", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, ChokeAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("ChokeAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| ChokeAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                ChokeAttrs::Parms(val) => {
                    if last_off == offset {
                        stack.push(("Parms", last_off));
                        break;
                    }
                }
                ChokeAttrs::Stab(val) => {
                    if last_off == offset {
                        stack.push(("Stab", last_off));
                        break;
                    }
                }
                ChokeAttrs::MaxP(val) => {
                    if last_off == offset {
                        stack.push(("MaxP", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("ChokeAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"codel-attrs\""]
#[derive(Clone)]
pub enum CodelAttrs {
    Target(u32),
    Limit(u32),
    Interval(u32),
    Ecn(u32),
    CeThreshold(u32),
}
impl<'a> Iterable<'a, CodelAttrs> {
    pub fn get_target(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CodelAttrs::Target(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CodelAttrs", "Target"))
    }
    pub fn get_limit(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CodelAttrs::Limit(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CodelAttrs", "Limit"))
    }
    pub fn get_interval(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CodelAttrs::Interval(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CodelAttrs", "Interval"))
    }
    pub fn get_ecn(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CodelAttrs::Ecn(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CodelAttrs", "Ecn"))
    }
    pub fn get_ce_threshold(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CodelAttrs::CeThreshold(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("CodelAttrs", "CeThreshold"))
    }
}
impl CodelAttrs {
    pub fn new(buf: &'_ [u8]) -> Iterable<'_, CodelAttrs> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Target",
            2u16 => "Limit",
            3u16 => "Interval",
            4u16 => "Ecn",
            5u16 => "CeThreshold",
            _ => return None,
        };
        Some(res)
    }
}
impl Iterator for Iterable<'_, CodelAttrs> {
    type Item = Result<CodelAttrs, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => CodelAttrs::Target({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => CodelAttrs::Limit({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => CodelAttrs::Interval({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => CodelAttrs::Ecn({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => CodelAttrs::CeThreshold({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "CodelAttrs",
            r#type.and_then(|t| CodelAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl std::fmt::Debug for Iterable<'_, CodelAttrs> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("CodelAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                CodelAttrs::Target(val) => fmt.field("Target", &val),
                CodelAttrs::Limit(val) => fmt.field("Limit", &val),
                CodelAttrs::Interval(val) => fmt.field("Interval", &val),
                CodelAttrs::Ecn(val) => fmt.field("Ecn", &val),
                CodelAttrs::CeThreshold(val) => fmt.field("CeThreshold", &val),
            };
        }
        fmt.finish()
    }
}
impl Iterable<'_, CodelAttrs> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("CodelAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| CodelAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                CodelAttrs::Target(val) => {
                    if last_off == offset {
                        stack.push(("Target", last_off));
                        break;
                    }
                }
                CodelAttrs::Limit(val) => {
                    if last_off == offset {
                        stack.push(("Limit", last_off));
                        break;
                    }
                }
                CodelAttrs::Interval(val) => {
                    if last_off == offset {
                        stack.push(("Interval", last_off));
                        break;
                    }
                }
                CodelAttrs::Ecn(val) => {
                    if last_off == offset {
                        stack.push(("Ecn", last_off));
                        break;
                    }
                }
                CodelAttrs::CeThreshold(val) => {
                    if last_off == offset {
                        stack.push(("CeThreshold", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("CodelAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"drr-attrs\""]
#[derive(Clone)]
pub enum DrrAttrs {
    Quantum(u32),
}
impl<'a> Iterable<'a, DrrAttrs> {
    pub fn get_quantum(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DrrAttrs::Quantum(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("DrrAttrs", "Quantum"))
    }
}
impl DrrAttrs {
    pub fn new(buf: &'_ [u8]) -> Iterable<'_, DrrAttrs> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Quantum",
            _ => return None,
        };
        Some(res)
    }
}
impl Iterator for Iterable<'_, DrrAttrs> {
    type Item = Result<DrrAttrs, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => DrrAttrs::Quantum({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "DrrAttrs",
            r#type.and_then(|t| DrrAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl std::fmt::Debug for Iterable<'_, DrrAttrs> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("DrrAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                DrrAttrs::Quantum(val) => fmt.field("Quantum", &val),
            };
        }
        fmt.finish()
    }
}
impl Iterable<'_, DrrAttrs> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("DrrAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| DrrAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                DrrAttrs::Quantum(val) => {
                    if last_off == offset {
                        stack.push(("Quantum", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("DrrAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"dualpi2-attrs\""]
#[derive(Clone)]
pub enum Dualpi2Attrs {
    #[doc = "Limit of total number of packets in queue"]
    Limit(u32),
    #[doc = "Memory limit of total number of packets in queue"]
    MemoryLimit(u32),
    #[doc = "Classic target delay in microseconds"]
    Target(u32),
    #[doc = "Drop probability update interval time in microseconds"]
    Tupdate(u32),
    #[doc = "Integral gain factor in Hz for PI controller"]
    Alpha(u32),
    #[doc = "Proportional gain factor in Hz for PI controller"]
    Beta(u32),
    #[doc = "L4S step marking threshold in packets"]
    StepThreshPkts(u32),
    #[doc = "L4S Step marking threshold in microseconds"]
    StepThreshUs(u32),
    #[doc = "Packets enqueued to the L-queue can apply the step threshold when the queue length of L-queue is larger than this value. (0 is recommended)"]
    MinQlenStep(u32),
    #[doc = "Probability coupling factor between Classic and L4S (2 is recommended)"]
    Coupling(u8),
    #[doc = "Control the overload strategy (drop to preserve latency or let the queue overflow)\nAssociated type: \"Dualpi2DropOverload\" (enum)"]
    DropOverload(u8),
    #[doc = "Decide where the Classic packets are PI-based dropped or marked\nAssociated type: \"Dualpi2DropEarly\" (enum)"]
    DropEarly(u8),
    #[doc = "Classic WRR weight in percentage (from 0 to 100)"]
    CProtection(u8),
    #[doc = "Configure the L-queue ECN classifier\nAssociated type: \"Dualpi2EcnMask\" (enum)"]
    EcnMask(u8),
    #[doc = "Split aggregated skb or not\nAssociated type: \"Dualpi2SplitGso\" (enum)"]
    SplitGso(u8),
}
impl<'a> Iterable<'a, Dualpi2Attrs> {
    #[doc = "Limit of total number of packets in queue"]
    pub fn get_limit(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Dualpi2Attrs::Limit(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("Dualpi2Attrs", "Limit"))
    }
    #[doc = "Memory limit of total number of packets in queue"]
    pub fn get_memory_limit(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Dualpi2Attrs::MemoryLimit(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("Dualpi2Attrs", "MemoryLimit"))
    }
    #[doc = "Classic target delay in microseconds"]
    pub fn get_target(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Dualpi2Attrs::Target(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("Dualpi2Attrs", "Target"))
    }
    #[doc = "Drop probability update interval time in microseconds"]
    pub fn get_tupdate(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Dualpi2Attrs::Tupdate(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("Dualpi2Attrs", "Tupdate"))
    }
    #[doc = "Integral gain factor in Hz for PI controller"]
    pub fn get_alpha(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Dualpi2Attrs::Alpha(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("Dualpi2Attrs", "Alpha"))
    }
    #[doc = "Proportional gain factor in Hz for PI controller"]
    pub fn get_beta(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Dualpi2Attrs::Beta(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("Dualpi2Attrs", "Beta"))
    }
    #[doc = "L4S step marking threshold in packets"]
    pub fn get_step_thresh_pkts(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Dualpi2Attrs::StepThreshPkts(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("Dualpi2Attrs", "StepThreshPkts"))
    }
    #[doc = "L4S Step marking threshold in microseconds"]
    pub fn get_step_thresh_us(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Dualpi2Attrs::StepThreshUs(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("Dualpi2Attrs", "StepThreshUs"))
    }
    #[doc = "Packets enqueued to the L-queue can apply the step threshold when the queue length of L-queue is larger than this value. (0 is recommended)"]
    pub fn get_min_qlen_step(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Dualpi2Attrs::MinQlenStep(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("Dualpi2Attrs", "MinQlenStep"))
    }
    #[doc = "Probability coupling factor between Classic and L4S (2 is recommended)"]
    pub fn get_coupling(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Dualpi2Attrs::Coupling(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("Dualpi2Attrs", "Coupling"))
    }
    #[doc = "Control the overload strategy (drop to preserve latency or let the queue overflow)\nAssociated type: \"Dualpi2DropOverload\" (enum)"]
    pub fn get_drop_overload(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Dualpi2Attrs::DropOverload(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("Dualpi2Attrs", "DropOverload"))
    }
    #[doc = "Decide where the Classic packets are PI-based dropped or marked\nAssociated type: \"Dualpi2DropEarly\" (enum)"]
    pub fn get_drop_early(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Dualpi2Attrs::DropEarly(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("Dualpi2Attrs", "DropEarly"))
    }
    #[doc = "Classic WRR weight in percentage (from 0 to 100)"]
    pub fn get_c_protection(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Dualpi2Attrs::CProtection(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("Dualpi2Attrs", "CProtection"))
    }
    #[doc = "Configure the L-queue ECN classifier\nAssociated type: \"Dualpi2EcnMask\" (enum)"]
    pub fn get_ecn_mask(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Dualpi2Attrs::EcnMask(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("Dualpi2Attrs", "EcnMask"))
    }
    #[doc = "Split aggregated skb or not\nAssociated type: \"Dualpi2SplitGso\" (enum)"]
    pub fn get_split_gso(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Dualpi2Attrs::SplitGso(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("Dualpi2Attrs", "SplitGso"))
    }
}
impl Dualpi2Attrs {
    pub fn new(buf: &'_ [u8]) -> Iterable<'_, Dualpi2Attrs> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Limit",
            2u16 => "MemoryLimit",
            3u16 => "Target",
            4u16 => "Tupdate",
            5u16 => "Alpha",
            6u16 => "Beta",
            7u16 => "StepThreshPkts",
            8u16 => "StepThreshUs",
            9u16 => "MinQlenStep",
            10u16 => "Coupling",
            11u16 => "DropOverload",
            12u16 => "DropEarly",
            13u16 => "CProtection",
            14u16 => "EcnMask",
            15u16 => "SplitGso",
            _ => return None,
        };
        Some(res)
    }
}
impl Iterator for Iterable<'_, Dualpi2Attrs> {
    type Item = Result<Dualpi2Attrs, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => Dualpi2Attrs::Limit({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => Dualpi2Attrs::MemoryLimit({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => Dualpi2Attrs::Target({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => Dualpi2Attrs::Tupdate({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => Dualpi2Attrs::Alpha({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => Dualpi2Attrs::Beta({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => Dualpi2Attrs::StepThreshPkts({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => Dualpi2Attrs::StepThreshUs({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => Dualpi2Attrs::MinQlenStep({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => Dualpi2Attrs::Coupling({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => Dualpi2Attrs::DropOverload({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                12u16 => Dualpi2Attrs::DropEarly({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                13u16 => Dualpi2Attrs::CProtection({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                14u16 => Dualpi2Attrs::EcnMask({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                15u16 => Dualpi2Attrs::SplitGso({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "Dualpi2Attrs",
            r#type.and_then(|t| Dualpi2Attrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl std::fmt::Debug for Iterable<'_, Dualpi2Attrs> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("Dualpi2Attrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                Dualpi2Attrs::Limit(val) => fmt.field("Limit", &val),
                Dualpi2Attrs::MemoryLimit(val) => fmt.field("MemoryLimit", &val),
                Dualpi2Attrs::Target(val) => fmt.field("Target", &val),
                Dualpi2Attrs::Tupdate(val) => fmt.field("Tupdate", &val),
                Dualpi2Attrs::Alpha(val) => fmt.field("Alpha", &val),
                Dualpi2Attrs::Beta(val) => fmt.field("Beta", &val),
                Dualpi2Attrs::StepThreshPkts(val) => fmt.field("StepThreshPkts", &val),
                Dualpi2Attrs::StepThreshUs(val) => fmt.field("StepThreshUs", &val),
                Dualpi2Attrs::MinQlenStep(val) => fmt.field("MinQlenStep", &val),
                Dualpi2Attrs::Coupling(val) => fmt.field("Coupling", &val),
                Dualpi2Attrs::DropOverload(val) => fmt.field(
                    "DropOverload",
                    &FormatEnum(val.into(), Dualpi2DropOverload::from_value),
                ),
                Dualpi2Attrs::DropEarly(val) => fmt.field(
                    "DropEarly",
                    &FormatEnum(val.into(), Dualpi2DropEarly::from_value),
                ),
                Dualpi2Attrs::CProtection(val) => fmt.field("CProtection", &val),
                Dualpi2Attrs::EcnMask(val) => fmt.field(
                    "EcnMask",
                    &FormatEnum(val.into(), Dualpi2EcnMask::from_value),
                ),
                Dualpi2Attrs::SplitGso(val) => fmt.field(
                    "SplitGso",
                    &FormatEnum(val.into(), Dualpi2SplitGso::from_value),
                ),
            };
        }
        fmt.finish()
    }
}
impl Iterable<'_, Dualpi2Attrs> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("Dualpi2Attrs", offset));
            return (
                stack,
                missing_type.and_then(|t| Dualpi2Attrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                Dualpi2Attrs::Limit(val) => {
                    if last_off == offset {
                        stack.push(("Limit", last_off));
                        break;
                    }
                }
                Dualpi2Attrs::MemoryLimit(val) => {
                    if last_off == offset {
                        stack.push(("MemoryLimit", last_off));
                        break;
                    }
                }
                Dualpi2Attrs::Target(val) => {
                    if last_off == offset {
                        stack.push(("Target", last_off));
                        break;
                    }
                }
                Dualpi2Attrs::Tupdate(val) => {
                    if last_off == offset {
                        stack.push(("Tupdate", last_off));
                        break;
                    }
                }
                Dualpi2Attrs::Alpha(val) => {
                    if last_off == offset {
                        stack.push(("Alpha", last_off));
                        break;
                    }
                }
                Dualpi2Attrs::Beta(val) => {
                    if last_off == offset {
                        stack.push(("Beta", last_off));
                        break;
                    }
                }
                Dualpi2Attrs::StepThreshPkts(val) => {
                    if last_off == offset {
                        stack.push(("StepThreshPkts", last_off));
                        break;
                    }
                }
                Dualpi2Attrs::StepThreshUs(val) => {
                    if last_off == offset {
                        stack.push(("StepThreshUs", last_off));
                        break;
                    }
                }
                Dualpi2Attrs::MinQlenStep(val) => {
                    if last_off == offset {
                        stack.push(("MinQlenStep", last_off));
                        break;
                    }
                }
                Dualpi2Attrs::Coupling(val) => {
                    if last_off == offset {
                        stack.push(("Coupling", last_off));
                        break;
                    }
                }
                Dualpi2Attrs::DropOverload(val) => {
                    if last_off == offset {
                        stack.push(("DropOverload", last_off));
                        break;
                    }
                }
                Dualpi2Attrs::DropEarly(val) => {
                    if last_off == offset {
                        stack.push(("DropEarly", last_off));
                        break;
                    }
                }
                Dualpi2Attrs::CProtection(val) => {
                    if last_off == offset {
                        stack.push(("CProtection", last_off));
                        break;
                    }
                }
                Dualpi2Attrs::EcnMask(val) => {
                    if last_off == offset {
                        stack.push(("EcnMask", last_off));
                        break;
                    }
                }
                Dualpi2Attrs::SplitGso(val) => {
                    if last_off == offset {
                        stack.push(("SplitGso", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("Dualpi2Attrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"ematch-attrs\""]
#[derive(Clone)]
pub enum EmatchAttrs<'a> {
    TreeHdr(PushTcfEmatchTreeHdr),
    TreeList(&'a [u8]),
}
impl<'a> Iterable<'a, EmatchAttrs<'a>> {
    pub fn get_tree_hdr(&self) -> Result<PushTcfEmatchTreeHdr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let EmatchAttrs::TreeHdr(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("EmatchAttrs", "TreeHdr"))
    }
    pub fn get_tree_list(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let EmatchAttrs::TreeList(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("EmatchAttrs", "TreeList"))
    }
}
impl<'a> EmatchAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, EmatchAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "TreeHdr",
            2u16 => "TreeList",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, EmatchAttrs<'a>> {
    type Item = Result<EmatchAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => EmatchAttrs::TreeHdr({
                    let res = PushTcfEmatchTreeHdr::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => EmatchAttrs::TreeList({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "EmatchAttrs",
            r#type.and_then(|t| EmatchAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, EmatchAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("EmatchAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                EmatchAttrs::TreeHdr(val) => fmt.field("TreeHdr", &val),
                EmatchAttrs::TreeList(val) => fmt.field("TreeList", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, EmatchAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("EmatchAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| EmatchAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                EmatchAttrs::TreeHdr(val) => {
                    if last_off == offset {
                        stack.push(("TreeHdr", last_off));
                        break;
                    }
                }
                EmatchAttrs::TreeList(val) => {
                    if last_off == offset {
                        stack.push(("TreeList", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("EmatchAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"flow-attrs\""]
#[derive(Clone)]
pub enum FlowAttrs<'a> {
    Keys(u32),
    Mode(u32),
    Baseclass(u32),
    Rshift(u32),
    Addend(u32),
    Mask(u32),
    Xor(u32),
    Divisor(u32),
    Act(&'a [u8]),
    Police(Iterable<'a, PoliceAttrs<'a>>),
    Ematches(&'a [u8]),
    Perturb(u32),
}
impl<'a> Iterable<'a, FlowAttrs<'a>> {
    pub fn get_keys(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowAttrs::Keys(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowAttrs", "Keys"))
    }
    pub fn get_mode(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowAttrs::Mode(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowAttrs", "Mode"))
    }
    pub fn get_baseclass(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowAttrs::Baseclass(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowAttrs", "Baseclass"))
    }
    pub fn get_rshift(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowAttrs::Rshift(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowAttrs", "Rshift"))
    }
    pub fn get_addend(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowAttrs::Addend(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowAttrs", "Addend"))
    }
    pub fn get_mask(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowAttrs::Mask(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowAttrs", "Mask"))
    }
    pub fn get_xor(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowAttrs::Xor(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowAttrs", "Xor"))
    }
    pub fn get_divisor(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowAttrs::Divisor(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowAttrs", "Divisor"))
    }
    pub fn get_act(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowAttrs::Act(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowAttrs", "Act"))
    }
    pub fn get_police(&self) -> Result<Iterable<'a, PoliceAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowAttrs::Police(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowAttrs", "Police"))
    }
    pub fn get_ematches(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowAttrs::Ematches(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowAttrs", "Ematches"))
    }
    pub fn get_perturb(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowAttrs::Perturb(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowAttrs", "Perturb"))
    }
}
impl<'a> FlowAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, FlowAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Keys",
            2u16 => "Mode",
            3u16 => "Baseclass",
            4u16 => "Rshift",
            5u16 => "Addend",
            6u16 => "Mask",
            7u16 => "Xor",
            8u16 => "Divisor",
            9u16 => "Act",
            10u16 => "Police",
            11u16 => "Ematches",
            12u16 => "Perturb",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, FlowAttrs<'a>> {
    type Item = Result<FlowAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => FlowAttrs::Keys({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => FlowAttrs::Mode({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => FlowAttrs::Baseclass({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => FlowAttrs::Rshift({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => FlowAttrs::Addend({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => FlowAttrs::Mask({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => FlowAttrs::Xor({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => FlowAttrs::Divisor({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => FlowAttrs::Act({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => FlowAttrs::Police({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => FlowAttrs::Ematches({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                12u16 => FlowAttrs::Perturb({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "FlowAttrs",
            r#type.and_then(|t| FlowAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, FlowAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("FlowAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                FlowAttrs::Keys(val) => fmt.field("Keys", &val),
                FlowAttrs::Mode(val) => fmt.field("Mode", &val),
                FlowAttrs::Baseclass(val) => fmt.field("Baseclass", &val),
                FlowAttrs::Rshift(val) => fmt.field("Rshift", &val),
                FlowAttrs::Addend(val) => fmt.field("Addend", &val),
                FlowAttrs::Mask(val) => fmt.field("Mask", &val),
                FlowAttrs::Xor(val) => fmt.field("Xor", &val),
                FlowAttrs::Divisor(val) => fmt.field("Divisor", &val),
                FlowAttrs::Act(val) => fmt.field("Act", &val),
                FlowAttrs::Police(val) => fmt.field("Police", &val),
                FlowAttrs::Ematches(val) => fmt.field("Ematches", &val),
                FlowAttrs::Perturb(val) => fmt.field("Perturb", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, FlowAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("FlowAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| FlowAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                FlowAttrs::Keys(val) => {
                    if last_off == offset {
                        stack.push(("Keys", last_off));
                        break;
                    }
                }
                FlowAttrs::Mode(val) => {
                    if last_off == offset {
                        stack.push(("Mode", last_off));
                        break;
                    }
                }
                FlowAttrs::Baseclass(val) => {
                    if last_off == offset {
                        stack.push(("Baseclass", last_off));
                        break;
                    }
                }
                FlowAttrs::Rshift(val) => {
                    if last_off == offset {
                        stack.push(("Rshift", last_off));
                        break;
                    }
                }
                FlowAttrs::Addend(val) => {
                    if last_off == offset {
                        stack.push(("Addend", last_off));
                        break;
                    }
                }
                FlowAttrs::Mask(val) => {
                    if last_off == offset {
                        stack.push(("Mask", last_off));
                        break;
                    }
                }
                FlowAttrs::Xor(val) => {
                    if last_off == offset {
                        stack.push(("Xor", last_off));
                        break;
                    }
                }
                FlowAttrs::Divisor(val) => {
                    if last_off == offset {
                        stack.push(("Divisor", last_off));
                        break;
                    }
                }
                FlowAttrs::Act(val) => {
                    if last_off == offset {
                        stack.push(("Act", last_off));
                        break;
                    }
                }
                FlowAttrs::Police(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                FlowAttrs::Ematches(val) => {
                    if last_off == offset {
                        stack.push(("Ematches", last_off));
                        break;
                    }
                }
                FlowAttrs::Perturb(val) => {
                    if last_off == offset {
                        stack.push(("Perturb", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("FlowAttrs", cur));
        }
        (stack, missing)
    }
}
#[doc = "Original name: \"flower-attrs\""]
#[derive(Clone)]
pub enum FlowerAttrs<'a> {
    Classid(u32),
    Indev(&'a CStr),
    Act(Iterable<'a, Iterable<'a, ActAttrs<'a>>>),
    KeyEthDst(&'a [u8]),
    KeyEthDstMask(&'a [u8]),
    KeyEthSrc(&'a [u8]),
    KeyEthSrcMask(&'a [u8]),
    KeyEthType(u16),
    KeyIpProto(u8),
    KeyIpv4Src(std::net::Ipv4Addr),
    KeyIpv4SrcMask(std::net::Ipv4Addr),
    KeyIpv4Dst(std::net::Ipv4Addr),
    KeyIpv4DstMask(std::net::Ipv4Addr),
    KeyIpv6Src(&'a [u8]),
    KeyIpv6SrcMask(&'a [u8]),
    KeyIpv6Dst(&'a [u8]),
    KeyIpv6DstMask(&'a [u8]),
    KeyTcpSrc(u16),
    KeyTcpDst(u16),
    KeyUdpSrc(u16),
    KeyUdpDst(u16),
    #[doc = "Associated type: \"ClsFlags\" (1 bit per enumeration)"]
    Flags(u32),
    KeyVlanId(u16),
    KeyVlanPrio(u8),
    KeyVlanEthType(u16),
    KeyEncKeyId(u32),
    KeyEncIpv4Src(std::net::Ipv4Addr),
    KeyEncIpv4SrcMask(std::net::Ipv4Addr),
    KeyEncIpv4Dst(std::net::Ipv4Addr),
    KeyEncIpv4DstMask(std::net::Ipv4Addr),
    KeyEncIpv6Src(&'a [u8]),
    KeyEncIpv6SrcMask(&'a [u8]),
    KeyEncIpv6Dst(&'a [u8]),
    KeyEncIpv6DstMask(&'a [u8]),
    KeyTcpSrcMask(u16),
    KeyTcpDstMask(u16),
    KeyUdpSrcMask(u16),
    KeyUdpDstMask(u16),
    KeySctpSrcMask(u16),
    KeySctpDstMask(u16),
    KeySctpSrc(u16),
    KeySctpDst(u16),
    KeyEncUdpSrcPort(u16),
    KeyEncUdpSrcPortMask(u16),
    KeyEncUdpDstPort(u16),
    KeyEncUdpDstPortMask(u16),
    #[doc = "Associated type: \"FlowerKeyCtrlFlags\" (1 bit per enumeration)"]
    KeyFlags(u32),
    #[doc = "Associated type: \"FlowerKeyCtrlFlags\" (1 bit per enumeration)"]
    KeyFlagsMask(u32),
    KeyIcmpv4Code(u8),
    KeyIcmpv4CodeMask(u8),
    KeyIcmpv4Type(u8),
    KeyIcmpv4TypeMask(u8),
    KeyIcmpv6Code(u8),
    KeyIcmpv6CodeMask(u8),
    KeyIcmpv6Type(u8),
    KeyIcmpv6TypeMask(u8),
    KeyArpSip(u32),
    KeyArpSipMask(u32),
    KeyArpTip(u32),
    KeyArpTipMask(u32),
    KeyArpOp(u8),
    KeyArpOpMask(u8),
    KeyArpSha(&'a [u8]),
    KeyArpShaMask(&'a [u8]),
    KeyArpTha(&'a [u8]),
    KeyArpThaMask(&'a [u8]),
    KeyMplsTtl(u8),
    KeyMplsBos(u8),
    KeyMplsTc(u8),
    KeyMplsLabel(u32),
    KeyTcpFlags(u16),
    KeyTcpFlagsMask(u16),
    KeyIpTos(u8),
    KeyIpTosMask(u8),
    KeyIpTtl(u8),
    KeyIpTtlMask(u8),
    KeyCvlanId(u16),
    KeyCvlanPrio(u8),
    KeyCvlanEthType(u16),
    KeyEncIpTos(u8),
    KeyEncIpTosMask(u8),
    KeyEncIpTtl(u8),
    KeyEncIpTtlMask(u8),
    KeyEncOpts(Iterable<'a, FlowerKeyEncOptsAttrs<'a>>),
    KeyEncOptsMask(Iterable<'a, FlowerKeyEncOptsAttrs<'a>>),
    InHwCount(u32),
    KeyPortSrcMin(u16),
    KeyPortSrcMax(u16),
    KeyPortDstMin(u16),
    KeyPortDstMax(u16),
    KeyCtState(u16),
    KeyCtStateMask(u16),
    KeyCtZone(u16),
    KeyCtZoneMask(u16),
    KeyCtMark(u32),
    KeyCtMarkMask(u32),
    KeyCtLabels(&'a [u8]),
    KeyCtLabelsMask(&'a [u8]),
    KeyMplsOpts(Iterable<'a, FlowerKeyMplsOptAttrs>),
    KeyHash(u32),
    KeyHashMask(u32),
    KeyNumOfVlans(u8),
    KeyPppoeSid(u16),
    KeyPppProto(u16),
    KeyL2tpv3Sid(u32),
    L2Miss(u8),
    KeyCfm(Iterable<'a, FlowerKeyCfmAttrs>),
    KeySpi(u32),
    KeySpiMask(u32),
    #[doc = "Associated type: \"FlowerKeyCtrlFlags\" (1 bit per enumeration)"]
    KeyEncFlags(u32),
    #[doc = "Associated type: \"FlowerKeyCtrlFlags\" (1 bit per enumeration)"]
    KeyEncFlagsMask(u32),
}
impl<'a> Iterable<'a, FlowerAttrs<'a>> {
    pub fn get_classid(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::Classid(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "Classid"))
    }
    pub fn get_indev(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::Indev(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "Indev"))
    }
    pub fn get_act(
        &self,
    ) -> Result<
        ArrayIterable<Iterable<'a, Iterable<'a, ActAttrs<'a>>>, Iterable<'a, ActAttrs<'a>>>,
        ErrorContext,
    > {
        for attr in self.clone() {
            if let FlowerAttrs::Act(val) = attr? {
                return Ok(ArrayIterable::new(val));
            }
        }
        Err(self.error_missing("FlowerAttrs", "Act"))
    }
    pub fn get_key_eth_dst(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyEthDst(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyEthDst"))
    }
    pub fn get_key_eth_dst_mask(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyEthDstMask(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyEthDstMask"))
    }
    pub fn get_key_eth_src(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyEthSrc(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyEthSrc"))
    }
    pub fn get_key_eth_src_mask(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyEthSrcMask(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyEthSrcMask"))
    }
    pub fn get_key_eth_type(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyEthType(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyEthType"))
    }
    pub fn get_key_ip_proto(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyIpProto(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyIpProto"))
    }
    pub fn get_key_ipv4_src(&self) -> Result<std::net::Ipv4Addr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyIpv4Src(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyIpv4Src"))
    }
    pub fn get_key_ipv4_src_mask(&self) -> Result<std::net::Ipv4Addr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyIpv4SrcMask(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyIpv4SrcMask"))
    }
    pub fn get_key_ipv4_dst(&self) -> Result<std::net::Ipv4Addr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyIpv4Dst(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyIpv4Dst"))
    }
    pub fn get_key_ipv4_dst_mask(&self) -> Result<std::net::Ipv4Addr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyIpv4DstMask(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyIpv4DstMask"))
    }
    pub fn get_key_ipv6_src(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyIpv6Src(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyIpv6Src"))
    }
    pub fn get_key_ipv6_src_mask(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyIpv6SrcMask(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyIpv6SrcMask"))
    }
    pub fn get_key_ipv6_dst(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyIpv6Dst(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyIpv6Dst"))
    }
    pub fn get_key_ipv6_dst_mask(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyIpv6DstMask(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyIpv6DstMask"))
    }
    pub fn get_key_tcp_src(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyTcpSrc(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyTcpSrc"))
    }
    pub fn get_key_tcp_dst(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyTcpDst(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyTcpDst"))
    }
    pub fn get_key_udp_src(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyUdpSrc(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyUdpSrc"))
    }
    pub fn get_key_udp_dst(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyUdpDst(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyUdpDst"))
    }
    #[doc = "Associated type: \"ClsFlags\" (1 bit per enumeration)"]
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "Flags"))
    }
    pub fn get_key_vlan_id(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyVlanId(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyVlanId"))
    }
    pub fn get_key_vlan_prio(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyVlanPrio(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyVlanPrio"))
    }
    pub fn get_key_vlan_eth_type(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyVlanEthType(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyVlanEthType"))
    }
    pub fn get_key_enc_key_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyEncKeyId(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyEncKeyId"))
    }
    pub fn get_key_enc_ipv4_src(&self) -> Result<std::net::Ipv4Addr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyEncIpv4Src(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyEncIpv4Src"))
    }
    pub fn get_key_enc_ipv4_src_mask(&self) -> Result<std::net::Ipv4Addr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyEncIpv4SrcMask(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyEncIpv4SrcMask"))
    }
    pub fn get_key_enc_ipv4_dst(&self) -> Result<std::net::Ipv4Addr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyEncIpv4Dst(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyEncIpv4Dst"))
    }
    pub fn get_key_enc_ipv4_dst_mask(&self) -> Result<std::net::Ipv4Addr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyEncIpv4DstMask(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyEncIpv4DstMask"))
    }
    pub fn get_key_enc_ipv6_src(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyEncIpv6Src(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyEncIpv6Src"))
    }
    pub fn get_key_enc_ipv6_src_mask(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyEncIpv6SrcMask(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyEncIpv6SrcMask"))
    }
    pub fn get_key_enc_ipv6_dst(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyEncIpv6Dst(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyEncIpv6Dst"))
    }
    pub fn get_key_enc_ipv6_dst_mask(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyEncIpv6DstMask(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyEncIpv6DstMask"))
    }
    pub fn get_key_tcp_src_mask(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyTcpSrcMask(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyTcpSrcMask"))
    }
    pub fn get_key_tcp_dst_mask(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyTcpDstMask(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyTcpDstMask"))
    }
    pub fn get_key_udp_src_mask(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyUdpSrcMask(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyUdpSrcMask"))
    }
    pub fn get_key_udp_dst_mask(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyUdpDstMask(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyUdpDstMask"))
    }
    pub fn get_key_sctp_src_mask(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeySctpSrcMask(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeySctpSrcMask"))
    }
    pub fn get_key_sctp_dst_mask(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeySctpDstMask(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeySctpDstMask"))
    }
    pub fn get_key_sctp_src(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeySctpSrc(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeySctpSrc"))
    }
    pub fn get_key_sctp_dst(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeySctpDst(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeySctpDst"))
    }
    pub fn get_key_enc_udp_src_port(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyEncUdpSrcPort(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyEncUdpSrcPort"))
    }
    pub fn get_key_enc_udp_src_port_mask(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyEncUdpSrcPortMask(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyEncUdpSrcPortMask"))
    }
    pub fn get_key_enc_udp_dst_port(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyEncUdpDstPort(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyEncUdpDstPort"))
    }
    pub fn get_key_enc_udp_dst_port_mask(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyEncUdpDstPortMask(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyEncUdpDstPortMask"))
    }
    #[doc = "Associated type: \"FlowerKeyCtrlFlags\" (1 bit per enumeration)"]
    pub fn get_key_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyFlags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyFlags"))
    }
    #[doc = "Associated type: \"FlowerKeyCtrlFlags\" (1 bit per enumeration)"]
    pub fn get_key_flags_mask(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyFlagsMask(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyFlagsMask"))
    }
    pub fn get_key_icmpv4_code(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyIcmpv4Code(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyIcmpv4Code"))
    }
    pub fn get_key_icmpv4_code_mask(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyIcmpv4CodeMask(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyIcmpv4CodeMask"))
    }
    pub fn get_key_icmpv4_type(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyIcmpv4Type(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyIcmpv4Type"))
    }
    pub fn get_key_icmpv4_type_mask(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyIcmpv4TypeMask(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyIcmpv4TypeMask"))
    }
    pub fn get_key_icmpv6_code(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyIcmpv6Code(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyIcmpv6Code"))
    }
    pub fn get_key_icmpv6_code_mask(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyIcmpv6CodeMask(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyIcmpv6CodeMask"))
    }
    pub fn get_key_icmpv6_type(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyIcmpv6Type(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyIcmpv6Type"))
    }
    pub fn get_key_icmpv6_type_mask(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyIcmpv6TypeMask(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyIcmpv6TypeMask"))
    }
    pub fn get_key_arp_sip(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyArpSip(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyArpSip"))
    }
    pub fn get_key_arp_sip_mask(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyArpSipMask(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyArpSipMask"))
    }
    pub fn get_key_arp_tip(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyArpTip(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyArpTip"))
    }
    pub fn get_key_arp_tip_mask(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyArpTipMask(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyArpTipMask"))
    }
    pub fn get_key_arp_op(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyArpOp(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyArpOp"))
    }
    pub fn get_key_arp_op_mask(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyArpOpMask(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyArpOpMask"))
    }
    pub fn get_key_arp_sha(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyArpSha(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyArpSha"))
    }
    pub fn get_key_arp_sha_mask(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyArpShaMask(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyArpShaMask"))
    }
    pub fn get_key_arp_tha(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyArpTha(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyArpTha"))
    }
    pub fn get_key_arp_tha_mask(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyArpThaMask(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyArpThaMask"))
    }
    pub fn get_key_mpls_ttl(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyMplsTtl(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyMplsTtl"))
    }
    pub fn get_key_mpls_bos(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyMplsBos(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyMplsBos"))
    }
    pub fn get_key_mpls_tc(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyMplsTc(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyMplsTc"))
    }
    pub fn get_key_mpls_label(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyMplsLabel(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyMplsLabel"))
    }
    pub fn get_key_tcp_flags(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyTcpFlags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyTcpFlags"))
    }
    pub fn get_key_tcp_flags_mask(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyTcpFlagsMask(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyTcpFlagsMask"))
    }
    pub fn get_key_ip_tos(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyIpTos(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyIpTos"))
    }
    pub fn get_key_ip_tos_mask(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyIpTosMask(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyIpTosMask"))
    }
    pub fn get_key_ip_ttl(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyIpTtl(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyIpTtl"))
    }
    pub fn get_key_ip_ttl_mask(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyIpTtlMask(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyIpTtlMask"))
    }
    pub fn get_key_cvlan_id(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyCvlanId(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyCvlanId"))
    }
    pub fn get_key_cvlan_prio(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyCvlanPrio(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyCvlanPrio"))
    }
    pub fn get_key_cvlan_eth_type(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyCvlanEthType(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyCvlanEthType"))
    }
    pub fn get_key_enc_ip_tos(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyEncIpTos(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyEncIpTos"))
    }
    pub fn get_key_enc_ip_tos_mask(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyEncIpTosMask(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyEncIpTosMask"))
    }
    pub fn get_key_enc_ip_ttl(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyEncIpTtl(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyEncIpTtl"))
    }
    pub fn get_key_enc_ip_ttl_mask(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyEncIpTtlMask(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyEncIpTtlMask"))
    }
    pub fn get_key_enc_opts(
        &self,
    ) -> Result<Iterable<'a, FlowerKeyEncOptsAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyEncOpts(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyEncOpts"))
    }
    pub fn get_key_enc_opts_mask(
        &self,
    ) -> Result<Iterable<'a, FlowerKeyEncOptsAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyEncOptsMask(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyEncOptsMask"))
    }
    pub fn get_in_hw_count(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::InHwCount(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "InHwCount"))
    }
    pub fn get_key_port_src_min(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyPortSrcMin(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyPortSrcMin"))
    }
    pub fn get_key_port_src_max(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyPortSrcMax(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyPortSrcMax"))
    }
    pub fn get_key_port_dst_min(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyPortDstMin(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyPortDstMin"))
    }
    pub fn get_key_port_dst_max(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyPortDstMax(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyPortDstMax"))
    }
    pub fn get_key_ct_state(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyCtState(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyCtState"))
    }
    pub fn get_key_ct_state_mask(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyCtStateMask(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyCtStateMask"))
    }
    pub fn get_key_ct_zone(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyCtZone(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyCtZone"))
    }
    pub fn get_key_ct_zone_mask(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyCtZoneMask(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyCtZoneMask"))
    }
    pub fn get_key_ct_mark(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyCtMark(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyCtMark"))
    }
    pub fn get_key_ct_mark_mask(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyCtMarkMask(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyCtMarkMask"))
    }
    pub fn get_key_ct_labels(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyCtLabels(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyCtLabels"))
    }
    pub fn get_key_ct_labels_mask(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyCtLabelsMask(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyCtLabelsMask"))
    }
    pub fn get_key_mpls_opts(&self) -> Result<Iterable<'a, FlowerKeyMplsOptAttrs>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyMplsOpts(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyMplsOpts"))
    }
    pub fn get_key_hash(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyHash(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyHash"))
    }
    pub fn get_key_hash_mask(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyHashMask(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyHashMask"))
    }
    pub fn get_key_num_of_vlans(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyNumOfVlans(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyNumOfVlans"))
    }
    pub fn get_key_pppoe_sid(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyPppoeSid(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyPppoeSid"))
    }
    pub fn get_key_ppp_proto(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyPppProto(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyPppProto"))
    }
    pub fn get_key_l2tpv3_sid(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyL2tpv3Sid(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyL2tpv3Sid"))
    }
    pub fn get_l2_miss(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::L2Miss(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "L2Miss"))
    }
    pub fn get_key_cfm(&self) -> Result<Iterable<'a, FlowerKeyCfmAttrs>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyCfm(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyCfm"))
    }
    pub fn get_key_spi(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeySpi(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeySpi"))
    }
    pub fn get_key_spi_mask(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeySpiMask(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeySpiMask"))
    }
    #[doc = "Associated type: \"FlowerKeyCtrlFlags\" (1 bit per enumeration)"]
    pub fn get_key_enc_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyEncFlags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyEncFlags"))
    }
    #[doc = "Associated type: \"FlowerKeyCtrlFlags\" (1 bit per enumeration)"]
    pub fn get_key_enc_flags_mask(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerAttrs::KeyEncFlagsMask(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerAttrs", "KeyEncFlagsMask"))
    }
}
impl<'a> FlowerAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, FlowerAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Classid",
            2u16 => "Indev",
            3u16 => "Act",
            4u16 => "KeyEthDst",
            5u16 => "KeyEthDstMask",
            6u16 => "KeyEthSrc",
            7u16 => "KeyEthSrcMask",
            8u16 => "KeyEthType",
            9u16 => "KeyIpProto",
            10u16 => "KeyIpv4Src",
            11u16 => "KeyIpv4SrcMask",
            12u16 => "KeyIpv4Dst",
            13u16 => "KeyIpv4DstMask",
            14u16 => "KeyIpv6Src",
            15u16 => "KeyIpv6SrcMask",
            16u16 => "KeyIpv6Dst",
            17u16 => "KeyIpv6DstMask",
            18u16 => "KeyTcpSrc",
            19u16 => "KeyTcpDst",
            20u16 => "KeyUdpSrc",
            21u16 => "KeyUdpDst",
            22u16 => "Flags",
            23u16 => "KeyVlanId",
            24u16 => "KeyVlanPrio",
            25u16 => "KeyVlanEthType",
            26u16 => "KeyEncKeyId",
            27u16 => "KeyEncIpv4Src",
            28u16 => "KeyEncIpv4SrcMask",
            29u16 => "KeyEncIpv4Dst",
            30u16 => "KeyEncIpv4DstMask",
            31u16 => "KeyEncIpv6Src",
            32u16 => "KeyEncIpv6SrcMask",
            33u16 => "KeyEncIpv6Dst",
            34u16 => "KeyEncIpv6DstMask",
            35u16 => "KeyTcpSrcMask",
            36u16 => "KeyTcpDstMask",
            37u16 => "KeyUdpSrcMask",
            38u16 => "KeyUdpDstMask",
            39u16 => "KeySctpSrcMask",
            40u16 => "KeySctpDstMask",
            41u16 => "KeySctpSrc",
            42u16 => "KeySctpDst",
            43u16 => "KeyEncUdpSrcPort",
            44u16 => "KeyEncUdpSrcPortMask",
            45u16 => "KeyEncUdpDstPort",
            46u16 => "KeyEncUdpDstPortMask",
            47u16 => "KeyFlags",
            48u16 => "KeyFlagsMask",
            49u16 => "KeyIcmpv4Code",
            50u16 => "KeyIcmpv4CodeMask",
            51u16 => "KeyIcmpv4Type",
            52u16 => "KeyIcmpv4TypeMask",
            53u16 => "KeyIcmpv6Code",
            54u16 => "KeyIcmpv6CodeMask",
            55u16 => "KeyIcmpv6Type",
            56u16 => "KeyIcmpv6TypeMask",
            57u16 => "KeyArpSip",
            58u16 => "KeyArpSipMask",
            59u16 => "KeyArpTip",
            60u16 => "KeyArpTipMask",
            61u16 => "KeyArpOp",
            62u16 => "KeyArpOpMask",
            63u16 => "KeyArpSha",
            64u16 => "KeyArpShaMask",
            65u16 => "KeyArpTha",
            66u16 => "KeyArpThaMask",
            67u16 => "KeyMplsTtl",
            68u16 => "KeyMplsBos",
            69u16 => "KeyMplsTc",
            70u16 => "KeyMplsLabel",
            71u16 => "KeyTcpFlags",
            72u16 => "KeyTcpFlagsMask",
            73u16 => "KeyIpTos",
            74u16 => "KeyIpTosMask",
            75u16 => "KeyIpTtl",
            76u16 => "KeyIpTtlMask",
            77u16 => "KeyCvlanId",
            78u16 => "KeyCvlanPrio",
            79u16 => "KeyCvlanEthType",
            80u16 => "KeyEncIpTos",
            81u16 => "KeyEncIpTosMask",
            82u16 => "KeyEncIpTtl",
            83u16 => "KeyEncIpTtlMask",
            84u16 => "KeyEncOpts",
            85u16 => "KeyEncOptsMask",
            86u16 => "InHwCount",
            87u16 => "KeyPortSrcMin",
            88u16 => "KeyPortSrcMax",
            89u16 => "KeyPortDstMin",
            90u16 => "KeyPortDstMax",
            91u16 => "KeyCtState",
            92u16 => "KeyCtStateMask",
            93u16 => "KeyCtZone",
            94u16 => "KeyCtZoneMask",
            95u16 => "KeyCtMark",
            96u16 => "KeyCtMarkMask",
            97u16 => "KeyCtLabels",
            98u16 => "KeyCtLabelsMask",
            99u16 => "KeyMplsOpts",
            100u16 => "KeyHash",
            101u16 => "KeyHashMask",
            102u16 => "KeyNumOfVlans",
            103u16 => "KeyPppoeSid",
            104u16 => "KeyPppProto",
            105u16 => "KeyL2tpv3Sid",
            106u16 => "L2Miss",
            107u16 => "KeyCfm",
            108u16 => "KeySpi",
            109u16 => "KeySpiMask",
            110u16 => "KeyEncFlags",
            111u16 => "KeyEncFlagsMask",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, FlowerAttrs<'a>> {
    type Item = Result<FlowerAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => FlowerAttrs::Classid({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => FlowerAttrs::Indev({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => FlowerAttrs::Act({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => FlowerAttrs::KeyEthDst({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => FlowerAttrs::KeyEthDstMask({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => FlowerAttrs::KeyEthSrc({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => FlowerAttrs::KeyEthSrcMask({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => FlowerAttrs::KeyEthType({
                    let res = parse_be_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => FlowerAttrs::KeyIpProto({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => FlowerAttrs::KeyIpv4Src({
                    let res = parse_be_u32(next).map(Ipv4Addr::from_bits);
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => FlowerAttrs::KeyIpv4SrcMask({
                    let res = parse_be_u32(next).map(Ipv4Addr::from_bits);
                    let Some(val) = res else { break };
                    val
                }),
                12u16 => FlowerAttrs::KeyIpv4Dst({
                    let res = parse_be_u32(next).map(Ipv4Addr::from_bits);
                    let Some(val) = res else { break };
                    val
                }),
                13u16 => FlowerAttrs::KeyIpv4DstMask({
                    let res = parse_be_u32(next).map(Ipv4Addr::from_bits);
                    let Some(val) = res else { break };
                    val
                }),
                14u16 => FlowerAttrs::KeyIpv6Src({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                15u16 => FlowerAttrs::KeyIpv6SrcMask({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                16u16 => FlowerAttrs::KeyIpv6Dst({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                17u16 => FlowerAttrs::KeyIpv6DstMask({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                18u16 => FlowerAttrs::KeyTcpSrc({
                    let res = parse_be_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                19u16 => FlowerAttrs::KeyTcpDst({
                    let res = parse_be_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                20u16 => FlowerAttrs::KeyUdpSrc({
                    let res = parse_be_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                21u16 => FlowerAttrs::KeyUdpDst({
                    let res = parse_be_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                22u16 => FlowerAttrs::Flags({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                23u16 => FlowerAttrs::KeyVlanId({
                    let res = parse_be_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                24u16 => FlowerAttrs::KeyVlanPrio({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                25u16 => FlowerAttrs::KeyVlanEthType({
                    let res = parse_be_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                26u16 => FlowerAttrs::KeyEncKeyId({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                27u16 => FlowerAttrs::KeyEncIpv4Src({
                    let res = parse_be_u32(next).map(Ipv4Addr::from_bits);
                    let Some(val) = res else { break };
                    val
                }),
                28u16 => FlowerAttrs::KeyEncIpv4SrcMask({
                    let res = parse_be_u32(next).map(Ipv4Addr::from_bits);
                    let Some(val) = res else { break };
                    val
                }),
                29u16 => FlowerAttrs::KeyEncIpv4Dst({
                    let res = parse_be_u32(next).map(Ipv4Addr::from_bits);
                    let Some(val) = res else { break };
                    val
                }),
                30u16 => FlowerAttrs::KeyEncIpv4DstMask({
                    let res = parse_be_u32(next).map(Ipv4Addr::from_bits);
                    let Some(val) = res else { break };
                    val
                }),
                31u16 => FlowerAttrs::KeyEncIpv6Src({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                32u16 => FlowerAttrs::KeyEncIpv6SrcMask({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                33u16 => FlowerAttrs::KeyEncIpv6Dst({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                34u16 => FlowerAttrs::KeyEncIpv6DstMask({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                35u16 => FlowerAttrs::KeyTcpSrcMask({
                    let res = parse_be_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                36u16 => FlowerAttrs::KeyTcpDstMask({
                    let res = parse_be_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                37u16 => FlowerAttrs::KeyUdpSrcMask({
                    let res = parse_be_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                38u16 => FlowerAttrs::KeyUdpDstMask({
                    let res = parse_be_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                39u16 => FlowerAttrs::KeySctpSrcMask({
                    let res = parse_be_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                40u16 => FlowerAttrs::KeySctpDstMask({
                    let res = parse_be_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                41u16 => FlowerAttrs::KeySctpSrc({
                    let res = parse_be_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                42u16 => FlowerAttrs::KeySctpDst({
                    let res = parse_be_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                43u16 => FlowerAttrs::KeyEncUdpSrcPort({
                    let res = parse_be_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                44u16 => FlowerAttrs::KeyEncUdpSrcPortMask({
                    let res = parse_be_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                45u16 => FlowerAttrs::KeyEncUdpDstPort({
                    let res = parse_be_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                46u16 => FlowerAttrs::KeyEncUdpDstPortMask({
                    let res = parse_be_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                47u16 => FlowerAttrs::KeyFlags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                48u16 => FlowerAttrs::KeyFlagsMask({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                49u16 => FlowerAttrs::KeyIcmpv4Code({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                50u16 => FlowerAttrs::KeyIcmpv4CodeMask({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                51u16 => FlowerAttrs::KeyIcmpv4Type({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                52u16 => FlowerAttrs::KeyIcmpv4TypeMask({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                53u16 => FlowerAttrs::KeyIcmpv6Code({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                54u16 => FlowerAttrs::KeyIcmpv6CodeMask({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                55u16 => FlowerAttrs::KeyIcmpv6Type({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                56u16 => FlowerAttrs::KeyIcmpv6TypeMask({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                57u16 => FlowerAttrs::KeyArpSip({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                58u16 => FlowerAttrs::KeyArpSipMask({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                59u16 => FlowerAttrs::KeyArpTip({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                60u16 => FlowerAttrs::KeyArpTipMask({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                61u16 => FlowerAttrs::KeyArpOp({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                62u16 => FlowerAttrs::KeyArpOpMask({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                63u16 => FlowerAttrs::KeyArpSha({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                64u16 => FlowerAttrs::KeyArpShaMask({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                65u16 => FlowerAttrs::KeyArpTha({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                66u16 => FlowerAttrs::KeyArpThaMask({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                67u16 => FlowerAttrs::KeyMplsTtl({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                68u16 => FlowerAttrs::KeyMplsBos({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                69u16 => FlowerAttrs::KeyMplsTc({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                70u16 => FlowerAttrs::KeyMplsLabel({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                71u16 => FlowerAttrs::KeyTcpFlags({
                    let res = parse_be_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                72u16 => FlowerAttrs::KeyTcpFlagsMask({
                    let res = parse_be_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                73u16 => FlowerAttrs::KeyIpTos({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                74u16 => FlowerAttrs::KeyIpTosMask({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                75u16 => FlowerAttrs::KeyIpTtl({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                76u16 => FlowerAttrs::KeyIpTtlMask({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                77u16 => FlowerAttrs::KeyCvlanId({
                    let res = parse_be_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                78u16 => FlowerAttrs::KeyCvlanPrio({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                79u16 => FlowerAttrs::KeyCvlanEthType({
                    let res = parse_be_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                80u16 => FlowerAttrs::KeyEncIpTos({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                81u16 => FlowerAttrs::KeyEncIpTosMask({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                82u16 => FlowerAttrs::KeyEncIpTtl({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                83u16 => FlowerAttrs::KeyEncIpTtlMask({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                84u16 => FlowerAttrs::KeyEncOpts({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                85u16 => FlowerAttrs::KeyEncOptsMask({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                86u16 => FlowerAttrs::InHwCount({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                87u16 => FlowerAttrs::KeyPortSrcMin({
                    let res = parse_be_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                88u16 => FlowerAttrs::KeyPortSrcMax({
                    let res = parse_be_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                89u16 => FlowerAttrs::KeyPortDstMin({
                    let res = parse_be_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                90u16 => FlowerAttrs::KeyPortDstMax({
                    let res = parse_be_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                91u16 => FlowerAttrs::KeyCtState({
                    let res = parse_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                92u16 => FlowerAttrs::KeyCtStateMask({
                    let res = parse_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                93u16 => FlowerAttrs::KeyCtZone({
                    let res = parse_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                94u16 => FlowerAttrs::KeyCtZoneMask({
                    let res = parse_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                95u16 => FlowerAttrs::KeyCtMark({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                96u16 => FlowerAttrs::KeyCtMarkMask({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                97u16 => FlowerAttrs::KeyCtLabels({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                98u16 => FlowerAttrs::KeyCtLabelsMask({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                99u16 => FlowerAttrs::KeyMplsOpts({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                100u16 => FlowerAttrs::KeyHash({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                101u16 => FlowerAttrs::KeyHashMask({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                102u16 => FlowerAttrs::KeyNumOfVlans({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                103u16 => FlowerAttrs::KeyPppoeSid({
                    let res = parse_be_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                104u16 => FlowerAttrs::KeyPppProto({
                    let res = parse_be_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                105u16 => FlowerAttrs::KeyL2tpv3Sid({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                106u16 => FlowerAttrs::L2Miss({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                107u16 => FlowerAttrs::KeyCfm({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                108u16 => FlowerAttrs::KeySpi({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                109u16 => FlowerAttrs::KeySpiMask({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                110u16 => FlowerAttrs::KeyEncFlags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                111u16 => FlowerAttrs::KeyEncFlagsMask({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "FlowerAttrs",
            r#type.and_then(|t| FlowerAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, FlowerAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("FlowerAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                FlowerAttrs::Classid(val) => fmt.field("Classid", &val),
                FlowerAttrs::Indev(val) => fmt.field("Indev", &val),
                FlowerAttrs::Act(val) => fmt.field("Act", &val),
                FlowerAttrs::KeyEthDst(val) => fmt.field("KeyEthDst", &val),
                FlowerAttrs::KeyEthDstMask(val) => fmt.field("KeyEthDstMask", &val),
                FlowerAttrs::KeyEthSrc(val) => fmt.field("KeyEthSrc", &val),
                FlowerAttrs::KeyEthSrcMask(val) => fmt.field("KeyEthSrcMask", &val),
                FlowerAttrs::KeyEthType(val) => fmt.field("KeyEthType", &val),
                FlowerAttrs::KeyIpProto(val) => fmt.field("KeyIpProto", &val),
                FlowerAttrs::KeyIpv4Src(val) => fmt.field("KeyIpv4Src", &val),
                FlowerAttrs::KeyIpv4SrcMask(val) => fmt.field("KeyIpv4SrcMask", &val),
                FlowerAttrs::KeyIpv4Dst(val) => fmt.field("KeyIpv4Dst", &val),
                FlowerAttrs::KeyIpv4DstMask(val) => fmt.field("KeyIpv4DstMask", &val),
                FlowerAttrs::KeyIpv6Src(val) => fmt.field("KeyIpv6Src", &val),
                FlowerAttrs::KeyIpv6SrcMask(val) => fmt.field("KeyIpv6SrcMask", &val),
                FlowerAttrs::KeyIpv6Dst(val) => fmt.field("KeyIpv6Dst", &val),
                FlowerAttrs::KeyIpv6DstMask(val) => fmt.field("KeyIpv6DstMask", &val),
                FlowerAttrs::KeyTcpSrc(val) => fmt.field("KeyTcpSrc", &val),
                FlowerAttrs::KeyTcpDst(val) => fmt.field("KeyTcpDst", &val),
                FlowerAttrs::KeyUdpSrc(val) => fmt.field("KeyUdpSrc", &val),
                FlowerAttrs::KeyUdpDst(val) => fmt.field("KeyUdpDst", &val),
                FlowerAttrs::Flags(val) => {
                    fmt.field("Flags", &FormatFlags(val.into(), ClsFlags::from_value))
                }
                FlowerAttrs::KeyVlanId(val) => fmt.field("KeyVlanId", &val),
                FlowerAttrs::KeyVlanPrio(val) => fmt.field("KeyVlanPrio", &val),
                FlowerAttrs::KeyVlanEthType(val) => fmt.field("KeyVlanEthType", &val),
                FlowerAttrs::KeyEncKeyId(val) => fmt.field("KeyEncKeyId", &val),
                FlowerAttrs::KeyEncIpv4Src(val) => fmt.field("KeyEncIpv4Src", &val),
                FlowerAttrs::KeyEncIpv4SrcMask(val) => fmt.field("KeyEncIpv4SrcMask", &val),
                FlowerAttrs::KeyEncIpv4Dst(val) => fmt.field("KeyEncIpv4Dst", &val),
                FlowerAttrs::KeyEncIpv4DstMask(val) => fmt.field("KeyEncIpv4DstMask", &val),
                FlowerAttrs::KeyEncIpv6Src(val) => fmt.field("KeyEncIpv6Src", &val),
                FlowerAttrs::KeyEncIpv6SrcMask(val) => fmt.field("KeyEncIpv6SrcMask", &val),
                FlowerAttrs::KeyEncIpv6Dst(val) => fmt.field("KeyEncIpv6Dst", &val),
                FlowerAttrs::KeyEncIpv6DstMask(val) => fmt.field("KeyEncIpv6DstMask", &val),
                FlowerAttrs::KeyTcpSrcMask(val) => fmt.field("KeyTcpSrcMask", &val),
                FlowerAttrs::KeyTcpDstMask(val) => fmt.field("KeyTcpDstMask", &val),
                FlowerAttrs::KeyUdpSrcMask(val) => fmt.field("KeyUdpSrcMask", &val),
                FlowerAttrs::KeyUdpDstMask(val) => fmt.field("KeyUdpDstMask", &val),
                FlowerAttrs::KeySctpSrcMask(val) => fmt.field("KeySctpSrcMask", &val),
                FlowerAttrs::KeySctpDstMask(val) => fmt.field("KeySctpDstMask", &val),
                FlowerAttrs::KeySctpSrc(val) => fmt.field("KeySctpSrc", &val),
                FlowerAttrs::KeySctpDst(val) => fmt.field("KeySctpDst", &val),
                FlowerAttrs::KeyEncUdpSrcPort(val) => fmt.field("KeyEncUdpSrcPort", &val),
                FlowerAttrs::KeyEncUdpSrcPortMask(val) => fmt.field("KeyEncUdpSrcPortMask", &val),
                FlowerAttrs::KeyEncUdpDstPort(val) => fmt.field("KeyEncUdpDstPort", &val),
                FlowerAttrs::KeyEncUdpDstPortMask(val) => fmt.field("KeyEncUdpDstPortMask", &val),
                FlowerAttrs::KeyFlags(val) => fmt.field(
                    "KeyFlags",
                    &FormatFlags(val.into(), FlowerKeyCtrlFlags::from_value),
                ),
                FlowerAttrs::KeyFlagsMask(val) => fmt.field(
                    "KeyFlagsMask",
                    &FormatFlags(val.into(), FlowerKeyCtrlFlags::from_value),
                ),
                FlowerAttrs::KeyIcmpv4Code(val) => fmt.field("KeyIcmpv4Code", &val),
                FlowerAttrs::KeyIcmpv4CodeMask(val) => fmt.field("KeyIcmpv4CodeMask", &val),
                FlowerAttrs::KeyIcmpv4Type(val) => fmt.field("KeyIcmpv4Type", &val),
                FlowerAttrs::KeyIcmpv4TypeMask(val) => fmt.field("KeyIcmpv4TypeMask", &val),
                FlowerAttrs::KeyIcmpv6Code(val) => fmt.field("KeyIcmpv6Code", &val),
                FlowerAttrs::KeyIcmpv6CodeMask(val) => fmt.field("KeyIcmpv6CodeMask", &val),
                FlowerAttrs::KeyIcmpv6Type(val) => fmt.field("KeyIcmpv6Type", &val),
                FlowerAttrs::KeyIcmpv6TypeMask(val) => fmt.field("KeyIcmpv6TypeMask", &val),
                FlowerAttrs::KeyArpSip(val) => fmt.field("KeyArpSip", &val),
                FlowerAttrs::KeyArpSipMask(val) => fmt.field("KeyArpSipMask", &val),
                FlowerAttrs::KeyArpTip(val) => fmt.field("KeyArpTip", &val),
                FlowerAttrs::KeyArpTipMask(val) => fmt.field("KeyArpTipMask", &val),
                FlowerAttrs::KeyArpOp(val) => fmt.field("KeyArpOp", &val),
                FlowerAttrs::KeyArpOpMask(val) => fmt.field("KeyArpOpMask", &val),
                FlowerAttrs::KeyArpSha(val) => fmt.field("KeyArpSha", &val),
                FlowerAttrs::KeyArpShaMask(val) => fmt.field("KeyArpShaMask", &val),
                FlowerAttrs::KeyArpTha(val) => fmt.field("KeyArpTha", &val),
                FlowerAttrs::KeyArpThaMask(val) => fmt.field("KeyArpThaMask", &val),
                FlowerAttrs::KeyMplsTtl(val) => fmt.field("KeyMplsTtl", &val),
                FlowerAttrs::KeyMplsBos(val) => fmt.field("KeyMplsBos", &val),
                FlowerAttrs::KeyMplsTc(val) => fmt.field("KeyMplsTc", &val),
                FlowerAttrs::KeyMplsLabel(val) => fmt.field("KeyMplsLabel", &val),
                FlowerAttrs::KeyTcpFlags(val) => fmt.field("KeyTcpFlags", &val),
                FlowerAttrs::KeyTcpFlagsMask(val) => fmt.field("KeyTcpFlagsMask", &val),
                FlowerAttrs::KeyIpTos(val) => fmt.field("KeyIpTos", &val),
                FlowerAttrs::KeyIpTosMask(val) => fmt.field("KeyIpTosMask", &val),
                FlowerAttrs::KeyIpTtl(val) => fmt.field("KeyIpTtl", &val),
                FlowerAttrs::KeyIpTtlMask(val) => fmt.field("KeyIpTtlMask", &val),
                FlowerAttrs::KeyCvlanId(val) => fmt.field("KeyCvlanId", &val),
                FlowerAttrs::KeyCvlanPrio(val) => fmt.field("KeyCvlanPrio", &val),
                FlowerAttrs::KeyCvlanEthType(val) => fmt.field("KeyCvlanEthType", &val),
                FlowerAttrs::KeyEncIpTos(val) => fmt.field("KeyEncIpTos", &val),
                FlowerAttrs::KeyEncIpTosMask(val) => fmt.field("KeyEncIpTosMask", &val),
                FlowerAttrs::KeyEncIpTtl(val) => fmt.field("KeyEncIpTtl", &val),
                FlowerAttrs::KeyEncIpTtlMask(val) => fmt.field("KeyEncIpTtlMask", &val),
                FlowerAttrs::KeyEncOpts(val) => fmt.field("KeyEncOpts", &val),
                FlowerAttrs::KeyEncOptsMask(val) => fmt.field("KeyEncOptsMask", &val),
                FlowerAttrs::InHwCount(val) => fmt.field("InHwCount", &val),
                FlowerAttrs::KeyPortSrcMin(val) => fmt.field("KeyPortSrcMin", &val),
                FlowerAttrs::KeyPortSrcMax(val) => fmt.field("KeyPortSrcMax", &val),
                FlowerAttrs::KeyPortDstMin(val) => fmt.field("KeyPortDstMin", &val),
                FlowerAttrs::KeyPortDstMax(val) => fmt.field("KeyPortDstMax", &val),
                FlowerAttrs::KeyCtState(val) => fmt.field("KeyCtState", &val),
                FlowerAttrs::KeyCtStateMask(val) => fmt.field("KeyCtStateMask", &val),
                FlowerAttrs::KeyCtZone(val) => fmt.field("KeyCtZone", &val),
                FlowerAttrs::KeyCtZoneMask(val) => fmt.field("KeyCtZoneMask", &val),
                FlowerAttrs::KeyCtMark(val) => fmt.field("KeyCtMark", &val),
                FlowerAttrs::KeyCtMarkMask(val) => fmt.field("KeyCtMarkMask", &val),
                FlowerAttrs::KeyCtLabels(val) => fmt.field("KeyCtLabels", &val),
                FlowerAttrs::KeyCtLabelsMask(val) => fmt.field("KeyCtLabelsMask", &val),
                FlowerAttrs::KeyMplsOpts(val) => fmt.field("KeyMplsOpts", &val),
                FlowerAttrs::KeyHash(val) => fmt.field("KeyHash", &val),
                FlowerAttrs::KeyHashMask(val) => fmt.field("KeyHashMask", &val),
                FlowerAttrs::KeyNumOfVlans(val) => fmt.field("KeyNumOfVlans", &val),
                FlowerAttrs::KeyPppoeSid(val) => fmt.field("KeyPppoeSid", &val),
                FlowerAttrs::KeyPppProto(val) => fmt.field("KeyPppProto", &val),
                FlowerAttrs::KeyL2tpv3Sid(val) => fmt.field("KeyL2tpv3Sid", &val),
                FlowerAttrs::L2Miss(val) => fmt.field("L2Miss", &val),
                FlowerAttrs::KeyCfm(val) => fmt.field("KeyCfm", &val),
                FlowerAttrs::KeySpi(val) => fmt.field("KeySpi", &val),
                FlowerAttrs::KeySpiMask(val) => fmt.field("KeySpiMask", &val),
                FlowerAttrs::KeyEncFlags(val) => fmt.field(
                    "KeyEncFlags",
                    &FormatFlags(val.into(), FlowerKeyCtrlFlags::from_value),
                ),
                FlowerAttrs::KeyEncFlagsMask(val) => fmt.field(
                    "KeyEncFlagsMask",
                    &FormatFlags(val.into(), FlowerKeyCtrlFlags::from_value),
                ),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, FlowerAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("FlowerAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| FlowerAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                FlowerAttrs::Classid(val) => {
                    if last_off == offset {
                        stack.push(("Classid", last_off));
                        break;
                    }
                }
                FlowerAttrs::Indev(val) => {
                    if last_off == offset {
                        stack.push(("Indev", last_off));
                        break;
                    }
                }
                FlowerAttrs::Act(val) => {
                    for entry in val {
                        let Ok(attr) = entry else { break };
                        (stack, missing) = attr.lookup_attr(offset, missing_type);
                        if !stack.is_empty() {
                            break;
                        }
                    }
                    if !stack.is_empty() {
                        stack.push(("Act", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyEthDst(val) => {
                    if last_off == offset {
                        stack.push(("KeyEthDst", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyEthDstMask(val) => {
                    if last_off == offset {
                        stack.push(("KeyEthDstMask", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyEthSrc(val) => {
                    if last_off == offset {
                        stack.push(("KeyEthSrc", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyEthSrcMask(val) => {
                    if last_off == offset {
                        stack.push(("KeyEthSrcMask", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyEthType(val) => {
                    if last_off == offset {
                        stack.push(("KeyEthType", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyIpProto(val) => {
                    if last_off == offset {
                        stack.push(("KeyIpProto", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyIpv4Src(val) => {
                    if last_off == offset {
                        stack.push(("KeyIpv4Src", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyIpv4SrcMask(val) => {
                    if last_off == offset {
                        stack.push(("KeyIpv4SrcMask", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyIpv4Dst(val) => {
                    if last_off == offset {
                        stack.push(("KeyIpv4Dst", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyIpv4DstMask(val) => {
                    if last_off == offset {
                        stack.push(("KeyIpv4DstMask", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyIpv6Src(val) => {
                    if last_off == offset {
                        stack.push(("KeyIpv6Src", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyIpv6SrcMask(val) => {
                    if last_off == offset {
                        stack.push(("KeyIpv6SrcMask", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyIpv6Dst(val) => {
                    if last_off == offset {
                        stack.push(("KeyIpv6Dst", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyIpv6DstMask(val) => {
                    if last_off == offset {
                        stack.push(("KeyIpv6DstMask", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyTcpSrc(val) => {
                    if last_off == offset {
                        stack.push(("KeyTcpSrc", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyTcpDst(val) => {
                    if last_off == offset {
                        stack.push(("KeyTcpDst", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyUdpSrc(val) => {
                    if last_off == offset {
                        stack.push(("KeyUdpSrc", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyUdpDst(val) => {
                    if last_off == offset {
                        stack.push(("KeyUdpDst", last_off));
                        break;
                    }
                }
                FlowerAttrs::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyVlanId(val) => {
                    if last_off == offset {
                        stack.push(("KeyVlanId", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyVlanPrio(val) => {
                    if last_off == offset {
                        stack.push(("KeyVlanPrio", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyVlanEthType(val) => {
                    if last_off == offset {
                        stack.push(("KeyVlanEthType", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyEncKeyId(val) => {
                    if last_off == offset {
                        stack.push(("KeyEncKeyId", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyEncIpv4Src(val) => {
                    if last_off == offset {
                        stack.push(("KeyEncIpv4Src", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyEncIpv4SrcMask(val) => {
                    if last_off == offset {
                        stack.push(("KeyEncIpv4SrcMask", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyEncIpv4Dst(val) => {
                    if last_off == offset {
                        stack.push(("KeyEncIpv4Dst", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyEncIpv4DstMask(val) => {
                    if last_off == offset {
                        stack.push(("KeyEncIpv4DstMask", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyEncIpv6Src(val) => {
                    if last_off == offset {
                        stack.push(("KeyEncIpv6Src", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyEncIpv6SrcMask(val) => {
                    if last_off == offset {
                        stack.push(("KeyEncIpv6SrcMask", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyEncIpv6Dst(val) => {
                    if last_off == offset {
                        stack.push(("KeyEncIpv6Dst", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyEncIpv6DstMask(val) => {
                    if last_off == offset {
                        stack.push(("KeyEncIpv6DstMask", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyTcpSrcMask(val) => {
                    if last_off == offset {
                        stack.push(("KeyTcpSrcMask", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyTcpDstMask(val) => {
                    if last_off == offset {
                        stack.push(("KeyTcpDstMask", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyUdpSrcMask(val) => {
                    if last_off == offset {
                        stack.push(("KeyUdpSrcMask", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyUdpDstMask(val) => {
                    if last_off == offset {
                        stack.push(("KeyUdpDstMask", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeySctpSrcMask(val) => {
                    if last_off == offset {
                        stack.push(("KeySctpSrcMask", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeySctpDstMask(val) => {
                    if last_off == offset {
                        stack.push(("KeySctpDstMask", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeySctpSrc(val) => {
                    if last_off == offset {
                        stack.push(("KeySctpSrc", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeySctpDst(val) => {
                    if last_off == offset {
                        stack.push(("KeySctpDst", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyEncUdpSrcPort(val) => {
                    if last_off == offset {
                        stack.push(("KeyEncUdpSrcPort", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyEncUdpSrcPortMask(val) => {
                    if last_off == offset {
                        stack.push(("KeyEncUdpSrcPortMask", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyEncUdpDstPort(val) => {
                    if last_off == offset {
                        stack.push(("KeyEncUdpDstPort", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyEncUdpDstPortMask(val) => {
                    if last_off == offset {
                        stack.push(("KeyEncUdpDstPortMask", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyFlags(val) => {
                    if last_off == offset {
                        stack.push(("KeyFlags", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyFlagsMask(val) => {
                    if last_off == offset {
                        stack.push(("KeyFlagsMask", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyIcmpv4Code(val) => {
                    if last_off == offset {
                        stack.push(("KeyIcmpv4Code", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyIcmpv4CodeMask(val) => {
                    if last_off == offset {
                        stack.push(("KeyIcmpv4CodeMask", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyIcmpv4Type(val) => {
                    if last_off == offset {
                        stack.push(("KeyIcmpv4Type", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyIcmpv4TypeMask(val) => {
                    if last_off == offset {
                        stack.push(("KeyIcmpv4TypeMask", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyIcmpv6Code(val) => {
                    if last_off == offset {
                        stack.push(("KeyIcmpv6Code", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyIcmpv6CodeMask(val) => {
                    if last_off == offset {
                        stack.push(("KeyIcmpv6CodeMask", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyIcmpv6Type(val) => {
                    if last_off == offset {
                        stack.push(("KeyIcmpv6Type", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyIcmpv6TypeMask(val) => {
                    if last_off == offset {
                        stack.push(("KeyIcmpv6TypeMask", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyArpSip(val) => {
                    if last_off == offset {
                        stack.push(("KeyArpSip", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyArpSipMask(val) => {
                    if last_off == offset {
                        stack.push(("KeyArpSipMask", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyArpTip(val) => {
                    if last_off == offset {
                        stack.push(("KeyArpTip", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyArpTipMask(val) => {
                    if last_off == offset {
                        stack.push(("KeyArpTipMask", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyArpOp(val) => {
                    if last_off == offset {
                        stack.push(("KeyArpOp", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyArpOpMask(val) => {
                    if last_off == offset {
                        stack.push(("KeyArpOpMask", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyArpSha(val) => {
                    if last_off == offset {
                        stack.push(("KeyArpSha", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyArpShaMask(val) => {
                    if last_off == offset {
                        stack.push(("KeyArpShaMask", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyArpTha(val) => {
                    if last_off == offset {
                        stack.push(("KeyArpTha", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyArpThaMask(val) => {
                    if last_off == offset {
                        stack.push(("KeyArpThaMask", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyMplsTtl(val) => {
                    if last_off == offset {
                        stack.push(("KeyMplsTtl", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyMplsBos(val) => {
                    if last_off == offset {
                        stack.push(("KeyMplsBos", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyMplsTc(val) => {
                    if last_off == offset {
                        stack.push(("KeyMplsTc", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyMplsLabel(val) => {
                    if last_off == offset {
                        stack.push(("KeyMplsLabel", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyTcpFlags(val) => {
                    if last_off == offset {
                        stack.push(("KeyTcpFlags", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyTcpFlagsMask(val) => {
                    if last_off == offset {
                        stack.push(("KeyTcpFlagsMask", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyIpTos(val) => {
                    if last_off == offset {
                        stack.push(("KeyIpTos", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyIpTosMask(val) => {
                    if last_off == offset {
                        stack.push(("KeyIpTosMask", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyIpTtl(val) => {
                    if last_off == offset {
                        stack.push(("KeyIpTtl", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyIpTtlMask(val) => {
                    if last_off == offset {
                        stack.push(("KeyIpTtlMask", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyCvlanId(val) => {
                    if last_off == offset {
                        stack.push(("KeyCvlanId", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyCvlanPrio(val) => {
                    if last_off == offset {
                        stack.push(("KeyCvlanPrio", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyCvlanEthType(val) => {
                    if last_off == offset {
                        stack.push(("KeyCvlanEthType", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyEncIpTos(val) => {
                    if last_off == offset {
                        stack.push(("KeyEncIpTos", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyEncIpTosMask(val) => {
                    if last_off == offset {
                        stack.push(("KeyEncIpTosMask", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyEncIpTtl(val) => {
                    if last_off == offset {
                        stack.push(("KeyEncIpTtl", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyEncIpTtlMask(val) => {
                    if last_off == offset {
                        stack.push(("KeyEncIpTtlMask", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyEncOpts(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                FlowerAttrs::KeyEncOptsMask(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                FlowerAttrs::InHwCount(val) => {
                    if last_off == offset {
                        stack.push(("InHwCount", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyPortSrcMin(val) => {
                    if last_off == offset {
                        stack.push(("KeyPortSrcMin", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyPortSrcMax(val) => {
                    if last_off == offset {
                        stack.push(("KeyPortSrcMax", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyPortDstMin(val) => {
                    if last_off == offset {
                        stack.push(("KeyPortDstMin", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyPortDstMax(val) => {
                    if last_off == offset {
                        stack.push(("KeyPortDstMax", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyCtState(val) => {
                    if last_off == offset {
                        stack.push(("KeyCtState", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyCtStateMask(val) => {
                    if last_off == offset {
                        stack.push(("KeyCtStateMask", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyCtZone(val) => {
                    if last_off == offset {
                        stack.push(("KeyCtZone", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyCtZoneMask(val) => {
                    if last_off == offset {
                        stack.push(("KeyCtZoneMask", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyCtMark(val) => {
                    if last_off == offset {
                        stack.push(("KeyCtMark", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyCtMarkMask(val) => {
                    if last_off == offset {
                        stack.push(("KeyCtMarkMask", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyCtLabels(val) => {
                    if last_off == offset {
                        stack.push(("KeyCtLabels", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyCtLabelsMask(val) => {
                    if last_off == offset {
                        stack.push(("KeyCtLabelsMask", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyMplsOpts(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                FlowerAttrs::KeyHash(val) => {
                    if last_off == offset {
                        stack.push(("KeyHash", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyHashMask(val) => {
                    if last_off == offset {
                        stack.push(("KeyHashMask", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyNumOfVlans(val) => {
                    if last_off == offset {
                        stack.push(("KeyNumOfVlans", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyPppoeSid(val) => {
                    if last_off == offset {
                        stack.push(("KeyPppoeSid", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyPppProto(val) => {
                    if last_off == offset {
                        stack.push(("KeyPppProto", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyL2tpv3Sid(val) => {
                    if last_off == offset {
                        stack.push(("KeyL2tpv3Sid", last_off));
                        break;
                    }
                }
                FlowerAttrs::L2Miss(val) => {
                    if last_off == offset {
                        stack.push(("L2Miss", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyCfm(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                FlowerAttrs::KeySpi(val) => {
                    if last_off == offset {
                        stack.push(("KeySpi", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeySpiMask(val) => {
                    if last_off == offset {
                        stack.push(("KeySpiMask", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyEncFlags(val) => {
                    if last_off == offset {
                        stack.push(("KeyEncFlags", last_off));
                        break;
                    }
                }
                FlowerAttrs::KeyEncFlagsMask(val) => {
                    if last_off == offset {
                        stack.push(("KeyEncFlagsMask", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("FlowerAttrs", cur));
        }
        (stack, missing)
    }
}
#[doc = "Original name: \"flower-key-enc-opts-attrs\""]
#[derive(Clone)]
pub enum FlowerKeyEncOptsAttrs<'a> {
    Geneve(Iterable<'a, FlowerKeyEncOptGeneveAttrs<'a>>),
    Vxlan(Iterable<'a, FlowerKeyEncOptVxlanAttrs>),
    Erspan(Iterable<'a, FlowerKeyEncOptErspanAttrs>),
    Gtp(Iterable<'a, FlowerKeyEncOptGtpAttrs>),
}
impl<'a> Iterable<'a, FlowerKeyEncOptsAttrs<'a>> {
    pub fn get_geneve(&self) -> Result<Iterable<'a, FlowerKeyEncOptGeneveAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerKeyEncOptsAttrs::Geneve(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerKeyEncOptsAttrs", "Geneve"))
    }
    pub fn get_vxlan(&self) -> Result<Iterable<'a, FlowerKeyEncOptVxlanAttrs>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerKeyEncOptsAttrs::Vxlan(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerKeyEncOptsAttrs", "Vxlan"))
    }
    pub fn get_erspan(&self) -> Result<Iterable<'a, FlowerKeyEncOptErspanAttrs>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerKeyEncOptsAttrs::Erspan(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerKeyEncOptsAttrs", "Erspan"))
    }
    pub fn get_gtp(&self) -> Result<Iterable<'a, FlowerKeyEncOptGtpAttrs>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerKeyEncOptsAttrs::Gtp(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerKeyEncOptsAttrs", "Gtp"))
    }
}
impl<'a> FlowerKeyEncOptsAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, FlowerKeyEncOptsAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Geneve",
            2u16 => "Vxlan",
            3u16 => "Erspan",
            4u16 => "Gtp",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, FlowerKeyEncOptsAttrs<'a>> {
    type Item = Result<FlowerKeyEncOptsAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => FlowerKeyEncOptsAttrs::Geneve({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => FlowerKeyEncOptsAttrs::Vxlan({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => FlowerKeyEncOptsAttrs::Erspan({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => FlowerKeyEncOptsAttrs::Gtp({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "FlowerKeyEncOptsAttrs",
            r#type.and_then(|t| FlowerKeyEncOptsAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, FlowerKeyEncOptsAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("FlowerKeyEncOptsAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                FlowerKeyEncOptsAttrs::Geneve(val) => fmt.field("Geneve", &val),
                FlowerKeyEncOptsAttrs::Vxlan(val) => fmt.field("Vxlan", &val),
                FlowerKeyEncOptsAttrs::Erspan(val) => fmt.field("Erspan", &val),
                FlowerKeyEncOptsAttrs::Gtp(val) => fmt.field("Gtp", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, FlowerKeyEncOptsAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("FlowerKeyEncOptsAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| FlowerKeyEncOptsAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                FlowerKeyEncOptsAttrs::Geneve(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                FlowerKeyEncOptsAttrs::Vxlan(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                FlowerKeyEncOptsAttrs::Erspan(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                FlowerKeyEncOptsAttrs::Gtp(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("FlowerKeyEncOptsAttrs", cur));
        }
        (stack, missing)
    }
}
#[doc = "Original name: \"flower-key-enc-opt-geneve-attrs\""]
#[derive(Clone)]
pub enum FlowerKeyEncOptGeneveAttrs<'a> {
    Class(u16),
    Type(u8),
    Data(&'a [u8]),
}
impl<'a> Iterable<'a, FlowerKeyEncOptGeneveAttrs<'a>> {
    pub fn get_class(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerKeyEncOptGeneveAttrs::Class(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerKeyEncOptGeneveAttrs", "Class"))
    }
    pub fn get_type(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerKeyEncOptGeneveAttrs::Type(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerKeyEncOptGeneveAttrs", "Type"))
    }
    pub fn get_data(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerKeyEncOptGeneveAttrs::Data(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerKeyEncOptGeneveAttrs", "Data"))
    }
}
impl<'a> FlowerKeyEncOptGeneveAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, FlowerKeyEncOptGeneveAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Class",
            2u16 => "Type",
            3u16 => "Data",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, FlowerKeyEncOptGeneveAttrs<'a>> {
    type Item = Result<FlowerKeyEncOptGeneveAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => FlowerKeyEncOptGeneveAttrs::Class({
                    let res = parse_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => FlowerKeyEncOptGeneveAttrs::Type({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => FlowerKeyEncOptGeneveAttrs::Data({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "FlowerKeyEncOptGeneveAttrs",
            r#type.and_then(|t| FlowerKeyEncOptGeneveAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, FlowerKeyEncOptGeneveAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("FlowerKeyEncOptGeneveAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                FlowerKeyEncOptGeneveAttrs::Class(val) => fmt.field("Class", &val),
                FlowerKeyEncOptGeneveAttrs::Type(val) => fmt.field("Type", &val),
                FlowerKeyEncOptGeneveAttrs::Data(val) => fmt.field("Data", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, FlowerKeyEncOptGeneveAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("FlowerKeyEncOptGeneveAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| FlowerKeyEncOptGeneveAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                FlowerKeyEncOptGeneveAttrs::Class(val) => {
                    if last_off == offset {
                        stack.push(("Class", last_off));
                        break;
                    }
                }
                FlowerKeyEncOptGeneveAttrs::Type(val) => {
                    if last_off == offset {
                        stack.push(("Type", last_off));
                        break;
                    }
                }
                FlowerKeyEncOptGeneveAttrs::Data(val) => {
                    if last_off == offset {
                        stack.push(("Data", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("FlowerKeyEncOptGeneveAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"flower-key-enc-opt-vxlan-attrs\""]
#[derive(Clone)]
pub enum FlowerKeyEncOptVxlanAttrs {
    Gbp(u32),
}
impl<'a> Iterable<'a, FlowerKeyEncOptVxlanAttrs> {
    pub fn get_gbp(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerKeyEncOptVxlanAttrs::Gbp(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerKeyEncOptVxlanAttrs", "Gbp"))
    }
}
impl FlowerKeyEncOptVxlanAttrs {
    pub fn new(buf: &'_ [u8]) -> Iterable<'_, FlowerKeyEncOptVxlanAttrs> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Gbp",
            _ => return None,
        };
        Some(res)
    }
}
impl Iterator for Iterable<'_, FlowerKeyEncOptVxlanAttrs> {
    type Item = Result<FlowerKeyEncOptVxlanAttrs, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => FlowerKeyEncOptVxlanAttrs::Gbp({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "FlowerKeyEncOptVxlanAttrs",
            r#type.and_then(|t| FlowerKeyEncOptVxlanAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl std::fmt::Debug for Iterable<'_, FlowerKeyEncOptVxlanAttrs> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("FlowerKeyEncOptVxlanAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                FlowerKeyEncOptVxlanAttrs::Gbp(val) => fmt.field("Gbp", &val),
            };
        }
        fmt.finish()
    }
}
impl Iterable<'_, FlowerKeyEncOptVxlanAttrs> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("FlowerKeyEncOptVxlanAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| FlowerKeyEncOptVxlanAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                FlowerKeyEncOptVxlanAttrs::Gbp(val) => {
                    if last_off == offset {
                        stack.push(("Gbp", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("FlowerKeyEncOptVxlanAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"flower-key-enc-opt-erspan-attrs\""]
#[derive(Clone)]
pub enum FlowerKeyEncOptErspanAttrs {
    Ver(u8),
    Index(u32),
    Dir(u8),
    Hwid(u8),
}
impl<'a> Iterable<'a, FlowerKeyEncOptErspanAttrs> {
    pub fn get_ver(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerKeyEncOptErspanAttrs::Ver(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerKeyEncOptErspanAttrs", "Ver"))
    }
    pub fn get_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerKeyEncOptErspanAttrs::Index(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerKeyEncOptErspanAttrs", "Index"))
    }
    pub fn get_dir(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerKeyEncOptErspanAttrs::Dir(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerKeyEncOptErspanAttrs", "Dir"))
    }
    pub fn get_hwid(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerKeyEncOptErspanAttrs::Hwid(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerKeyEncOptErspanAttrs", "Hwid"))
    }
}
impl FlowerKeyEncOptErspanAttrs {
    pub fn new(buf: &'_ [u8]) -> Iterable<'_, FlowerKeyEncOptErspanAttrs> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Ver",
            2u16 => "Index",
            3u16 => "Dir",
            4u16 => "Hwid",
            _ => return None,
        };
        Some(res)
    }
}
impl Iterator for Iterable<'_, FlowerKeyEncOptErspanAttrs> {
    type Item = Result<FlowerKeyEncOptErspanAttrs, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => FlowerKeyEncOptErspanAttrs::Ver({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => FlowerKeyEncOptErspanAttrs::Index({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => FlowerKeyEncOptErspanAttrs::Dir({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => FlowerKeyEncOptErspanAttrs::Hwid({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "FlowerKeyEncOptErspanAttrs",
            r#type.and_then(|t| FlowerKeyEncOptErspanAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl std::fmt::Debug for Iterable<'_, FlowerKeyEncOptErspanAttrs> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("FlowerKeyEncOptErspanAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                FlowerKeyEncOptErspanAttrs::Ver(val) => fmt.field("Ver", &val),
                FlowerKeyEncOptErspanAttrs::Index(val) => fmt.field("Index", &val),
                FlowerKeyEncOptErspanAttrs::Dir(val) => fmt.field("Dir", &val),
                FlowerKeyEncOptErspanAttrs::Hwid(val) => fmt.field("Hwid", &val),
            };
        }
        fmt.finish()
    }
}
impl Iterable<'_, FlowerKeyEncOptErspanAttrs> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("FlowerKeyEncOptErspanAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| FlowerKeyEncOptErspanAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                FlowerKeyEncOptErspanAttrs::Ver(val) => {
                    if last_off == offset {
                        stack.push(("Ver", last_off));
                        break;
                    }
                }
                FlowerKeyEncOptErspanAttrs::Index(val) => {
                    if last_off == offset {
                        stack.push(("Index", last_off));
                        break;
                    }
                }
                FlowerKeyEncOptErspanAttrs::Dir(val) => {
                    if last_off == offset {
                        stack.push(("Dir", last_off));
                        break;
                    }
                }
                FlowerKeyEncOptErspanAttrs::Hwid(val) => {
                    if last_off == offset {
                        stack.push(("Hwid", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("FlowerKeyEncOptErspanAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"flower-key-enc-opt-gtp-attrs\""]
#[derive(Clone)]
pub enum FlowerKeyEncOptGtpAttrs {
    PduType(u8),
    Qfi(u8),
}
impl<'a> Iterable<'a, FlowerKeyEncOptGtpAttrs> {
    pub fn get_pdu_type(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerKeyEncOptGtpAttrs::PduType(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerKeyEncOptGtpAttrs", "PduType"))
    }
    pub fn get_qfi(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerKeyEncOptGtpAttrs::Qfi(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerKeyEncOptGtpAttrs", "Qfi"))
    }
}
impl FlowerKeyEncOptGtpAttrs {
    pub fn new(buf: &'_ [u8]) -> Iterable<'_, FlowerKeyEncOptGtpAttrs> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "PduType",
            2u16 => "Qfi",
            _ => return None,
        };
        Some(res)
    }
}
impl Iterator for Iterable<'_, FlowerKeyEncOptGtpAttrs> {
    type Item = Result<FlowerKeyEncOptGtpAttrs, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => FlowerKeyEncOptGtpAttrs::PduType({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => FlowerKeyEncOptGtpAttrs::Qfi({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "FlowerKeyEncOptGtpAttrs",
            r#type.and_then(|t| FlowerKeyEncOptGtpAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl std::fmt::Debug for Iterable<'_, FlowerKeyEncOptGtpAttrs> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("FlowerKeyEncOptGtpAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                FlowerKeyEncOptGtpAttrs::PduType(val) => fmt.field("PduType", &val),
                FlowerKeyEncOptGtpAttrs::Qfi(val) => fmt.field("Qfi", &val),
            };
        }
        fmt.finish()
    }
}
impl Iterable<'_, FlowerKeyEncOptGtpAttrs> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("FlowerKeyEncOptGtpAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| FlowerKeyEncOptGtpAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                FlowerKeyEncOptGtpAttrs::PduType(val) => {
                    if last_off == offset {
                        stack.push(("PduType", last_off));
                        break;
                    }
                }
                FlowerKeyEncOptGtpAttrs::Qfi(val) => {
                    if last_off == offset {
                        stack.push(("Qfi", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("FlowerKeyEncOptGtpAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"flower-key-mpls-opt-attrs\""]
#[derive(Clone)]
pub enum FlowerKeyMplsOptAttrs {
    LseDepth(u8),
    LseTtl(u8),
    LseBos(u8),
    LseTc(u8),
    LseLabel(u32),
}
impl<'a> Iterable<'a, FlowerKeyMplsOptAttrs> {
    pub fn get_lse_depth(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerKeyMplsOptAttrs::LseDepth(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerKeyMplsOptAttrs", "LseDepth"))
    }
    pub fn get_lse_ttl(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerKeyMplsOptAttrs::LseTtl(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerKeyMplsOptAttrs", "LseTtl"))
    }
    pub fn get_lse_bos(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerKeyMplsOptAttrs::LseBos(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerKeyMplsOptAttrs", "LseBos"))
    }
    pub fn get_lse_tc(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerKeyMplsOptAttrs::LseTc(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerKeyMplsOptAttrs", "LseTc"))
    }
    pub fn get_lse_label(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerKeyMplsOptAttrs::LseLabel(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerKeyMplsOptAttrs", "LseLabel"))
    }
}
impl FlowerKeyMplsOptAttrs {
    pub fn new(buf: &'_ [u8]) -> Iterable<'_, FlowerKeyMplsOptAttrs> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "LseDepth",
            2u16 => "LseTtl",
            3u16 => "LseBos",
            4u16 => "LseTc",
            5u16 => "LseLabel",
            _ => return None,
        };
        Some(res)
    }
}
impl Iterator for Iterable<'_, FlowerKeyMplsOptAttrs> {
    type Item = Result<FlowerKeyMplsOptAttrs, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => FlowerKeyMplsOptAttrs::LseDepth({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => FlowerKeyMplsOptAttrs::LseTtl({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => FlowerKeyMplsOptAttrs::LseBos({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => FlowerKeyMplsOptAttrs::LseTc({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => FlowerKeyMplsOptAttrs::LseLabel({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "FlowerKeyMplsOptAttrs",
            r#type.and_then(|t| FlowerKeyMplsOptAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl std::fmt::Debug for Iterable<'_, FlowerKeyMplsOptAttrs> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("FlowerKeyMplsOptAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                FlowerKeyMplsOptAttrs::LseDepth(val) => fmt.field("LseDepth", &val),
                FlowerKeyMplsOptAttrs::LseTtl(val) => fmt.field("LseTtl", &val),
                FlowerKeyMplsOptAttrs::LseBos(val) => fmt.field("LseBos", &val),
                FlowerKeyMplsOptAttrs::LseTc(val) => fmt.field("LseTc", &val),
                FlowerKeyMplsOptAttrs::LseLabel(val) => fmt.field("LseLabel", &val),
            };
        }
        fmt.finish()
    }
}
impl Iterable<'_, FlowerKeyMplsOptAttrs> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("FlowerKeyMplsOptAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| FlowerKeyMplsOptAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                FlowerKeyMplsOptAttrs::LseDepth(val) => {
                    if last_off == offset {
                        stack.push(("LseDepth", last_off));
                        break;
                    }
                }
                FlowerKeyMplsOptAttrs::LseTtl(val) => {
                    if last_off == offset {
                        stack.push(("LseTtl", last_off));
                        break;
                    }
                }
                FlowerKeyMplsOptAttrs::LseBos(val) => {
                    if last_off == offset {
                        stack.push(("LseBos", last_off));
                        break;
                    }
                }
                FlowerKeyMplsOptAttrs::LseTc(val) => {
                    if last_off == offset {
                        stack.push(("LseTc", last_off));
                        break;
                    }
                }
                FlowerKeyMplsOptAttrs::LseLabel(val) => {
                    if last_off == offset {
                        stack.push(("LseLabel", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("FlowerKeyMplsOptAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"flower-key-cfm-attrs\""]
#[derive(Clone)]
pub enum FlowerKeyCfmAttrs {
    MdLevel(u8),
    Opcode(u8),
}
impl<'a> Iterable<'a, FlowerKeyCfmAttrs> {
    pub fn get_md_level(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerKeyCfmAttrs::MdLevel(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerKeyCfmAttrs", "MdLevel"))
    }
    pub fn get_opcode(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowerKeyCfmAttrs::Opcode(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FlowerKeyCfmAttrs", "Opcode"))
    }
}
impl FlowerKeyCfmAttrs {
    pub fn new(buf: &'_ [u8]) -> Iterable<'_, FlowerKeyCfmAttrs> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "MdLevel",
            2u16 => "Opcode",
            _ => return None,
        };
        Some(res)
    }
}
impl Iterator for Iterable<'_, FlowerKeyCfmAttrs> {
    type Item = Result<FlowerKeyCfmAttrs, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => FlowerKeyCfmAttrs::MdLevel({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => FlowerKeyCfmAttrs::Opcode({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "FlowerKeyCfmAttrs",
            r#type.and_then(|t| FlowerKeyCfmAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl std::fmt::Debug for Iterable<'_, FlowerKeyCfmAttrs> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("FlowerKeyCfmAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                FlowerKeyCfmAttrs::MdLevel(val) => fmt.field("MdLevel", &val),
                FlowerKeyCfmAttrs::Opcode(val) => fmt.field("Opcode", &val),
            };
        }
        fmt.finish()
    }
}
impl Iterable<'_, FlowerKeyCfmAttrs> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("FlowerKeyCfmAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| FlowerKeyCfmAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                FlowerKeyCfmAttrs::MdLevel(val) => {
                    if last_off == offset {
                        stack.push(("MdLevel", last_off));
                        break;
                    }
                }
                FlowerKeyCfmAttrs::Opcode(val) => {
                    if last_off == offset {
                        stack.push(("Opcode", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("FlowerKeyCfmAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"fw-attrs\""]
#[derive(Clone)]
pub enum FwAttrs<'a> {
    Classid(u32),
    Police(Iterable<'a, PoliceAttrs<'a>>),
    Indev(&'a CStr),
    Act(Iterable<'a, Iterable<'a, ActAttrs<'a>>>),
    Mask(u32),
}
impl<'a> Iterable<'a, FwAttrs<'a>> {
    pub fn get_classid(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FwAttrs::Classid(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FwAttrs", "Classid"))
    }
    pub fn get_police(&self) -> Result<Iterable<'a, PoliceAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FwAttrs::Police(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FwAttrs", "Police"))
    }
    pub fn get_indev(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FwAttrs::Indev(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FwAttrs", "Indev"))
    }
    pub fn get_act(
        &self,
    ) -> Result<
        ArrayIterable<Iterable<'a, Iterable<'a, ActAttrs<'a>>>, Iterable<'a, ActAttrs<'a>>>,
        ErrorContext,
    > {
        for attr in self.clone() {
            if let FwAttrs::Act(val) = attr? {
                return Ok(ArrayIterable::new(val));
            }
        }
        Err(self.error_missing("FwAttrs", "Act"))
    }
    pub fn get_mask(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FwAttrs::Mask(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FwAttrs", "Mask"))
    }
}
impl<'a> FwAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, FwAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Classid",
            2u16 => "Police",
            3u16 => "Indev",
            4u16 => "Act",
            5u16 => "Mask",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, FwAttrs<'a>> {
    type Item = Result<FwAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => FwAttrs::Classid({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => FwAttrs::Police({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => FwAttrs::Indev({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => FwAttrs::Act({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => FwAttrs::Mask({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "FwAttrs",
            r#type.and_then(|t| FwAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, FwAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("FwAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                FwAttrs::Classid(val) => fmt.field("Classid", &val),
                FwAttrs::Police(val) => fmt.field("Police", &val),
                FwAttrs::Indev(val) => fmt.field("Indev", &val),
                FwAttrs::Act(val) => fmt.field("Act", &val),
                FwAttrs::Mask(val) => fmt.field("Mask", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, FwAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("FwAttrs", offset));
            return (stack, missing_type.and_then(|t| FwAttrs::attr_from_type(t)));
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                FwAttrs::Classid(val) => {
                    if last_off == offset {
                        stack.push(("Classid", last_off));
                        break;
                    }
                }
                FwAttrs::Police(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                FwAttrs::Indev(val) => {
                    if last_off == offset {
                        stack.push(("Indev", last_off));
                        break;
                    }
                }
                FwAttrs::Act(val) => {
                    for entry in val {
                        let Ok(attr) = entry else { break };
                        (stack, missing) = attr.lookup_attr(offset, missing_type);
                        if !stack.is_empty() {
                            break;
                        }
                    }
                    if !stack.is_empty() {
                        stack.push(("Act", last_off));
                        break;
                    }
                }
                FwAttrs::Mask(val) => {
                    if last_off == offset {
                        stack.push(("Mask", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("FwAttrs", cur));
        }
        (stack, missing)
    }
}
#[doc = "Original name: \"gred-attrs\""]
#[derive(Clone)]
pub enum GredAttrs<'a> {
    Parms(&'a [u8]),
    Stab(&'a [u8]),
    Dps(PushTcGredSopt),
    MaxP(&'a [u8]),
    Limit(u32),
    VqList(Iterable<'a, TcaGredVqListAttrs<'a>>),
}
impl<'a> Iterable<'a, GredAttrs<'a>> {
    pub fn get_parms(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let GredAttrs::Parms(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("GredAttrs", "Parms"))
    }
    pub fn get_stab(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let GredAttrs::Stab(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("GredAttrs", "Stab"))
    }
    pub fn get_dps(&self) -> Result<PushTcGredSopt, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let GredAttrs::Dps(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("GredAttrs", "Dps"))
    }
    pub fn get_max_p(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let GredAttrs::MaxP(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("GredAttrs", "MaxP"))
    }
    pub fn get_limit(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let GredAttrs::Limit(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("GredAttrs", "Limit"))
    }
    pub fn get_vq_list(&self) -> Result<Iterable<'a, TcaGredVqListAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let GredAttrs::VqList(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("GredAttrs", "VqList"))
    }
}
impl<'a> GredAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, GredAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Parms",
            2u16 => "Stab",
            3u16 => "Dps",
            4u16 => "MaxP",
            5u16 => "Limit",
            6u16 => "VqList",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, GredAttrs<'a>> {
    type Item = Result<GredAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => GredAttrs::Parms({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => GredAttrs::Stab({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => GredAttrs::Dps({
                    let res = PushTcGredSopt::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => GredAttrs::MaxP({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => GredAttrs::Limit({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => GredAttrs::VqList({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "GredAttrs",
            r#type.and_then(|t| GredAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, GredAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("GredAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                GredAttrs::Parms(val) => fmt.field("Parms", &val),
                GredAttrs::Stab(val) => fmt.field("Stab", &val),
                GredAttrs::Dps(val) => fmt.field("Dps", &val),
                GredAttrs::MaxP(val) => fmt.field("MaxP", &val),
                GredAttrs::Limit(val) => fmt.field("Limit", &val),
                GredAttrs::VqList(val) => fmt.field("VqList", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, GredAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("GredAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| GredAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                GredAttrs::Parms(val) => {
                    if last_off == offset {
                        stack.push(("Parms", last_off));
                        break;
                    }
                }
                GredAttrs::Stab(val) => {
                    if last_off == offset {
                        stack.push(("Stab", last_off));
                        break;
                    }
                }
                GredAttrs::Dps(val) => {
                    if last_off == offset {
                        stack.push(("Dps", last_off));
                        break;
                    }
                }
                GredAttrs::MaxP(val) => {
                    if last_off == offset {
                        stack.push(("MaxP", last_off));
                        break;
                    }
                }
                GredAttrs::Limit(val) => {
                    if last_off == offset {
                        stack.push(("Limit", last_off));
                        break;
                    }
                }
                GredAttrs::VqList(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("GredAttrs", cur));
        }
        (stack, missing)
    }
}
#[doc = "Original name: \"tca-gred-vq-list-attrs\""]
#[derive(Clone)]
pub enum TcaGredVqListAttrs<'a> {
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    Entry(Iterable<'a, TcaGredVqEntryAttrs<'a>>),
}
impl<'a> Iterable<'a, TcaGredVqListAttrs<'a>> {
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn get_entry(
        &self,
    ) -> MultiAttrIterable<Self, TcaGredVqListAttrs<'a>, Iterable<'a, TcaGredVqEntryAttrs<'a>>>
    {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let TcaGredVqListAttrs::Entry(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
}
impl<'a> TcaGredVqListAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, TcaGredVqListAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Entry",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, TcaGredVqListAttrs<'a>> {
    type Item = Result<TcaGredVqListAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => TcaGredVqListAttrs::Entry({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "TcaGredVqListAttrs",
            r#type.and_then(|t| TcaGredVqListAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, TcaGredVqListAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("TcaGredVqListAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                TcaGredVqListAttrs::Entry(val) => fmt.field("Entry", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, TcaGredVqListAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("TcaGredVqListAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| TcaGredVqListAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                TcaGredVqListAttrs::Entry(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("TcaGredVqListAttrs", cur));
        }
        (stack, missing)
    }
}
#[doc = "Original name: \"tca-gred-vq-entry-attrs\""]
#[derive(Clone)]
pub enum TcaGredVqEntryAttrs<'a> {
    Pad(&'a [u8]),
    Dp(u32),
    StatBytes(u64),
    StatPackets(u32),
    StatBacklog(u32),
    StatProbDrop(u32),
    StatProbMark(u32),
    StatForcedDrop(u32),
    StatForcedMark(u32),
    StatPdrop(u32),
    StatOther(u32),
    Flags(u32),
}
impl<'a> Iterable<'a, TcaGredVqEntryAttrs<'a>> {
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TcaGredVqEntryAttrs::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("TcaGredVqEntryAttrs", "Pad"))
    }
    pub fn get_dp(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TcaGredVqEntryAttrs::Dp(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("TcaGredVqEntryAttrs", "Dp"))
    }
    pub fn get_stat_bytes(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TcaGredVqEntryAttrs::StatBytes(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("TcaGredVqEntryAttrs", "StatBytes"))
    }
    pub fn get_stat_packets(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TcaGredVqEntryAttrs::StatPackets(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("TcaGredVqEntryAttrs", "StatPackets"))
    }
    pub fn get_stat_backlog(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TcaGredVqEntryAttrs::StatBacklog(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("TcaGredVqEntryAttrs", "StatBacklog"))
    }
    pub fn get_stat_prob_drop(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TcaGredVqEntryAttrs::StatProbDrop(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("TcaGredVqEntryAttrs", "StatProbDrop"))
    }
    pub fn get_stat_prob_mark(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TcaGredVqEntryAttrs::StatProbMark(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("TcaGredVqEntryAttrs", "StatProbMark"))
    }
    pub fn get_stat_forced_drop(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TcaGredVqEntryAttrs::StatForcedDrop(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("TcaGredVqEntryAttrs", "StatForcedDrop"))
    }
    pub fn get_stat_forced_mark(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TcaGredVqEntryAttrs::StatForcedMark(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("TcaGredVqEntryAttrs", "StatForcedMark"))
    }
    pub fn get_stat_pdrop(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TcaGredVqEntryAttrs::StatPdrop(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("TcaGredVqEntryAttrs", "StatPdrop"))
    }
    pub fn get_stat_other(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TcaGredVqEntryAttrs::StatOther(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("TcaGredVqEntryAttrs", "StatOther"))
    }
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TcaGredVqEntryAttrs::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("TcaGredVqEntryAttrs", "Flags"))
    }
}
impl<'a> TcaGredVqEntryAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, TcaGredVqEntryAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Pad",
            2u16 => "Dp",
            3u16 => "StatBytes",
            4u16 => "StatPackets",
            5u16 => "StatBacklog",
            6u16 => "StatProbDrop",
            7u16 => "StatProbMark",
            8u16 => "StatForcedDrop",
            9u16 => "StatForcedMark",
            10u16 => "StatPdrop",
            11u16 => "StatOther",
            12u16 => "Flags",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, TcaGredVqEntryAttrs<'a>> {
    type Item = Result<TcaGredVqEntryAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => TcaGredVqEntryAttrs::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => TcaGredVqEntryAttrs::Dp({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => TcaGredVqEntryAttrs::StatBytes({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => TcaGredVqEntryAttrs::StatPackets({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => TcaGredVqEntryAttrs::StatBacklog({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => TcaGredVqEntryAttrs::StatProbDrop({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => TcaGredVqEntryAttrs::StatProbMark({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => TcaGredVqEntryAttrs::StatForcedDrop({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => TcaGredVqEntryAttrs::StatForcedMark({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => TcaGredVqEntryAttrs::StatPdrop({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => TcaGredVqEntryAttrs::StatOther({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                12u16 => TcaGredVqEntryAttrs::Flags({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "TcaGredVqEntryAttrs",
            r#type.and_then(|t| TcaGredVqEntryAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, TcaGredVqEntryAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("TcaGredVqEntryAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                TcaGredVqEntryAttrs::Pad(val) => fmt.field("Pad", &val),
                TcaGredVqEntryAttrs::Dp(val) => fmt.field("Dp", &val),
                TcaGredVqEntryAttrs::StatBytes(val) => fmt.field("StatBytes", &val),
                TcaGredVqEntryAttrs::StatPackets(val) => fmt.field("StatPackets", &val),
                TcaGredVqEntryAttrs::StatBacklog(val) => fmt.field("StatBacklog", &val),
                TcaGredVqEntryAttrs::StatProbDrop(val) => fmt.field("StatProbDrop", &val),
                TcaGredVqEntryAttrs::StatProbMark(val) => fmt.field("StatProbMark", &val),
                TcaGredVqEntryAttrs::StatForcedDrop(val) => fmt.field("StatForcedDrop", &val),
                TcaGredVqEntryAttrs::StatForcedMark(val) => fmt.field("StatForcedMark", &val),
                TcaGredVqEntryAttrs::StatPdrop(val) => fmt.field("StatPdrop", &val),
                TcaGredVqEntryAttrs::StatOther(val) => fmt.field("StatOther", &val),
                TcaGredVqEntryAttrs::Flags(val) => fmt.field("Flags", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, TcaGredVqEntryAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("TcaGredVqEntryAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| TcaGredVqEntryAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                TcaGredVqEntryAttrs::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                TcaGredVqEntryAttrs::Dp(val) => {
                    if last_off == offset {
                        stack.push(("Dp", last_off));
                        break;
                    }
                }
                TcaGredVqEntryAttrs::StatBytes(val) => {
                    if last_off == offset {
                        stack.push(("StatBytes", last_off));
                        break;
                    }
                }
                TcaGredVqEntryAttrs::StatPackets(val) => {
                    if last_off == offset {
                        stack.push(("StatPackets", last_off));
                        break;
                    }
                }
                TcaGredVqEntryAttrs::StatBacklog(val) => {
                    if last_off == offset {
                        stack.push(("StatBacklog", last_off));
                        break;
                    }
                }
                TcaGredVqEntryAttrs::StatProbDrop(val) => {
                    if last_off == offset {
                        stack.push(("StatProbDrop", last_off));
                        break;
                    }
                }
                TcaGredVqEntryAttrs::StatProbMark(val) => {
                    if last_off == offset {
                        stack.push(("StatProbMark", last_off));
                        break;
                    }
                }
                TcaGredVqEntryAttrs::StatForcedDrop(val) => {
                    if last_off == offset {
                        stack.push(("StatForcedDrop", last_off));
                        break;
                    }
                }
                TcaGredVqEntryAttrs::StatForcedMark(val) => {
                    if last_off == offset {
                        stack.push(("StatForcedMark", last_off));
                        break;
                    }
                }
                TcaGredVqEntryAttrs::StatPdrop(val) => {
                    if last_off == offset {
                        stack.push(("StatPdrop", last_off));
                        break;
                    }
                }
                TcaGredVqEntryAttrs::StatOther(val) => {
                    if last_off == offset {
                        stack.push(("StatOther", last_off));
                        break;
                    }
                }
                TcaGredVqEntryAttrs::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("TcaGredVqEntryAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"hfsc-attrs\""]
#[derive(Clone)]
pub enum HfscAttrs<'a> {
    Rsc(&'a [u8]),
    Fsc(&'a [u8]),
    Usc(&'a [u8]),
}
impl<'a> Iterable<'a, HfscAttrs<'a>> {
    pub fn get_rsc(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let HfscAttrs::Rsc(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("HfscAttrs", "Rsc"))
    }
    pub fn get_fsc(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let HfscAttrs::Fsc(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("HfscAttrs", "Fsc"))
    }
    pub fn get_usc(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let HfscAttrs::Usc(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("HfscAttrs", "Usc"))
    }
}
impl<'a> HfscAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, HfscAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Rsc",
            2u16 => "Fsc",
            3u16 => "Usc",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, HfscAttrs<'a>> {
    type Item = Result<HfscAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => HfscAttrs::Rsc({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => HfscAttrs::Fsc({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => HfscAttrs::Usc({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "HfscAttrs",
            r#type.and_then(|t| HfscAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, HfscAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("HfscAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                HfscAttrs::Rsc(val) => fmt.field("Rsc", &val),
                HfscAttrs::Fsc(val) => fmt.field("Fsc", &val),
                HfscAttrs::Usc(val) => fmt.field("Usc", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, HfscAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("HfscAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| HfscAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                HfscAttrs::Rsc(val) => {
                    if last_off == offset {
                        stack.push(("Rsc", last_off));
                        break;
                    }
                }
                HfscAttrs::Fsc(val) => {
                    if last_off == offset {
                        stack.push(("Fsc", last_off));
                        break;
                    }
                }
                HfscAttrs::Usc(val) => {
                    if last_off == offset {
                        stack.push(("Usc", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("HfscAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"hhf-attrs\""]
#[derive(Clone)]
pub enum HhfAttrs {
    BacklogLimit(u32),
    Quantum(u32),
    HhFlowsLimit(u32),
    ResetTimeout(u32),
    AdmitBytes(u32),
    EvictTimeout(u32),
    NonHhWeight(u32),
}
impl<'a> Iterable<'a, HhfAttrs> {
    pub fn get_backlog_limit(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let HhfAttrs::BacklogLimit(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("HhfAttrs", "BacklogLimit"))
    }
    pub fn get_quantum(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let HhfAttrs::Quantum(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("HhfAttrs", "Quantum"))
    }
    pub fn get_hh_flows_limit(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let HhfAttrs::HhFlowsLimit(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("HhfAttrs", "HhFlowsLimit"))
    }
    pub fn get_reset_timeout(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let HhfAttrs::ResetTimeout(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("HhfAttrs", "ResetTimeout"))
    }
    pub fn get_admit_bytes(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let HhfAttrs::AdmitBytes(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("HhfAttrs", "AdmitBytes"))
    }
    pub fn get_evict_timeout(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let HhfAttrs::EvictTimeout(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("HhfAttrs", "EvictTimeout"))
    }
    pub fn get_non_hh_weight(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let HhfAttrs::NonHhWeight(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("HhfAttrs", "NonHhWeight"))
    }
}
impl HhfAttrs {
    pub fn new(buf: &'_ [u8]) -> Iterable<'_, HhfAttrs> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "BacklogLimit",
            2u16 => "Quantum",
            3u16 => "HhFlowsLimit",
            4u16 => "ResetTimeout",
            5u16 => "AdmitBytes",
            6u16 => "EvictTimeout",
            7u16 => "NonHhWeight",
            _ => return None,
        };
        Some(res)
    }
}
impl Iterator for Iterable<'_, HhfAttrs> {
    type Item = Result<HhfAttrs, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => HhfAttrs::BacklogLimit({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => HhfAttrs::Quantum({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => HhfAttrs::HhFlowsLimit({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => HhfAttrs::ResetTimeout({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => HhfAttrs::AdmitBytes({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => HhfAttrs::EvictTimeout({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => HhfAttrs::NonHhWeight({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "HhfAttrs",
            r#type.and_then(|t| HhfAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl std::fmt::Debug for Iterable<'_, HhfAttrs> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("HhfAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                HhfAttrs::BacklogLimit(val) => fmt.field("BacklogLimit", &val),
                HhfAttrs::Quantum(val) => fmt.field("Quantum", &val),
                HhfAttrs::HhFlowsLimit(val) => fmt.field("HhFlowsLimit", &val),
                HhfAttrs::ResetTimeout(val) => fmt.field("ResetTimeout", &val),
                HhfAttrs::AdmitBytes(val) => fmt.field("AdmitBytes", &val),
                HhfAttrs::EvictTimeout(val) => fmt.field("EvictTimeout", &val),
                HhfAttrs::NonHhWeight(val) => fmt.field("NonHhWeight", &val),
            };
        }
        fmt.finish()
    }
}
impl Iterable<'_, HhfAttrs> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("HhfAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| HhfAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                HhfAttrs::BacklogLimit(val) => {
                    if last_off == offset {
                        stack.push(("BacklogLimit", last_off));
                        break;
                    }
                }
                HhfAttrs::Quantum(val) => {
                    if last_off == offset {
                        stack.push(("Quantum", last_off));
                        break;
                    }
                }
                HhfAttrs::HhFlowsLimit(val) => {
                    if last_off == offset {
                        stack.push(("HhFlowsLimit", last_off));
                        break;
                    }
                }
                HhfAttrs::ResetTimeout(val) => {
                    if last_off == offset {
                        stack.push(("ResetTimeout", last_off));
                        break;
                    }
                }
                HhfAttrs::AdmitBytes(val) => {
                    if last_off == offset {
                        stack.push(("AdmitBytes", last_off));
                        break;
                    }
                }
                HhfAttrs::EvictTimeout(val) => {
                    if last_off == offset {
                        stack.push(("EvictTimeout", last_off));
                        break;
                    }
                }
                HhfAttrs::NonHhWeight(val) => {
                    if last_off == offset {
                        stack.push(("NonHhWeight", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("HhfAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"htb-attrs\""]
#[derive(Clone)]
pub enum HtbAttrs<'a> {
    Parms(PushTcHtbOpt),
    Init(PushTcHtbGlob),
    Ctab(&'a [u8]),
    Rtab(&'a [u8]),
    DirectQlen(u32),
    Rate64(u64),
    Ceil64(u64),
    Pad(&'a [u8]),
    Offload(()),
}
impl<'a> Iterable<'a, HtbAttrs<'a>> {
    pub fn get_parms(&self) -> Result<PushTcHtbOpt, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let HtbAttrs::Parms(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("HtbAttrs", "Parms"))
    }
    pub fn get_init(&self) -> Result<PushTcHtbGlob, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let HtbAttrs::Init(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("HtbAttrs", "Init"))
    }
    pub fn get_ctab(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let HtbAttrs::Ctab(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("HtbAttrs", "Ctab"))
    }
    pub fn get_rtab(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let HtbAttrs::Rtab(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("HtbAttrs", "Rtab"))
    }
    pub fn get_direct_qlen(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let HtbAttrs::DirectQlen(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("HtbAttrs", "DirectQlen"))
    }
    pub fn get_rate64(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let HtbAttrs::Rate64(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("HtbAttrs", "Rate64"))
    }
    pub fn get_ceil64(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let HtbAttrs::Ceil64(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("HtbAttrs", "Ceil64"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let HtbAttrs::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("HtbAttrs", "Pad"))
    }
    pub fn get_offload(&self) -> Result<(), ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let HtbAttrs::Offload(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("HtbAttrs", "Offload"))
    }
}
impl<'a> HtbAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, HtbAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Parms",
            2u16 => "Init",
            3u16 => "Ctab",
            4u16 => "Rtab",
            5u16 => "DirectQlen",
            6u16 => "Rate64",
            7u16 => "Ceil64",
            8u16 => "Pad",
            9u16 => "Offload",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, HtbAttrs<'a>> {
    type Item = Result<HtbAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => HtbAttrs::Parms({
                    let res = PushTcHtbOpt::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => HtbAttrs::Init({
                    let res = PushTcHtbGlob::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => HtbAttrs::Ctab({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => HtbAttrs::Rtab({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => HtbAttrs::DirectQlen({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => HtbAttrs::Rate64({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => HtbAttrs::Ceil64({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => HtbAttrs::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => HtbAttrs::Offload(()),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "HtbAttrs",
            r#type.and_then(|t| HtbAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, HtbAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("HtbAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                HtbAttrs::Parms(val) => fmt.field("Parms", &val),
                HtbAttrs::Init(val) => fmt.field("Init", &val),
                HtbAttrs::Ctab(val) => fmt.field("Ctab", &val),
                HtbAttrs::Rtab(val) => fmt.field("Rtab", &val),
                HtbAttrs::DirectQlen(val) => fmt.field("DirectQlen", &val),
                HtbAttrs::Rate64(val) => fmt.field("Rate64", &val),
                HtbAttrs::Ceil64(val) => fmt.field("Ceil64", &val),
                HtbAttrs::Pad(val) => fmt.field("Pad", &val),
                HtbAttrs::Offload(val) => fmt.field("Offload", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, HtbAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("HtbAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| HtbAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                HtbAttrs::Parms(val) => {
                    if last_off == offset {
                        stack.push(("Parms", last_off));
                        break;
                    }
                }
                HtbAttrs::Init(val) => {
                    if last_off == offset {
                        stack.push(("Init", last_off));
                        break;
                    }
                }
                HtbAttrs::Ctab(val) => {
                    if last_off == offset {
                        stack.push(("Ctab", last_off));
                        break;
                    }
                }
                HtbAttrs::Rtab(val) => {
                    if last_off == offset {
                        stack.push(("Rtab", last_off));
                        break;
                    }
                }
                HtbAttrs::DirectQlen(val) => {
                    if last_off == offset {
                        stack.push(("DirectQlen", last_off));
                        break;
                    }
                }
                HtbAttrs::Rate64(val) => {
                    if last_off == offset {
                        stack.push(("Rate64", last_off));
                        break;
                    }
                }
                HtbAttrs::Ceil64(val) => {
                    if last_off == offset {
                        stack.push(("Ceil64", last_off));
                        break;
                    }
                }
                HtbAttrs::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                HtbAttrs::Offload(val) => {
                    if last_off == offset {
                        stack.push(("Offload", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("HtbAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"matchall-attrs\""]
#[derive(Clone)]
pub enum MatchallAttrs<'a> {
    Classid(u32),
    Act(Iterable<'a, Iterable<'a, ActAttrs<'a>>>),
    Flags(u32),
    Pcnt(PushTcMatchallPcnt),
    Pad(&'a [u8]),
}
impl<'a> Iterable<'a, MatchallAttrs<'a>> {
    pub fn get_classid(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let MatchallAttrs::Classid(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("MatchallAttrs", "Classid"))
    }
    pub fn get_act(
        &self,
    ) -> Result<
        ArrayIterable<Iterable<'a, Iterable<'a, ActAttrs<'a>>>, Iterable<'a, ActAttrs<'a>>>,
        ErrorContext,
    > {
        for attr in self.clone() {
            if let MatchallAttrs::Act(val) = attr? {
                return Ok(ArrayIterable::new(val));
            }
        }
        Err(self.error_missing("MatchallAttrs", "Act"))
    }
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let MatchallAttrs::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("MatchallAttrs", "Flags"))
    }
    pub fn get_pcnt(&self) -> Result<PushTcMatchallPcnt, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let MatchallAttrs::Pcnt(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("MatchallAttrs", "Pcnt"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let MatchallAttrs::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("MatchallAttrs", "Pad"))
    }
}
impl<'a> MatchallAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, MatchallAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Classid",
            2u16 => "Act",
            3u16 => "Flags",
            4u16 => "Pcnt",
            5u16 => "Pad",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, MatchallAttrs<'a>> {
    type Item = Result<MatchallAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => MatchallAttrs::Classid({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => MatchallAttrs::Act({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => MatchallAttrs::Flags({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => MatchallAttrs::Pcnt({
                    let res = PushTcMatchallPcnt::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => MatchallAttrs::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "MatchallAttrs",
            r#type.and_then(|t| MatchallAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, MatchallAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("MatchallAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                MatchallAttrs::Classid(val) => fmt.field("Classid", &val),
                MatchallAttrs::Act(val) => fmt.field("Act", &val),
                MatchallAttrs::Flags(val) => fmt.field("Flags", &val),
                MatchallAttrs::Pcnt(val) => fmt.field("Pcnt", &val),
                MatchallAttrs::Pad(val) => fmt.field("Pad", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, MatchallAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("MatchallAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| MatchallAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                MatchallAttrs::Classid(val) => {
                    if last_off == offset {
                        stack.push(("Classid", last_off));
                        break;
                    }
                }
                MatchallAttrs::Act(val) => {
                    for entry in val {
                        let Ok(attr) = entry else { break };
                        (stack, missing) = attr.lookup_attr(offset, missing_type);
                        if !stack.is_empty() {
                            break;
                        }
                    }
                    if !stack.is_empty() {
                        stack.push(("Act", last_off));
                        break;
                    }
                }
                MatchallAttrs::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                MatchallAttrs::Pcnt(val) => {
                    if last_off == offset {
                        stack.push(("Pcnt", last_off));
                        break;
                    }
                }
                MatchallAttrs::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("MatchallAttrs", cur));
        }
        (stack, missing)
    }
}
#[doc = "Original name: \"etf-attrs\""]
#[derive(Clone)]
pub enum EtfAttrs {
    Parms(PushTcEtfQopt),
}
impl<'a> Iterable<'a, EtfAttrs> {
    pub fn get_parms(&self) -> Result<PushTcEtfQopt, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let EtfAttrs::Parms(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("EtfAttrs", "Parms"))
    }
}
impl EtfAttrs {
    pub fn new(buf: &'_ [u8]) -> Iterable<'_, EtfAttrs> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Parms",
            _ => return None,
        };
        Some(res)
    }
}
impl Iterator for Iterable<'_, EtfAttrs> {
    type Item = Result<EtfAttrs, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => EtfAttrs::Parms({
                    let res = PushTcEtfQopt::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "EtfAttrs",
            r#type.and_then(|t| EtfAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl std::fmt::Debug for Iterable<'_, EtfAttrs> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("EtfAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                EtfAttrs::Parms(val) => fmt.field("Parms", &val),
            };
        }
        fmt.finish()
    }
}
impl Iterable<'_, EtfAttrs> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("EtfAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| EtfAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                EtfAttrs::Parms(val) => {
                    if last_off == offset {
                        stack.push(("Parms", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("EtfAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"ets-attrs\""]
#[derive(Clone)]
pub enum EtsAttrs<'a> {
    Nbands(u8),
    Nstrict(u8),
    Quanta(Iterable<'a, EtsAttrs<'a>>),
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    QuantaBand(u32),
    Priomap(Iterable<'a, EtsAttrs<'a>>),
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    PriomapBand(u8),
}
impl<'a> Iterable<'a, EtsAttrs<'a>> {
    pub fn get_nbands(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let EtsAttrs::Nbands(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("EtsAttrs", "Nbands"))
    }
    pub fn get_nstrict(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let EtsAttrs::Nstrict(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("EtsAttrs", "Nstrict"))
    }
    pub fn get_quanta(&self) -> Result<Iterable<'a, EtsAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let EtsAttrs::Quanta(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("EtsAttrs", "Quanta"))
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn get_quanta_band(&self) -> MultiAttrIterable<Self, EtsAttrs<'a>, u32> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let EtsAttrs::QuantaBand(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
    pub fn get_priomap(&self) -> Result<Iterable<'a, EtsAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let EtsAttrs::Priomap(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("EtsAttrs", "Priomap"))
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn get_priomap_band(&self) -> MultiAttrIterable<Self, EtsAttrs<'a>, u8> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let EtsAttrs::PriomapBand(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
}
impl<'a> EtsAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, EtsAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Nbands",
            2u16 => "Nstrict",
            3u16 => "Quanta",
            4u16 => "QuantaBand",
            5u16 => "Priomap",
            6u16 => "PriomapBand",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, EtsAttrs<'a>> {
    type Item = Result<EtsAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => EtsAttrs::Nbands({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => EtsAttrs::Nstrict({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => EtsAttrs::Quanta({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => EtsAttrs::QuantaBand({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => EtsAttrs::Priomap({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => EtsAttrs::PriomapBand({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "EtsAttrs",
            r#type.and_then(|t| EtsAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, EtsAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("EtsAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                EtsAttrs::Nbands(val) => fmt.field("Nbands", &val),
                EtsAttrs::Nstrict(val) => fmt.field("Nstrict", &val),
                EtsAttrs::Quanta(val) => fmt.field("Quanta", &val),
                EtsAttrs::QuantaBand(val) => fmt.field("QuantaBand", &val),
                EtsAttrs::Priomap(val) => fmt.field("Priomap", &val),
                EtsAttrs::PriomapBand(val) => fmt.field("PriomapBand", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, EtsAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("EtsAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| EtsAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                EtsAttrs::Nbands(val) => {
                    if last_off == offset {
                        stack.push(("Nbands", last_off));
                        break;
                    }
                }
                EtsAttrs::Nstrict(val) => {
                    if last_off == offset {
                        stack.push(("Nstrict", last_off));
                        break;
                    }
                }
                EtsAttrs::Quanta(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                EtsAttrs::QuantaBand(val) => {
                    if last_off == offset {
                        stack.push(("QuantaBand", last_off));
                        break;
                    }
                }
                EtsAttrs::Priomap(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                EtsAttrs::PriomapBand(val) => {
                    if last_off == offset {
                        stack.push(("PriomapBand", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("EtsAttrs", cur));
        }
        (stack, missing)
    }
}
#[doc = "Original name: \"fq-attrs\""]
#[derive(Clone)]
pub enum FqAttrs<'a> {
    #[doc = "Limit of total number of packets in queue"]
    Plimit(u32),
    #[doc = "Limit of packets per flow"]
    FlowPlimit(u32),
    #[doc = "RR quantum"]
    Quantum(u32),
    #[doc = "RR quantum for new flow"]
    InitialQuantum(u32),
    #[doc = "Enable / disable rate limiting"]
    RateEnable(u32),
    #[doc = "Obsolete, do not use"]
    FlowDefaultRate(u32),
    #[doc = "Per flow max rate"]
    FlowMaxRate(u32),
    #[doc = "log2(number of buckets)"]
    BucketsLog(u32),
    #[doc = "Flow credit refill delay in usec"]
    FlowRefillDelay(u32),
    #[doc = "Mask applied to orphaned skb hashes"]
    OrphanMask(u32),
    #[doc = "Per packet delay under this rate"]
    LowRateThreshold(u32),
    #[doc = "DCTCP-like CE marking threshold"]
    CeThreshold(u32),
    TimerSlack(u32),
    #[doc = "Time horizon in usec"]
    Horizon(u32),
    #[doc = "Drop packets beyond horizon, or cap their EDT"]
    HorizonDrop(u8),
    Priomap(PushTcPrioQopt),
    #[doc = "Weights for each band"]
    Weights(&'a [u8]),
}
impl<'a> Iterable<'a, FqAttrs<'a>> {
    #[doc = "Limit of total number of packets in queue"]
    pub fn get_plimit(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FqAttrs::Plimit(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FqAttrs", "Plimit"))
    }
    #[doc = "Limit of packets per flow"]
    pub fn get_flow_plimit(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FqAttrs::FlowPlimit(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FqAttrs", "FlowPlimit"))
    }
    #[doc = "RR quantum"]
    pub fn get_quantum(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FqAttrs::Quantum(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FqAttrs", "Quantum"))
    }
    #[doc = "RR quantum for new flow"]
    pub fn get_initial_quantum(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FqAttrs::InitialQuantum(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FqAttrs", "InitialQuantum"))
    }
    #[doc = "Enable / disable rate limiting"]
    pub fn get_rate_enable(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FqAttrs::RateEnable(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FqAttrs", "RateEnable"))
    }
    #[doc = "Obsolete, do not use"]
    pub fn get_flow_default_rate(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FqAttrs::FlowDefaultRate(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FqAttrs", "FlowDefaultRate"))
    }
    #[doc = "Per flow max rate"]
    pub fn get_flow_max_rate(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FqAttrs::FlowMaxRate(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FqAttrs", "FlowMaxRate"))
    }
    #[doc = "log2(number of buckets)"]
    pub fn get_buckets_log(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FqAttrs::BucketsLog(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FqAttrs", "BucketsLog"))
    }
    #[doc = "Flow credit refill delay in usec"]
    pub fn get_flow_refill_delay(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FqAttrs::FlowRefillDelay(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FqAttrs", "FlowRefillDelay"))
    }
    #[doc = "Mask applied to orphaned skb hashes"]
    pub fn get_orphan_mask(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FqAttrs::OrphanMask(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FqAttrs", "OrphanMask"))
    }
    #[doc = "Per packet delay under this rate"]
    pub fn get_low_rate_threshold(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FqAttrs::LowRateThreshold(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FqAttrs", "LowRateThreshold"))
    }
    #[doc = "DCTCP-like CE marking threshold"]
    pub fn get_ce_threshold(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FqAttrs::CeThreshold(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FqAttrs", "CeThreshold"))
    }
    pub fn get_timer_slack(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FqAttrs::TimerSlack(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FqAttrs", "TimerSlack"))
    }
    #[doc = "Time horizon in usec"]
    pub fn get_horizon(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FqAttrs::Horizon(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FqAttrs", "Horizon"))
    }
    #[doc = "Drop packets beyond horizon, or cap their EDT"]
    pub fn get_horizon_drop(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FqAttrs::HorizonDrop(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FqAttrs", "HorizonDrop"))
    }
    pub fn get_priomap(&self) -> Result<PushTcPrioQopt, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FqAttrs::Priomap(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FqAttrs", "Priomap"))
    }
    #[doc = "Weights for each band"]
    pub fn get_weights(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FqAttrs::Weights(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FqAttrs", "Weights"))
    }
}
impl<'a> FqAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, FqAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Plimit",
            2u16 => "FlowPlimit",
            3u16 => "Quantum",
            4u16 => "InitialQuantum",
            5u16 => "RateEnable",
            6u16 => "FlowDefaultRate",
            7u16 => "FlowMaxRate",
            8u16 => "BucketsLog",
            9u16 => "FlowRefillDelay",
            10u16 => "OrphanMask",
            11u16 => "LowRateThreshold",
            12u16 => "CeThreshold",
            13u16 => "TimerSlack",
            14u16 => "Horizon",
            15u16 => "HorizonDrop",
            16u16 => "Priomap",
            17u16 => "Weights",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, FqAttrs<'a>> {
    type Item = Result<FqAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => FqAttrs::Plimit({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => FqAttrs::FlowPlimit({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => FqAttrs::Quantum({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => FqAttrs::InitialQuantum({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => FqAttrs::RateEnable({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => FqAttrs::FlowDefaultRate({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => FqAttrs::FlowMaxRate({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => FqAttrs::BucketsLog({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => FqAttrs::FlowRefillDelay({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => FqAttrs::OrphanMask({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => FqAttrs::LowRateThreshold({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                12u16 => FqAttrs::CeThreshold({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                13u16 => FqAttrs::TimerSlack({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                14u16 => FqAttrs::Horizon({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                15u16 => FqAttrs::HorizonDrop({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                16u16 => FqAttrs::Priomap({
                    let res = PushTcPrioQopt::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                17u16 => FqAttrs::Weights({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "FqAttrs",
            r#type.and_then(|t| FqAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, FqAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("FqAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                FqAttrs::Plimit(val) => fmt.field("Plimit", &val),
                FqAttrs::FlowPlimit(val) => fmt.field("FlowPlimit", &val),
                FqAttrs::Quantum(val) => fmt.field("Quantum", &val),
                FqAttrs::InitialQuantum(val) => fmt.field("InitialQuantum", &val),
                FqAttrs::RateEnable(val) => fmt.field("RateEnable", &val),
                FqAttrs::FlowDefaultRate(val) => fmt.field("FlowDefaultRate", &val),
                FqAttrs::FlowMaxRate(val) => fmt.field("FlowMaxRate", &val),
                FqAttrs::BucketsLog(val) => fmt.field("BucketsLog", &val),
                FqAttrs::FlowRefillDelay(val) => fmt.field("FlowRefillDelay", &val),
                FqAttrs::OrphanMask(val) => fmt.field("OrphanMask", &val),
                FqAttrs::LowRateThreshold(val) => fmt.field("LowRateThreshold", &val),
                FqAttrs::CeThreshold(val) => fmt.field("CeThreshold", &val),
                FqAttrs::TimerSlack(val) => fmt.field("TimerSlack", &val),
                FqAttrs::Horizon(val) => fmt.field("Horizon", &val),
                FqAttrs::HorizonDrop(val) => fmt.field("HorizonDrop", &val),
                FqAttrs::Priomap(val) => fmt.field("Priomap", &val),
                FqAttrs::Weights(val) => fmt.field("Weights", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, FqAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("FqAttrs", offset));
            return (stack, missing_type.and_then(|t| FqAttrs::attr_from_type(t)));
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                FqAttrs::Plimit(val) => {
                    if last_off == offset {
                        stack.push(("Plimit", last_off));
                        break;
                    }
                }
                FqAttrs::FlowPlimit(val) => {
                    if last_off == offset {
                        stack.push(("FlowPlimit", last_off));
                        break;
                    }
                }
                FqAttrs::Quantum(val) => {
                    if last_off == offset {
                        stack.push(("Quantum", last_off));
                        break;
                    }
                }
                FqAttrs::InitialQuantum(val) => {
                    if last_off == offset {
                        stack.push(("InitialQuantum", last_off));
                        break;
                    }
                }
                FqAttrs::RateEnable(val) => {
                    if last_off == offset {
                        stack.push(("RateEnable", last_off));
                        break;
                    }
                }
                FqAttrs::FlowDefaultRate(val) => {
                    if last_off == offset {
                        stack.push(("FlowDefaultRate", last_off));
                        break;
                    }
                }
                FqAttrs::FlowMaxRate(val) => {
                    if last_off == offset {
                        stack.push(("FlowMaxRate", last_off));
                        break;
                    }
                }
                FqAttrs::BucketsLog(val) => {
                    if last_off == offset {
                        stack.push(("BucketsLog", last_off));
                        break;
                    }
                }
                FqAttrs::FlowRefillDelay(val) => {
                    if last_off == offset {
                        stack.push(("FlowRefillDelay", last_off));
                        break;
                    }
                }
                FqAttrs::OrphanMask(val) => {
                    if last_off == offset {
                        stack.push(("OrphanMask", last_off));
                        break;
                    }
                }
                FqAttrs::LowRateThreshold(val) => {
                    if last_off == offset {
                        stack.push(("LowRateThreshold", last_off));
                        break;
                    }
                }
                FqAttrs::CeThreshold(val) => {
                    if last_off == offset {
                        stack.push(("CeThreshold", last_off));
                        break;
                    }
                }
                FqAttrs::TimerSlack(val) => {
                    if last_off == offset {
                        stack.push(("TimerSlack", last_off));
                        break;
                    }
                }
                FqAttrs::Horizon(val) => {
                    if last_off == offset {
                        stack.push(("Horizon", last_off));
                        break;
                    }
                }
                FqAttrs::HorizonDrop(val) => {
                    if last_off == offset {
                        stack.push(("HorizonDrop", last_off));
                        break;
                    }
                }
                FqAttrs::Priomap(val) => {
                    if last_off == offset {
                        stack.push(("Priomap", last_off));
                        break;
                    }
                }
                FqAttrs::Weights(val) => {
                    if last_off == offset {
                        stack.push(("Weights", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("FqAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"fq-codel-attrs\""]
#[derive(Clone)]
pub enum FqCodelAttrs {
    Target(u32),
    Limit(u32),
    Interval(u32),
    Ecn(u32),
    Flows(u32),
    Quantum(u32),
    CeThreshold(u32),
    DropBatchSize(u32),
    MemoryLimit(u32),
    CeThresholdSelector(u8),
    CeThresholdMask(u8),
}
impl<'a> Iterable<'a, FqCodelAttrs> {
    pub fn get_target(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FqCodelAttrs::Target(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FqCodelAttrs", "Target"))
    }
    pub fn get_limit(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FqCodelAttrs::Limit(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FqCodelAttrs", "Limit"))
    }
    pub fn get_interval(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FqCodelAttrs::Interval(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FqCodelAttrs", "Interval"))
    }
    pub fn get_ecn(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FqCodelAttrs::Ecn(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FqCodelAttrs", "Ecn"))
    }
    pub fn get_flows(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FqCodelAttrs::Flows(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FqCodelAttrs", "Flows"))
    }
    pub fn get_quantum(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FqCodelAttrs::Quantum(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FqCodelAttrs", "Quantum"))
    }
    pub fn get_ce_threshold(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FqCodelAttrs::CeThreshold(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FqCodelAttrs", "CeThreshold"))
    }
    pub fn get_drop_batch_size(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FqCodelAttrs::DropBatchSize(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FqCodelAttrs", "DropBatchSize"))
    }
    pub fn get_memory_limit(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FqCodelAttrs::MemoryLimit(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FqCodelAttrs", "MemoryLimit"))
    }
    pub fn get_ce_threshold_selector(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FqCodelAttrs::CeThresholdSelector(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FqCodelAttrs", "CeThresholdSelector"))
    }
    pub fn get_ce_threshold_mask(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FqCodelAttrs::CeThresholdMask(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FqCodelAttrs", "CeThresholdMask"))
    }
}
impl FqCodelAttrs {
    pub fn new(buf: &'_ [u8]) -> Iterable<'_, FqCodelAttrs> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Target",
            2u16 => "Limit",
            3u16 => "Interval",
            4u16 => "Ecn",
            5u16 => "Flows",
            6u16 => "Quantum",
            7u16 => "CeThreshold",
            8u16 => "DropBatchSize",
            9u16 => "MemoryLimit",
            10u16 => "CeThresholdSelector",
            11u16 => "CeThresholdMask",
            _ => return None,
        };
        Some(res)
    }
}
impl Iterator for Iterable<'_, FqCodelAttrs> {
    type Item = Result<FqCodelAttrs, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => FqCodelAttrs::Target({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => FqCodelAttrs::Limit({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => FqCodelAttrs::Interval({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => FqCodelAttrs::Ecn({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => FqCodelAttrs::Flows({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => FqCodelAttrs::Quantum({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => FqCodelAttrs::CeThreshold({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => FqCodelAttrs::DropBatchSize({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => FqCodelAttrs::MemoryLimit({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => FqCodelAttrs::CeThresholdSelector({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => FqCodelAttrs::CeThresholdMask({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "FqCodelAttrs",
            r#type.and_then(|t| FqCodelAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl std::fmt::Debug for Iterable<'_, FqCodelAttrs> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("FqCodelAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                FqCodelAttrs::Target(val) => fmt.field("Target", &val),
                FqCodelAttrs::Limit(val) => fmt.field("Limit", &val),
                FqCodelAttrs::Interval(val) => fmt.field("Interval", &val),
                FqCodelAttrs::Ecn(val) => fmt.field("Ecn", &val),
                FqCodelAttrs::Flows(val) => fmt.field("Flows", &val),
                FqCodelAttrs::Quantum(val) => fmt.field("Quantum", &val),
                FqCodelAttrs::CeThreshold(val) => fmt.field("CeThreshold", &val),
                FqCodelAttrs::DropBatchSize(val) => fmt.field("DropBatchSize", &val),
                FqCodelAttrs::MemoryLimit(val) => fmt.field("MemoryLimit", &val),
                FqCodelAttrs::CeThresholdSelector(val) => fmt.field("CeThresholdSelector", &val),
                FqCodelAttrs::CeThresholdMask(val) => fmt.field("CeThresholdMask", &val),
            };
        }
        fmt.finish()
    }
}
impl Iterable<'_, FqCodelAttrs> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("FqCodelAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| FqCodelAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                FqCodelAttrs::Target(val) => {
                    if last_off == offset {
                        stack.push(("Target", last_off));
                        break;
                    }
                }
                FqCodelAttrs::Limit(val) => {
                    if last_off == offset {
                        stack.push(("Limit", last_off));
                        break;
                    }
                }
                FqCodelAttrs::Interval(val) => {
                    if last_off == offset {
                        stack.push(("Interval", last_off));
                        break;
                    }
                }
                FqCodelAttrs::Ecn(val) => {
                    if last_off == offset {
                        stack.push(("Ecn", last_off));
                        break;
                    }
                }
                FqCodelAttrs::Flows(val) => {
                    if last_off == offset {
                        stack.push(("Flows", last_off));
                        break;
                    }
                }
                FqCodelAttrs::Quantum(val) => {
                    if last_off == offset {
                        stack.push(("Quantum", last_off));
                        break;
                    }
                }
                FqCodelAttrs::CeThreshold(val) => {
                    if last_off == offset {
                        stack.push(("CeThreshold", last_off));
                        break;
                    }
                }
                FqCodelAttrs::DropBatchSize(val) => {
                    if last_off == offset {
                        stack.push(("DropBatchSize", last_off));
                        break;
                    }
                }
                FqCodelAttrs::MemoryLimit(val) => {
                    if last_off == offset {
                        stack.push(("MemoryLimit", last_off));
                        break;
                    }
                }
                FqCodelAttrs::CeThresholdSelector(val) => {
                    if last_off == offset {
                        stack.push(("CeThresholdSelector", last_off));
                        break;
                    }
                }
                FqCodelAttrs::CeThresholdMask(val) => {
                    if last_off == offset {
                        stack.push(("CeThresholdMask", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("FqCodelAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"fq-pie-attrs\""]
#[derive(Clone)]
pub enum FqPieAttrs {
    Limit(u32),
    Flows(u32),
    Target(u32),
    Tupdate(u32),
    Alpha(u32),
    Beta(u32),
    Quantum(u32),
    MemoryLimit(u32),
    EcnProb(u32),
    Ecn(u32),
    Bytemode(u32),
    DqRateEstimator(u32),
}
impl<'a> Iterable<'a, FqPieAttrs> {
    pub fn get_limit(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FqPieAttrs::Limit(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FqPieAttrs", "Limit"))
    }
    pub fn get_flows(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FqPieAttrs::Flows(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FqPieAttrs", "Flows"))
    }
    pub fn get_target(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FqPieAttrs::Target(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FqPieAttrs", "Target"))
    }
    pub fn get_tupdate(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FqPieAttrs::Tupdate(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FqPieAttrs", "Tupdate"))
    }
    pub fn get_alpha(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FqPieAttrs::Alpha(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FqPieAttrs", "Alpha"))
    }
    pub fn get_beta(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FqPieAttrs::Beta(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FqPieAttrs", "Beta"))
    }
    pub fn get_quantum(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FqPieAttrs::Quantum(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FqPieAttrs", "Quantum"))
    }
    pub fn get_memory_limit(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FqPieAttrs::MemoryLimit(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FqPieAttrs", "MemoryLimit"))
    }
    pub fn get_ecn_prob(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FqPieAttrs::EcnProb(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FqPieAttrs", "EcnProb"))
    }
    pub fn get_ecn(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FqPieAttrs::Ecn(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FqPieAttrs", "Ecn"))
    }
    pub fn get_bytemode(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FqPieAttrs::Bytemode(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FqPieAttrs", "Bytemode"))
    }
    pub fn get_dq_rate_estimator(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FqPieAttrs::DqRateEstimator(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("FqPieAttrs", "DqRateEstimator"))
    }
}
impl FqPieAttrs {
    pub fn new(buf: &'_ [u8]) -> Iterable<'_, FqPieAttrs> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Limit",
            2u16 => "Flows",
            3u16 => "Target",
            4u16 => "Tupdate",
            5u16 => "Alpha",
            6u16 => "Beta",
            7u16 => "Quantum",
            8u16 => "MemoryLimit",
            9u16 => "EcnProb",
            10u16 => "Ecn",
            11u16 => "Bytemode",
            12u16 => "DqRateEstimator",
            _ => return None,
        };
        Some(res)
    }
}
impl Iterator for Iterable<'_, FqPieAttrs> {
    type Item = Result<FqPieAttrs, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => FqPieAttrs::Limit({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => FqPieAttrs::Flows({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => FqPieAttrs::Target({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => FqPieAttrs::Tupdate({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => FqPieAttrs::Alpha({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => FqPieAttrs::Beta({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => FqPieAttrs::Quantum({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => FqPieAttrs::MemoryLimit({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => FqPieAttrs::EcnProb({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => FqPieAttrs::Ecn({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => FqPieAttrs::Bytemode({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                12u16 => FqPieAttrs::DqRateEstimator({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "FqPieAttrs",
            r#type.and_then(|t| FqPieAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl std::fmt::Debug for Iterable<'_, FqPieAttrs> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("FqPieAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                FqPieAttrs::Limit(val) => fmt.field("Limit", &val),
                FqPieAttrs::Flows(val) => fmt.field("Flows", &val),
                FqPieAttrs::Target(val) => fmt.field("Target", &val),
                FqPieAttrs::Tupdate(val) => fmt.field("Tupdate", &val),
                FqPieAttrs::Alpha(val) => fmt.field("Alpha", &val),
                FqPieAttrs::Beta(val) => fmt.field("Beta", &val),
                FqPieAttrs::Quantum(val) => fmt.field("Quantum", &val),
                FqPieAttrs::MemoryLimit(val) => fmt.field("MemoryLimit", &val),
                FqPieAttrs::EcnProb(val) => fmt.field("EcnProb", &val),
                FqPieAttrs::Ecn(val) => fmt.field("Ecn", &val),
                FqPieAttrs::Bytemode(val) => fmt.field("Bytemode", &val),
                FqPieAttrs::DqRateEstimator(val) => fmt.field("DqRateEstimator", &val),
            };
        }
        fmt.finish()
    }
}
impl Iterable<'_, FqPieAttrs> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("FqPieAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| FqPieAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                FqPieAttrs::Limit(val) => {
                    if last_off == offset {
                        stack.push(("Limit", last_off));
                        break;
                    }
                }
                FqPieAttrs::Flows(val) => {
                    if last_off == offset {
                        stack.push(("Flows", last_off));
                        break;
                    }
                }
                FqPieAttrs::Target(val) => {
                    if last_off == offset {
                        stack.push(("Target", last_off));
                        break;
                    }
                }
                FqPieAttrs::Tupdate(val) => {
                    if last_off == offset {
                        stack.push(("Tupdate", last_off));
                        break;
                    }
                }
                FqPieAttrs::Alpha(val) => {
                    if last_off == offset {
                        stack.push(("Alpha", last_off));
                        break;
                    }
                }
                FqPieAttrs::Beta(val) => {
                    if last_off == offset {
                        stack.push(("Beta", last_off));
                        break;
                    }
                }
                FqPieAttrs::Quantum(val) => {
                    if last_off == offset {
                        stack.push(("Quantum", last_off));
                        break;
                    }
                }
                FqPieAttrs::MemoryLimit(val) => {
                    if last_off == offset {
                        stack.push(("MemoryLimit", last_off));
                        break;
                    }
                }
                FqPieAttrs::EcnProb(val) => {
                    if last_off == offset {
                        stack.push(("EcnProb", last_off));
                        break;
                    }
                }
                FqPieAttrs::Ecn(val) => {
                    if last_off == offset {
                        stack.push(("Ecn", last_off));
                        break;
                    }
                }
                FqPieAttrs::Bytemode(val) => {
                    if last_off == offset {
                        stack.push(("Bytemode", last_off));
                        break;
                    }
                }
                FqPieAttrs::DqRateEstimator(val) => {
                    if last_off == offset {
                        stack.push(("DqRateEstimator", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("FqPieAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"netem-attrs\""]
#[derive(Clone)]
pub enum NetemAttrs<'a> {
    Corr(PushTcNetemCorr),
    DelayDist(&'a [u8]),
    Reorder(PushTcNetemReorder),
    Corrupt(PushTcNetemCorrupt),
    Loss(Iterable<'a, NetemLossAttrs>),
    Rate(PushTcNetemRate),
    Ecn(u32),
    Rate64(u64),
    Pad(u32),
    Latency64(i64),
    Jitter64(i64),
    Slot(PushTcNetemSlot),
    SlotDist(&'a [u8]),
    PrngSeed(u64),
}
impl<'a> Iterable<'a, NetemAttrs<'a>> {
    pub fn get_corr(&self) -> Result<PushTcNetemCorr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let NetemAttrs::Corr(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("NetemAttrs", "Corr"))
    }
    pub fn get_delay_dist(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let NetemAttrs::DelayDist(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("NetemAttrs", "DelayDist"))
    }
    pub fn get_reorder(&self) -> Result<PushTcNetemReorder, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let NetemAttrs::Reorder(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("NetemAttrs", "Reorder"))
    }
    pub fn get_corrupt(&self) -> Result<PushTcNetemCorrupt, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let NetemAttrs::Corrupt(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("NetemAttrs", "Corrupt"))
    }
    pub fn get_loss(&self) -> Result<Iterable<'a, NetemLossAttrs>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let NetemAttrs::Loss(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("NetemAttrs", "Loss"))
    }
    pub fn get_rate(&self) -> Result<PushTcNetemRate, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let NetemAttrs::Rate(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("NetemAttrs", "Rate"))
    }
    pub fn get_ecn(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let NetemAttrs::Ecn(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("NetemAttrs", "Ecn"))
    }
    pub fn get_rate64(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let NetemAttrs::Rate64(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("NetemAttrs", "Rate64"))
    }
    pub fn get_pad(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let NetemAttrs::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("NetemAttrs", "Pad"))
    }
    pub fn get_latency64(&self) -> Result<i64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let NetemAttrs::Latency64(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("NetemAttrs", "Latency64"))
    }
    pub fn get_jitter64(&self) -> Result<i64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let NetemAttrs::Jitter64(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("NetemAttrs", "Jitter64"))
    }
    pub fn get_slot(&self) -> Result<PushTcNetemSlot, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let NetemAttrs::Slot(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("NetemAttrs", "Slot"))
    }
    pub fn get_slot_dist(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let NetemAttrs::SlotDist(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("NetemAttrs", "SlotDist"))
    }
    pub fn get_prng_seed(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let NetemAttrs::PrngSeed(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("NetemAttrs", "PrngSeed"))
    }
}
impl<'a> NetemAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, NetemAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Corr",
            2u16 => "DelayDist",
            3u16 => "Reorder",
            4u16 => "Corrupt",
            5u16 => "Loss",
            6u16 => "Rate",
            7u16 => "Ecn",
            8u16 => "Rate64",
            9u16 => "Pad",
            10u16 => "Latency64",
            11u16 => "Jitter64",
            12u16 => "Slot",
            13u16 => "SlotDist",
            14u16 => "PrngSeed",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, NetemAttrs<'a>> {
    type Item = Result<NetemAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => NetemAttrs::Corr({
                    let res = PushTcNetemCorr::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => NetemAttrs::DelayDist({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => NetemAttrs::Reorder({
                    let res = PushTcNetemReorder::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => NetemAttrs::Corrupt({
                    let res = PushTcNetemCorrupt::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => NetemAttrs::Loss({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => NetemAttrs::Rate({
                    let res = PushTcNetemRate::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => NetemAttrs::Ecn({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => NetemAttrs::Rate64({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => NetemAttrs::Pad({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => NetemAttrs::Latency64({
                    let res = parse_i64(next);
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => NetemAttrs::Jitter64({
                    let res = parse_i64(next);
                    let Some(val) = res else { break };
                    val
                }),
                12u16 => NetemAttrs::Slot({
                    let res = PushTcNetemSlot::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                13u16 => NetemAttrs::SlotDist({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                14u16 => NetemAttrs::PrngSeed({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "NetemAttrs",
            r#type.and_then(|t| NetemAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, NetemAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("NetemAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                NetemAttrs::Corr(val) => fmt.field("Corr", &val),
                NetemAttrs::DelayDist(val) => fmt.field("DelayDist", &val),
                NetemAttrs::Reorder(val) => fmt.field("Reorder", &val),
                NetemAttrs::Corrupt(val) => fmt.field("Corrupt", &val),
                NetemAttrs::Loss(val) => fmt.field("Loss", &val),
                NetemAttrs::Rate(val) => fmt.field("Rate", &val),
                NetemAttrs::Ecn(val) => fmt.field("Ecn", &val),
                NetemAttrs::Rate64(val) => fmt.field("Rate64", &val),
                NetemAttrs::Pad(val) => fmt.field("Pad", &val),
                NetemAttrs::Latency64(val) => fmt.field("Latency64", &val),
                NetemAttrs::Jitter64(val) => fmt.field("Jitter64", &val),
                NetemAttrs::Slot(val) => fmt.field("Slot", &val),
                NetemAttrs::SlotDist(val) => fmt.field("SlotDist", &val),
                NetemAttrs::PrngSeed(val) => fmt.field("PrngSeed", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, NetemAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("NetemAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| NetemAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                NetemAttrs::Corr(val) => {
                    if last_off == offset {
                        stack.push(("Corr", last_off));
                        break;
                    }
                }
                NetemAttrs::DelayDist(val) => {
                    if last_off == offset {
                        stack.push(("DelayDist", last_off));
                        break;
                    }
                }
                NetemAttrs::Reorder(val) => {
                    if last_off == offset {
                        stack.push(("Reorder", last_off));
                        break;
                    }
                }
                NetemAttrs::Corrupt(val) => {
                    if last_off == offset {
                        stack.push(("Corrupt", last_off));
                        break;
                    }
                }
                NetemAttrs::Loss(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                NetemAttrs::Rate(val) => {
                    if last_off == offset {
                        stack.push(("Rate", last_off));
                        break;
                    }
                }
                NetemAttrs::Ecn(val) => {
                    if last_off == offset {
                        stack.push(("Ecn", last_off));
                        break;
                    }
                }
                NetemAttrs::Rate64(val) => {
                    if last_off == offset {
                        stack.push(("Rate64", last_off));
                        break;
                    }
                }
                NetemAttrs::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                NetemAttrs::Latency64(val) => {
                    if last_off == offset {
                        stack.push(("Latency64", last_off));
                        break;
                    }
                }
                NetemAttrs::Jitter64(val) => {
                    if last_off == offset {
                        stack.push(("Jitter64", last_off));
                        break;
                    }
                }
                NetemAttrs::Slot(val) => {
                    if last_off == offset {
                        stack.push(("Slot", last_off));
                        break;
                    }
                }
                NetemAttrs::SlotDist(val) => {
                    if last_off == offset {
                        stack.push(("SlotDist", last_off));
                        break;
                    }
                }
                NetemAttrs::PrngSeed(val) => {
                    if last_off == offset {
                        stack.push(("PrngSeed", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("NetemAttrs", cur));
        }
        (stack, missing)
    }
}
#[doc = "Original name: \"netem-loss-attrs\""]
#[derive(Clone)]
pub enum NetemLossAttrs {
    #[doc = "General Intuitive - 4 state model"]
    Gi(PushTcNetemGimodel),
    #[doc = "Gilbert Elliot models"]
    Ge(PushTcNetemGemodel),
}
impl<'a> Iterable<'a, NetemLossAttrs> {
    #[doc = "General Intuitive - 4 state model"]
    pub fn get_gi(&self) -> Result<PushTcNetemGimodel, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let NetemLossAttrs::Gi(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("NetemLossAttrs", "Gi"))
    }
    #[doc = "Gilbert Elliot models"]
    pub fn get_ge(&self) -> Result<PushTcNetemGemodel, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let NetemLossAttrs::Ge(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("NetemLossAttrs", "Ge"))
    }
}
impl NetemLossAttrs {
    pub fn new(buf: &'_ [u8]) -> Iterable<'_, NetemLossAttrs> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Gi",
            2u16 => "Ge",
            _ => return None,
        };
        Some(res)
    }
}
impl Iterator for Iterable<'_, NetemLossAttrs> {
    type Item = Result<NetemLossAttrs, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => NetemLossAttrs::Gi({
                    let res = PushTcNetemGimodel::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => NetemLossAttrs::Ge({
                    let res = PushTcNetemGemodel::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "NetemLossAttrs",
            r#type.and_then(|t| NetemLossAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl std::fmt::Debug for Iterable<'_, NetemLossAttrs> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("NetemLossAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                NetemLossAttrs::Gi(val) => fmt.field("Gi", &val),
                NetemLossAttrs::Ge(val) => fmt.field("Ge", &val),
            };
        }
        fmt.finish()
    }
}
impl Iterable<'_, NetemLossAttrs> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("NetemLossAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| NetemLossAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                NetemLossAttrs::Gi(val) => {
                    if last_off == offset {
                        stack.push(("Gi", last_off));
                        break;
                    }
                }
                NetemLossAttrs::Ge(val) => {
                    if last_off == offset {
                        stack.push(("Ge", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("NetemLossAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"pie-attrs\""]
#[derive(Clone)]
pub enum PieAttrs {
    Target(u32),
    Limit(u32),
    Tupdate(u32),
    Alpha(u32),
    Beta(u32),
    Ecn(u32),
    Bytemode(u32),
    DqRateEstimator(u32),
}
impl<'a> Iterable<'a, PieAttrs> {
    pub fn get_target(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let PieAttrs::Target(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("PieAttrs", "Target"))
    }
    pub fn get_limit(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let PieAttrs::Limit(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("PieAttrs", "Limit"))
    }
    pub fn get_tupdate(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let PieAttrs::Tupdate(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("PieAttrs", "Tupdate"))
    }
    pub fn get_alpha(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let PieAttrs::Alpha(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("PieAttrs", "Alpha"))
    }
    pub fn get_beta(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let PieAttrs::Beta(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("PieAttrs", "Beta"))
    }
    pub fn get_ecn(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let PieAttrs::Ecn(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("PieAttrs", "Ecn"))
    }
    pub fn get_bytemode(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let PieAttrs::Bytemode(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("PieAttrs", "Bytemode"))
    }
    pub fn get_dq_rate_estimator(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let PieAttrs::DqRateEstimator(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("PieAttrs", "DqRateEstimator"))
    }
}
impl PieAttrs {
    pub fn new(buf: &'_ [u8]) -> Iterable<'_, PieAttrs> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Target",
            2u16 => "Limit",
            3u16 => "Tupdate",
            4u16 => "Alpha",
            5u16 => "Beta",
            6u16 => "Ecn",
            7u16 => "Bytemode",
            8u16 => "DqRateEstimator",
            _ => return None,
        };
        Some(res)
    }
}
impl Iterator for Iterable<'_, PieAttrs> {
    type Item = Result<PieAttrs, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => PieAttrs::Target({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => PieAttrs::Limit({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => PieAttrs::Tupdate({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => PieAttrs::Alpha({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => PieAttrs::Beta({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => PieAttrs::Ecn({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => PieAttrs::Bytemode({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => PieAttrs::DqRateEstimator({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "PieAttrs",
            r#type.and_then(|t| PieAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl std::fmt::Debug for Iterable<'_, PieAttrs> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("PieAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                PieAttrs::Target(val) => fmt.field("Target", &val),
                PieAttrs::Limit(val) => fmt.field("Limit", &val),
                PieAttrs::Tupdate(val) => fmt.field("Tupdate", &val),
                PieAttrs::Alpha(val) => fmt.field("Alpha", &val),
                PieAttrs::Beta(val) => fmt.field("Beta", &val),
                PieAttrs::Ecn(val) => fmt.field("Ecn", &val),
                PieAttrs::Bytemode(val) => fmt.field("Bytemode", &val),
                PieAttrs::DqRateEstimator(val) => fmt.field("DqRateEstimator", &val),
            };
        }
        fmt.finish()
    }
}
impl Iterable<'_, PieAttrs> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("PieAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| PieAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                PieAttrs::Target(val) => {
                    if last_off == offset {
                        stack.push(("Target", last_off));
                        break;
                    }
                }
                PieAttrs::Limit(val) => {
                    if last_off == offset {
                        stack.push(("Limit", last_off));
                        break;
                    }
                }
                PieAttrs::Tupdate(val) => {
                    if last_off == offset {
                        stack.push(("Tupdate", last_off));
                        break;
                    }
                }
                PieAttrs::Alpha(val) => {
                    if last_off == offset {
                        stack.push(("Alpha", last_off));
                        break;
                    }
                }
                PieAttrs::Beta(val) => {
                    if last_off == offset {
                        stack.push(("Beta", last_off));
                        break;
                    }
                }
                PieAttrs::Ecn(val) => {
                    if last_off == offset {
                        stack.push(("Ecn", last_off));
                        break;
                    }
                }
                PieAttrs::Bytemode(val) => {
                    if last_off == offset {
                        stack.push(("Bytemode", last_off));
                        break;
                    }
                }
                PieAttrs::DqRateEstimator(val) => {
                    if last_off == offset {
                        stack.push(("DqRateEstimator", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("PieAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"police-attrs\""]
#[derive(Clone)]
pub enum PoliceAttrs<'a> {
    Tbf(PushTcPolice),
    Rate(&'a [u8]),
    Peakrate(&'a [u8]),
    Avrate(u32),
    Result(u32),
    Tm(PushTcfT),
    Pad(&'a [u8]),
    Rate64(u64),
    Peakrate64(u64),
    Pktrate64(u64),
    Pktburst64(u64),
}
impl<'a> Iterable<'a, PoliceAttrs<'a>> {
    pub fn get_tbf(&self) -> Result<PushTcPolice, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let PoliceAttrs::Tbf(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("PoliceAttrs", "Tbf"))
    }
    pub fn get_rate(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let PoliceAttrs::Rate(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("PoliceAttrs", "Rate"))
    }
    pub fn get_peakrate(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let PoliceAttrs::Peakrate(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("PoliceAttrs", "Peakrate"))
    }
    pub fn get_avrate(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let PoliceAttrs::Avrate(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("PoliceAttrs", "Avrate"))
    }
    pub fn get_result(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let PoliceAttrs::Result(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("PoliceAttrs", "Result"))
    }
    pub fn get_tm(&self) -> Result<PushTcfT, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let PoliceAttrs::Tm(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("PoliceAttrs", "Tm"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let PoliceAttrs::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("PoliceAttrs", "Pad"))
    }
    pub fn get_rate64(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let PoliceAttrs::Rate64(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("PoliceAttrs", "Rate64"))
    }
    pub fn get_peakrate64(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let PoliceAttrs::Peakrate64(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("PoliceAttrs", "Peakrate64"))
    }
    pub fn get_pktrate64(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let PoliceAttrs::Pktrate64(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("PoliceAttrs", "Pktrate64"))
    }
    pub fn get_pktburst64(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let PoliceAttrs::Pktburst64(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("PoliceAttrs", "Pktburst64"))
    }
}
impl<'a> PoliceAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, PoliceAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Tbf",
            2u16 => "Rate",
            3u16 => "Peakrate",
            4u16 => "Avrate",
            5u16 => "Result",
            6u16 => "Tm",
            7u16 => "Pad",
            8u16 => "Rate64",
            9u16 => "Peakrate64",
            10u16 => "Pktrate64",
            11u16 => "Pktburst64",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, PoliceAttrs<'a>> {
    type Item = Result<PoliceAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => PoliceAttrs::Tbf({
                    let res = PushTcPolice::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => PoliceAttrs::Rate({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => PoliceAttrs::Peakrate({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => PoliceAttrs::Avrate({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => PoliceAttrs::Result({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => PoliceAttrs::Tm({
                    let res = PushTcfT::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => PoliceAttrs::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => PoliceAttrs::Rate64({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => PoliceAttrs::Peakrate64({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => PoliceAttrs::Pktrate64({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => PoliceAttrs::Pktburst64({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "PoliceAttrs",
            r#type.and_then(|t| PoliceAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, PoliceAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("PoliceAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                PoliceAttrs::Tbf(val) => fmt.field("Tbf", &val),
                PoliceAttrs::Rate(val) => fmt.field("Rate", &val),
                PoliceAttrs::Peakrate(val) => fmt.field("Peakrate", &val),
                PoliceAttrs::Avrate(val) => fmt.field("Avrate", &val),
                PoliceAttrs::Result(val) => fmt.field("Result", &val),
                PoliceAttrs::Tm(val) => fmt.field("Tm", &val),
                PoliceAttrs::Pad(val) => fmt.field("Pad", &val),
                PoliceAttrs::Rate64(val) => fmt.field("Rate64", &val),
                PoliceAttrs::Peakrate64(val) => fmt.field("Peakrate64", &val),
                PoliceAttrs::Pktrate64(val) => fmt.field("Pktrate64", &val),
                PoliceAttrs::Pktburst64(val) => fmt.field("Pktburst64", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, PoliceAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("PoliceAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| PoliceAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                PoliceAttrs::Tbf(val) => {
                    if last_off == offset {
                        stack.push(("Tbf", last_off));
                        break;
                    }
                }
                PoliceAttrs::Rate(val) => {
                    if last_off == offset {
                        stack.push(("Rate", last_off));
                        break;
                    }
                }
                PoliceAttrs::Peakrate(val) => {
                    if last_off == offset {
                        stack.push(("Peakrate", last_off));
                        break;
                    }
                }
                PoliceAttrs::Avrate(val) => {
                    if last_off == offset {
                        stack.push(("Avrate", last_off));
                        break;
                    }
                }
                PoliceAttrs::Result(val) => {
                    if last_off == offset {
                        stack.push(("Result", last_off));
                        break;
                    }
                }
                PoliceAttrs::Tm(val) => {
                    if last_off == offset {
                        stack.push(("Tm", last_off));
                        break;
                    }
                }
                PoliceAttrs::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                PoliceAttrs::Rate64(val) => {
                    if last_off == offset {
                        stack.push(("Rate64", last_off));
                        break;
                    }
                }
                PoliceAttrs::Peakrate64(val) => {
                    if last_off == offset {
                        stack.push(("Peakrate64", last_off));
                        break;
                    }
                }
                PoliceAttrs::Pktrate64(val) => {
                    if last_off == offset {
                        stack.push(("Pktrate64", last_off));
                        break;
                    }
                }
                PoliceAttrs::Pktburst64(val) => {
                    if last_off == offset {
                        stack.push(("Pktburst64", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("PoliceAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"qfq-attrs\""]
#[derive(Clone)]
pub enum QfqAttrs {
    Weight(u32),
    Lmax(u32),
}
impl<'a> Iterable<'a, QfqAttrs> {
    pub fn get_weight(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let QfqAttrs::Weight(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("QfqAttrs", "Weight"))
    }
    pub fn get_lmax(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let QfqAttrs::Lmax(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("QfqAttrs", "Lmax"))
    }
}
impl QfqAttrs {
    pub fn new(buf: &'_ [u8]) -> Iterable<'_, QfqAttrs> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Weight",
            2u16 => "Lmax",
            _ => return None,
        };
        Some(res)
    }
}
impl Iterator for Iterable<'_, QfqAttrs> {
    type Item = Result<QfqAttrs, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => QfqAttrs::Weight({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => QfqAttrs::Lmax({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "QfqAttrs",
            r#type.and_then(|t| QfqAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl std::fmt::Debug for Iterable<'_, QfqAttrs> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("QfqAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                QfqAttrs::Weight(val) => fmt.field("Weight", &val),
                QfqAttrs::Lmax(val) => fmt.field("Lmax", &val),
            };
        }
        fmt.finish()
    }
}
impl Iterable<'_, QfqAttrs> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("QfqAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| QfqAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                QfqAttrs::Weight(val) => {
                    if last_off == offset {
                        stack.push(("Weight", last_off));
                        break;
                    }
                }
                QfqAttrs::Lmax(val) => {
                    if last_off == offset {
                        stack.push(("Lmax", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("QfqAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"red-attrs\""]
#[derive(Clone)]
pub enum RedAttrs<'a> {
    Parms(PushTcRedQopt),
    Stab(&'a [u8]),
    MaxP(u32),
    Flags(PushBuiltinBitfield32),
    EarlyDropBlock(u32),
    MarkBlock(u32),
}
impl<'a> Iterable<'a, RedAttrs<'a>> {
    pub fn get_parms(&self) -> Result<PushTcRedQopt, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let RedAttrs::Parms(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("RedAttrs", "Parms"))
    }
    pub fn get_stab(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let RedAttrs::Stab(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("RedAttrs", "Stab"))
    }
    pub fn get_max_p(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let RedAttrs::MaxP(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("RedAttrs", "MaxP"))
    }
    pub fn get_flags(&self) -> Result<PushBuiltinBitfield32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let RedAttrs::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("RedAttrs", "Flags"))
    }
    pub fn get_early_drop_block(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let RedAttrs::EarlyDropBlock(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("RedAttrs", "EarlyDropBlock"))
    }
    pub fn get_mark_block(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let RedAttrs::MarkBlock(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("RedAttrs", "MarkBlock"))
    }
}
impl<'a> RedAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, RedAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Parms",
            2u16 => "Stab",
            3u16 => "MaxP",
            4u16 => "Flags",
            5u16 => "EarlyDropBlock",
            6u16 => "MarkBlock",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, RedAttrs<'a>> {
    type Item = Result<RedAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => RedAttrs::Parms({
                    let res = PushTcRedQopt::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => RedAttrs::Stab({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => RedAttrs::MaxP({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => RedAttrs::Flags({
                    let res = PushBuiltinBitfield32::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => RedAttrs::EarlyDropBlock({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => RedAttrs::MarkBlock({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "RedAttrs",
            r#type.and_then(|t| RedAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, RedAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("RedAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                RedAttrs::Parms(val) => fmt.field("Parms", &val),
                RedAttrs::Stab(val) => fmt.field("Stab", &val),
                RedAttrs::MaxP(val) => fmt.field("MaxP", &val),
                RedAttrs::Flags(val) => fmt.field("Flags", &val),
                RedAttrs::EarlyDropBlock(val) => fmt.field("EarlyDropBlock", &val),
                RedAttrs::MarkBlock(val) => fmt.field("MarkBlock", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, RedAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("RedAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| RedAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                RedAttrs::Parms(val) => {
                    if last_off == offset {
                        stack.push(("Parms", last_off));
                        break;
                    }
                }
                RedAttrs::Stab(val) => {
                    if last_off == offset {
                        stack.push(("Stab", last_off));
                        break;
                    }
                }
                RedAttrs::MaxP(val) => {
                    if last_off == offset {
                        stack.push(("MaxP", last_off));
                        break;
                    }
                }
                RedAttrs::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                RedAttrs::EarlyDropBlock(val) => {
                    if last_off == offset {
                        stack.push(("EarlyDropBlock", last_off));
                        break;
                    }
                }
                RedAttrs::MarkBlock(val) => {
                    if last_off == offset {
                        stack.push(("MarkBlock", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("RedAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"route-attrs\""]
#[derive(Clone)]
pub enum RouteAttrs<'a> {
    Classid(u32),
    To(u32),
    From(u32),
    Iif(u32),
    Police(Iterable<'a, PoliceAttrs<'a>>),
    Act(Iterable<'a, Iterable<'a, ActAttrs<'a>>>),
}
impl<'a> Iterable<'a, RouteAttrs<'a>> {
    pub fn get_classid(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let RouteAttrs::Classid(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("RouteAttrs", "Classid"))
    }
    pub fn get_to(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let RouteAttrs::To(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("RouteAttrs", "To"))
    }
    pub fn get_from(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let RouteAttrs::From(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("RouteAttrs", "From"))
    }
    pub fn get_iif(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let RouteAttrs::Iif(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("RouteAttrs", "Iif"))
    }
    pub fn get_police(&self) -> Result<Iterable<'a, PoliceAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let RouteAttrs::Police(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("RouteAttrs", "Police"))
    }
    pub fn get_act(
        &self,
    ) -> Result<
        ArrayIterable<Iterable<'a, Iterable<'a, ActAttrs<'a>>>, Iterable<'a, ActAttrs<'a>>>,
        ErrorContext,
    > {
        for attr in self.clone() {
            if let RouteAttrs::Act(val) = attr? {
                return Ok(ArrayIterable::new(val));
            }
        }
        Err(self.error_missing("RouteAttrs", "Act"))
    }
}
impl<'a> RouteAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, RouteAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Classid",
            2u16 => "To",
            3u16 => "From",
            4u16 => "Iif",
            5u16 => "Police",
            6u16 => "Act",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, RouteAttrs<'a>> {
    type Item = Result<RouteAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => RouteAttrs::Classid({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => RouteAttrs::To({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => RouteAttrs::From({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => RouteAttrs::Iif({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => RouteAttrs::Police({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => RouteAttrs::Act({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "RouteAttrs",
            r#type.and_then(|t| RouteAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, RouteAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("RouteAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                RouteAttrs::Classid(val) => fmt.field("Classid", &val),
                RouteAttrs::To(val) => fmt.field("To", &val),
                RouteAttrs::From(val) => fmt.field("From", &val),
                RouteAttrs::Iif(val) => fmt.field("Iif", &val),
                RouteAttrs::Police(val) => fmt.field("Police", &val),
                RouteAttrs::Act(val) => fmt.field("Act", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, RouteAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("RouteAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| RouteAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                RouteAttrs::Classid(val) => {
                    if last_off == offset {
                        stack.push(("Classid", last_off));
                        break;
                    }
                }
                RouteAttrs::To(val) => {
                    if last_off == offset {
                        stack.push(("To", last_off));
                        break;
                    }
                }
                RouteAttrs::From(val) => {
                    if last_off == offset {
                        stack.push(("From", last_off));
                        break;
                    }
                }
                RouteAttrs::Iif(val) => {
                    if last_off == offset {
                        stack.push(("Iif", last_off));
                        break;
                    }
                }
                RouteAttrs::Police(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                RouteAttrs::Act(val) => {
                    for entry in val {
                        let Ok(attr) = entry else { break };
                        (stack, missing) = attr.lookup_attr(offset, missing_type);
                        if !stack.is_empty() {
                            break;
                        }
                    }
                    if !stack.is_empty() {
                        stack.push(("Act", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("RouteAttrs", cur));
        }
        (stack, missing)
    }
}
#[doc = "Original name: \"taprio-attrs\""]
#[derive(Clone)]
pub enum TaprioAttrs<'a> {
    Priomap(PushTcMqprioQopt),
    SchedEntryList(Iterable<'a, TaprioSchedEntryList<'a>>),
    SchedBaseTime(i64),
    SchedSingleEntry(Iterable<'a, TaprioSchedEntry>),
    SchedClockid(i32),
    Pad(&'a [u8]),
    AdminSched(&'a [u8]),
    SchedCycleTime(i64),
    SchedCycleTimeExtension(i64),
    Flags(u32),
    TxtimeDelay(u32),
    TcEntry(Iterable<'a, TaprioTcEntryAttrs>),
}
impl<'a> Iterable<'a, TaprioAttrs<'a>> {
    pub fn get_priomap(&self) -> Result<PushTcMqprioQopt, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TaprioAttrs::Priomap(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("TaprioAttrs", "Priomap"))
    }
    pub fn get_sched_entry_list(
        &self,
    ) -> Result<Iterable<'a, TaprioSchedEntryList<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TaprioAttrs::SchedEntryList(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("TaprioAttrs", "SchedEntryList"))
    }
    pub fn get_sched_base_time(&self) -> Result<i64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TaprioAttrs::SchedBaseTime(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("TaprioAttrs", "SchedBaseTime"))
    }
    pub fn get_sched_single_entry(&self) -> Result<Iterable<'a, TaprioSchedEntry>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TaprioAttrs::SchedSingleEntry(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("TaprioAttrs", "SchedSingleEntry"))
    }
    pub fn get_sched_clockid(&self) -> Result<i32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TaprioAttrs::SchedClockid(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("TaprioAttrs", "SchedClockid"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TaprioAttrs::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("TaprioAttrs", "Pad"))
    }
    pub fn get_admin_sched(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TaprioAttrs::AdminSched(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("TaprioAttrs", "AdminSched"))
    }
    pub fn get_sched_cycle_time(&self) -> Result<i64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TaprioAttrs::SchedCycleTime(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("TaprioAttrs", "SchedCycleTime"))
    }
    pub fn get_sched_cycle_time_extension(&self) -> Result<i64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TaprioAttrs::SchedCycleTimeExtension(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("TaprioAttrs", "SchedCycleTimeExtension"))
    }
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TaprioAttrs::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("TaprioAttrs", "Flags"))
    }
    pub fn get_txtime_delay(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TaprioAttrs::TxtimeDelay(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("TaprioAttrs", "TxtimeDelay"))
    }
    pub fn get_tc_entry(&self) -> Result<Iterable<'a, TaprioTcEntryAttrs>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TaprioAttrs::TcEntry(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("TaprioAttrs", "TcEntry"))
    }
}
impl<'a> TaprioAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, TaprioAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Priomap",
            2u16 => "SchedEntryList",
            3u16 => "SchedBaseTime",
            4u16 => "SchedSingleEntry",
            5u16 => "SchedClockid",
            6u16 => "Pad",
            7u16 => "AdminSched",
            8u16 => "SchedCycleTime",
            9u16 => "SchedCycleTimeExtension",
            10u16 => "Flags",
            11u16 => "TxtimeDelay",
            12u16 => "TcEntry",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, TaprioAttrs<'a>> {
    type Item = Result<TaprioAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => TaprioAttrs::Priomap({
                    let res = PushTcMqprioQopt::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => TaprioAttrs::SchedEntryList({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => TaprioAttrs::SchedBaseTime({
                    let res = parse_i64(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => TaprioAttrs::SchedSingleEntry({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => TaprioAttrs::SchedClockid({
                    let res = parse_i32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => TaprioAttrs::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => TaprioAttrs::AdminSched({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => TaprioAttrs::SchedCycleTime({
                    let res = parse_i64(next);
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => TaprioAttrs::SchedCycleTimeExtension({
                    let res = parse_i64(next);
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => TaprioAttrs::Flags({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => TaprioAttrs::TxtimeDelay({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                12u16 => TaprioAttrs::TcEntry({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "TaprioAttrs",
            r#type.and_then(|t| TaprioAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, TaprioAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("TaprioAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                TaprioAttrs::Priomap(val) => fmt.field("Priomap", &val),
                TaprioAttrs::SchedEntryList(val) => fmt.field("SchedEntryList", &val),
                TaprioAttrs::SchedBaseTime(val) => fmt.field("SchedBaseTime", &val),
                TaprioAttrs::SchedSingleEntry(val) => fmt.field("SchedSingleEntry", &val),
                TaprioAttrs::SchedClockid(val) => fmt.field("SchedClockid", &val),
                TaprioAttrs::Pad(val) => fmt.field("Pad", &val),
                TaprioAttrs::AdminSched(val) => fmt.field("AdminSched", &val),
                TaprioAttrs::SchedCycleTime(val) => fmt.field("SchedCycleTime", &val),
                TaprioAttrs::SchedCycleTimeExtension(val) => {
                    fmt.field("SchedCycleTimeExtension", &val)
                }
                TaprioAttrs::Flags(val) => fmt.field("Flags", &val),
                TaprioAttrs::TxtimeDelay(val) => fmt.field("TxtimeDelay", &val),
                TaprioAttrs::TcEntry(val) => fmt.field("TcEntry", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, TaprioAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("TaprioAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| TaprioAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                TaprioAttrs::Priomap(val) => {
                    if last_off == offset {
                        stack.push(("Priomap", last_off));
                        break;
                    }
                }
                TaprioAttrs::SchedEntryList(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                TaprioAttrs::SchedBaseTime(val) => {
                    if last_off == offset {
                        stack.push(("SchedBaseTime", last_off));
                        break;
                    }
                }
                TaprioAttrs::SchedSingleEntry(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                TaprioAttrs::SchedClockid(val) => {
                    if last_off == offset {
                        stack.push(("SchedClockid", last_off));
                        break;
                    }
                }
                TaprioAttrs::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                TaprioAttrs::AdminSched(val) => {
                    if last_off == offset {
                        stack.push(("AdminSched", last_off));
                        break;
                    }
                }
                TaprioAttrs::SchedCycleTime(val) => {
                    if last_off == offset {
                        stack.push(("SchedCycleTime", last_off));
                        break;
                    }
                }
                TaprioAttrs::SchedCycleTimeExtension(val) => {
                    if last_off == offset {
                        stack.push(("SchedCycleTimeExtension", last_off));
                        break;
                    }
                }
                TaprioAttrs::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                TaprioAttrs::TxtimeDelay(val) => {
                    if last_off == offset {
                        stack.push(("TxtimeDelay", last_off));
                        break;
                    }
                }
                TaprioAttrs::TcEntry(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("TaprioAttrs", cur));
        }
        (stack, missing)
    }
}
#[doc = "Original name: \"taprio-sched-entry-list\""]
#[derive(Clone)]
pub enum TaprioSchedEntryList<'a> {
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    Entry(Iterable<'a, TaprioSchedEntry>),
}
impl<'a> Iterable<'a, TaprioSchedEntryList<'a>> {
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn get_entry(
        &self,
    ) -> MultiAttrIterable<Self, TaprioSchedEntryList<'a>, Iterable<'a, TaprioSchedEntry>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let TaprioSchedEntryList::Entry(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
}
impl<'a> TaprioSchedEntryList<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, TaprioSchedEntryList<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Entry",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, TaprioSchedEntryList<'a>> {
    type Item = Result<TaprioSchedEntryList<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => TaprioSchedEntryList::Entry({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "TaprioSchedEntryList",
            r#type.and_then(|t| TaprioSchedEntryList::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, TaprioSchedEntryList<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("TaprioSchedEntryList");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                TaprioSchedEntryList::Entry(val) => fmt.field("Entry", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, TaprioSchedEntryList<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("TaprioSchedEntryList", offset));
            return (
                stack,
                missing_type.and_then(|t| TaprioSchedEntryList::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                TaprioSchedEntryList::Entry(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("TaprioSchedEntryList", cur));
        }
        (stack, missing)
    }
}
#[doc = "Original name: \"taprio-sched-entry\""]
#[derive(Clone)]
pub enum TaprioSchedEntry {
    Index(u32),
    Cmd(u8),
    GateMask(u32),
    Interval(u32),
}
impl<'a> Iterable<'a, TaprioSchedEntry> {
    pub fn get_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TaprioSchedEntry::Index(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("TaprioSchedEntry", "Index"))
    }
    pub fn get_cmd(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TaprioSchedEntry::Cmd(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("TaprioSchedEntry", "Cmd"))
    }
    pub fn get_gate_mask(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TaprioSchedEntry::GateMask(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("TaprioSchedEntry", "GateMask"))
    }
    pub fn get_interval(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TaprioSchedEntry::Interval(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("TaprioSchedEntry", "Interval"))
    }
}
impl TaprioSchedEntry {
    pub fn new(buf: &'_ [u8]) -> Iterable<'_, TaprioSchedEntry> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Index",
            2u16 => "Cmd",
            3u16 => "GateMask",
            4u16 => "Interval",
            _ => return None,
        };
        Some(res)
    }
}
impl Iterator for Iterable<'_, TaprioSchedEntry> {
    type Item = Result<TaprioSchedEntry, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => TaprioSchedEntry::Index({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => TaprioSchedEntry::Cmd({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => TaprioSchedEntry::GateMask({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => TaprioSchedEntry::Interval({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "TaprioSchedEntry",
            r#type.and_then(|t| TaprioSchedEntry::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl std::fmt::Debug for Iterable<'_, TaprioSchedEntry> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("TaprioSchedEntry");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                TaprioSchedEntry::Index(val) => fmt.field("Index", &val),
                TaprioSchedEntry::Cmd(val) => fmt.field("Cmd", &val),
                TaprioSchedEntry::GateMask(val) => fmt.field("GateMask", &val),
                TaprioSchedEntry::Interval(val) => fmt.field("Interval", &val),
            };
        }
        fmt.finish()
    }
}
impl Iterable<'_, TaprioSchedEntry> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("TaprioSchedEntry", offset));
            return (
                stack,
                missing_type.and_then(|t| TaprioSchedEntry::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                TaprioSchedEntry::Index(val) => {
                    if last_off == offset {
                        stack.push(("Index", last_off));
                        break;
                    }
                }
                TaprioSchedEntry::Cmd(val) => {
                    if last_off == offset {
                        stack.push(("Cmd", last_off));
                        break;
                    }
                }
                TaprioSchedEntry::GateMask(val) => {
                    if last_off == offset {
                        stack.push(("GateMask", last_off));
                        break;
                    }
                }
                TaprioSchedEntry::Interval(val) => {
                    if last_off == offset {
                        stack.push(("Interval", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("TaprioSchedEntry", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"taprio-tc-entry-attrs\""]
#[derive(Clone)]
pub enum TaprioTcEntryAttrs {
    Index(u32),
    MaxSdu(u32),
    Fp(u32),
}
impl<'a> Iterable<'a, TaprioTcEntryAttrs> {
    pub fn get_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TaprioTcEntryAttrs::Index(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("TaprioTcEntryAttrs", "Index"))
    }
    pub fn get_max_sdu(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TaprioTcEntryAttrs::MaxSdu(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("TaprioTcEntryAttrs", "MaxSdu"))
    }
    pub fn get_fp(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TaprioTcEntryAttrs::Fp(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("TaprioTcEntryAttrs", "Fp"))
    }
}
impl TaprioTcEntryAttrs {
    pub fn new(buf: &'_ [u8]) -> Iterable<'_, TaprioTcEntryAttrs> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Index",
            2u16 => "MaxSdu",
            3u16 => "Fp",
            _ => return None,
        };
        Some(res)
    }
}
impl Iterator for Iterable<'_, TaprioTcEntryAttrs> {
    type Item = Result<TaprioTcEntryAttrs, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => TaprioTcEntryAttrs::Index({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => TaprioTcEntryAttrs::MaxSdu({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => TaprioTcEntryAttrs::Fp({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "TaprioTcEntryAttrs",
            r#type.and_then(|t| TaprioTcEntryAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl std::fmt::Debug for Iterable<'_, TaprioTcEntryAttrs> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("TaprioTcEntryAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                TaprioTcEntryAttrs::Index(val) => fmt.field("Index", &val),
                TaprioTcEntryAttrs::MaxSdu(val) => fmt.field("MaxSdu", &val),
                TaprioTcEntryAttrs::Fp(val) => fmt.field("Fp", &val),
            };
        }
        fmt.finish()
    }
}
impl Iterable<'_, TaprioTcEntryAttrs> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("TaprioTcEntryAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| TaprioTcEntryAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                TaprioTcEntryAttrs::Index(val) => {
                    if last_off == offset {
                        stack.push(("Index", last_off));
                        break;
                    }
                }
                TaprioTcEntryAttrs::MaxSdu(val) => {
                    if last_off == offset {
                        stack.push(("MaxSdu", last_off));
                        break;
                    }
                }
                TaprioTcEntryAttrs::Fp(val) => {
                    if last_off == offset {
                        stack.push(("Fp", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("TaprioTcEntryAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"tbf-attrs\""]
#[derive(Clone)]
pub enum TbfAttrs<'a> {
    Parms(PushTcTbfQopt),
    Rtab(&'a [u8]),
    Ptab(&'a [u8]),
    Rate64(u64),
    Prate64(u64),
    Burst(u32),
    Pburst(u32),
    Pad(&'a [u8]),
}
impl<'a> Iterable<'a, TbfAttrs<'a>> {
    pub fn get_parms(&self) -> Result<PushTcTbfQopt, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TbfAttrs::Parms(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("TbfAttrs", "Parms"))
    }
    pub fn get_rtab(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TbfAttrs::Rtab(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("TbfAttrs", "Rtab"))
    }
    pub fn get_ptab(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TbfAttrs::Ptab(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("TbfAttrs", "Ptab"))
    }
    pub fn get_rate64(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TbfAttrs::Rate64(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("TbfAttrs", "Rate64"))
    }
    pub fn get_prate64(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TbfAttrs::Prate64(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("TbfAttrs", "Prate64"))
    }
    pub fn get_burst(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TbfAttrs::Burst(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("TbfAttrs", "Burst"))
    }
    pub fn get_pburst(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TbfAttrs::Pburst(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("TbfAttrs", "Pburst"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TbfAttrs::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("TbfAttrs", "Pad"))
    }
}
impl<'a> TbfAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, TbfAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Parms",
            2u16 => "Rtab",
            3u16 => "Ptab",
            4u16 => "Rate64",
            5u16 => "Prate64",
            6u16 => "Burst",
            7u16 => "Pburst",
            8u16 => "Pad",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, TbfAttrs<'a>> {
    type Item = Result<TbfAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => TbfAttrs::Parms({
                    let res = PushTcTbfQopt::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => TbfAttrs::Rtab({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => TbfAttrs::Ptab({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => TbfAttrs::Rate64({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => TbfAttrs::Prate64({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => TbfAttrs::Burst({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => TbfAttrs::Pburst({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => TbfAttrs::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "TbfAttrs",
            r#type.and_then(|t| TbfAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, TbfAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("TbfAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                TbfAttrs::Parms(val) => fmt.field("Parms", &val),
                TbfAttrs::Rtab(val) => fmt.field("Rtab", &val),
                TbfAttrs::Ptab(val) => fmt.field("Ptab", &val),
                TbfAttrs::Rate64(val) => fmt.field("Rate64", &val),
                TbfAttrs::Prate64(val) => fmt.field("Prate64", &val),
                TbfAttrs::Burst(val) => fmt.field("Burst", &val),
                TbfAttrs::Pburst(val) => fmt.field("Pburst", &val),
                TbfAttrs::Pad(val) => fmt.field("Pad", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, TbfAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("TbfAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| TbfAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                TbfAttrs::Parms(val) => {
                    if last_off == offset {
                        stack.push(("Parms", last_off));
                        break;
                    }
                }
                TbfAttrs::Rtab(val) => {
                    if last_off == offset {
                        stack.push(("Rtab", last_off));
                        break;
                    }
                }
                TbfAttrs::Ptab(val) => {
                    if last_off == offset {
                        stack.push(("Ptab", last_off));
                        break;
                    }
                }
                TbfAttrs::Rate64(val) => {
                    if last_off == offset {
                        stack.push(("Rate64", last_off));
                        break;
                    }
                }
                TbfAttrs::Prate64(val) => {
                    if last_off == offset {
                        stack.push(("Prate64", last_off));
                        break;
                    }
                }
                TbfAttrs::Burst(val) => {
                    if last_off == offset {
                        stack.push(("Burst", last_off));
                        break;
                    }
                }
                TbfAttrs::Pburst(val) => {
                    if last_off == offset {
                        stack.push(("Pburst", last_off));
                        break;
                    }
                }
                TbfAttrs::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("TbfAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"act-sample-attrs\""]
#[derive(Clone)]
pub enum ActSampleAttrs<'a> {
    Tm(PushTcfT),
    Parms(PushTcGact),
    Rate(u32),
    TruncSize(u32),
    PsampleGroup(u32),
    Pad(&'a [u8]),
}
impl<'a> Iterable<'a, ActSampleAttrs<'a>> {
    pub fn get_tm(&self) -> Result<PushTcfT, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActSampleAttrs::Tm(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActSampleAttrs", "Tm"))
    }
    pub fn get_parms(&self) -> Result<PushTcGact, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActSampleAttrs::Parms(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActSampleAttrs", "Parms"))
    }
    pub fn get_rate(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActSampleAttrs::Rate(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActSampleAttrs", "Rate"))
    }
    pub fn get_trunc_size(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActSampleAttrs::TruncSize(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActSampleAttrs", "TruncSize"))
    }
    pub fn get_psample_group(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActSampleAttrs::PsampleGroup(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActSampleAttrs", "PsampleGroup"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActSampleAttrs::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActSampleAttrs", "Pad"))
    }
}
impl<'a> ActSampleAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, ActSampleAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Tm",
            2u16 => "Parms",
            3u16 => "Rate",
            4u16 => "TruncSize",
            5u16 => "PsampleGroup",
            6u16 => "Pad",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, ActSampleAttrs<'a>> {
    type Item = Result<ActSampleAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => ActSampleAttrs::Tm({
                    let res = PushTcfT::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => ActSampleAttrs::Parms({
                    let res = PushTcGact::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => ActSampleAttrs::Rate({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => ActSampleAttrs::TruncSize({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => ActSampleAttrs::PsampleGroup({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => ActSampleAttrs::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "ActSampleAttrs",
            r#type.and_then(|t| ActSampleAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, ActSampleAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("ActSampleAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                ActSampleAttrs::Tm(val) => fmt.field("Tm", &val),
                ActSampleAttrs::Parms(val) => fmt.field("Parms", &val),
                ActSampleAttrs::Rate(val) => fmt.field("Rate", &val),
                ActSampleAttrs::TruncSize(val) => fmt.field("TruncSize", &val),
                ActSampleAttrs::PsampleGroup(val) => fmt.field("PsampleGroup", &val),
                ActSampleAttrs::Pad(val) => fmt.field("Pad", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, ActSampleAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("ActSampleAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| ActSampleAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                ActSampleAttrs::Tm(val) => {
                    if last_off == offset {
                        stack.push(("Tm", last_off));
                        break;
                    }
                }
                ActSampleAttrs::Parms(val) => {
                    if last_off == offset {
                        stack.push(("Parms", last_off));
                        break;
                    }
                }
                ActSampleAttrs::Rate(val) => {
                    if last_off == offset {
                        stack.push(("Rate", last_off));
                        break;
                    }
                }
                ActSampleAttrs::TruncSize(val) => {
                    if last_off == offset {
                        stack.push(("TruncSize", last_off));
                        break;
                    }
                }
                ActSampleAttrs::PsampleGroup(val) => {
                    if last_off == offset {
                        stack.push(("PsampleGroup", last_off));
                        break;
                    }
                }
                ActSampleAttrs::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("ActSampleAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"act-gact-attrs\""]
#[derive(Clone)]
pub enum ActGactAttrs<'a> {
    Tm(PushTcfT),
    Parms(PushTcGact),
    Prob(PushTcGactP),
    Pad(&'a [u8]),
}
impl<'a> Iterable<'a, ActGactAttrs<'a>> {
    pub fn get_tm(&self) -> Result<PushTcfT, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActGactAttrs::Tm(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActGactAttrs", "Tm"))
    }
    pub fn get_parms(&self) -> Result<PushTcGact, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActGactAttrs::Parms(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActGactAttrs", "Parms"))
    }
    pub fn get_prob(&self) -> Result<PushTcGactP, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActGactAttrs::Prob(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActGactAttrs", "Prob"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ActGactAttrs::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("ActGactAttrs", "Pad"))
    }
}
impl<'a> ActGactAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, ActGactAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Tm",
            2u16 => "Parms",
            3u16 => "Prob",
            4u16 => "Pad",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, ActGactAttrs<'a>> {
    type Item = Result<ActGactAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => ActGactAttrs::Tm({
                    let res = PushTcfT::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => ActGactAttrs::Parms({
                    let res = PushTcGact::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => ActGactAttrs::Prob({
                    let res = PushTcGactP::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => ActGactAttrs::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "ActGactAttrs",
            r#type.and_then(|t| ActGactAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, ActGactAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("ActGactAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                ActGactAttrs::Tm(val) => fmt.field("Tm", &val),
                ActGactAttrs::Parms(val) => fmt.field("Parms", &val),
                ActGactAttrs::Prob(val) => fmt.field("Prob", &val),
                ActGactAttrs::Pad(val) => fmt.field("Pad", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, ActGactAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("ActGactAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| ActGactAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                ActGactAttrs::Tm(val) => {
                    if last_off == offset {
                        stack.push(("Tm", last_off));
                        break;
                    }
                }
                ActGactAttrs::Parms(val) => {
                    if last_off == offset {
                        stack.push(("Parms", last_off));
                        break;
                    }
                }
                ActGactAttrs::Prob(val) => {
                    if last_off == offset {
                        stack.push(("Prob", last_off));
                        break;
                    }
                }
                ActGactAttrs::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("ActGactAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"tca-stab-attrs\""]
#[derive(Clone)]
pub enum TcaStabAttrs<'a> {
    Base(PushTcSizespec),
    Data(&'a [u8]),
}
impl<'a> Iterable<'a, TcaStabAttrs<'a>> {
    pub fn get_base(&self) -> Result<PushTcSizespec, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TcaStabAttrs::Base(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("TcaStabAttrs", "Base"))
    }
    pub fn get_data(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TcaStabAttrs::Data(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("TcaStabAttrs", "Data"))
    }
}
impl<'a> TcaStabAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, TcaStabAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Base",
            2u16 => "Data",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, TcaStabAttrs<'a>> {
    type Item = Result<TcaStabAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => TcaStabAttrs::Base({
                    let res = PushTcSizespec::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => TcaStabAttrs::Data({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "TcaStabAttrs",
            r#type.and_then(|t| TcaStabAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, TcaStabAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("TcaStabAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                TcaStabAttrs::Base(val) => fmt.field("Base", &val),
                TcaStabAttrs::Data(val) => fmt.field("Data", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, TcaStabAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("TcaStabAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| TcaStabAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                TcaStabAttrs::Base(val) => {
                    if last_off == offset {
                        stack.push(("Base", last_off));
                        break;
                    }
                }
                TcaStabAttrs::Data(val) => {
                    if last_off == offset {
                        stack.push(("Data", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("TcaStabAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"tca-stats-attrs\""]
#[derive(Clone)]
pub enum TcaStatsAttrs<'a> {
    Basic(PushGnetStatsBasic),
    RateEst(PushGnetStatsRateEst),
    Queue(PushGnetStatsQueue),
    App(TcaStatsAppMsg<'a>),
    RateEst64(PushGnetStatsRateEst64),
    Pad(&'a [u8]),
    BasicHw(PushGnetStatsBasic),
    Pkt64(u64),
}
impl<'a> Iterable<'a, TcaStatsAttrs<'a>> {
    pub fn get_basic(&self) -> Result<PushGnetStatsBasic, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TcaStatsAttrs::Basic(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("TcaStatsAttrs", "Basic"))
    }
    pub fn get_rate_est(&self) -> Result<PushGnetStatsRateEst, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TcaStatsAttrs::RateEst(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("TcaStatsAttrs", "RateEst"))
    }
    pub fn get_queue(&self) -> Result<PushGnetStatsQueue, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TcaStatsAttrs::Queue(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("TcaStatsAttrs", "Queue"))
    }
    pub fn get_app(&self) -> Result<TcaStatsAppMsg<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TcaStatsAttrs::App(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("TcaStatsAttrs", "App"))
    }
    pub fn get_rate_est64(&self) -> Result<PushGnetStatsRateEst64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TcaStatsAttrs::RateEst64(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("TcaStatsAttrs", "RateEst64"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TcaStatsAttrs::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("TcaStatsAttrs", "Pad"))
    }
    pub fn get_basic_hw(&self) -> Result<PushGnetStatsBasic, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TcaStatsAttrs::BasicHw(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("TcaStatsAttrs", "BasicHw"))
    }
    pub fn get_pkt64(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TcaStatsAttrs::Pkt64(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("TcaStatsAttrs", "Pkt64"))
    }
}
impl<'a> TcaStatsAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, TcaStatsAttrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Basic",
            2u16 => "RateEst",
            3u16 => "Queue",
            4u16 => "App",
            5u16 => "RateEst64",
            6u16 => "Pad",
            7u16 => "BasicHw",
            8u16 => "Pkt64",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, TcaStatsAttrs<'a>> {
    type Item = Result<TcaStatsAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => TcaStatsAttrs::Basic({
                    let res = PushGnetStatsBasic::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => TcaStatsAttrs::RateEst({
                    let res = PushGnetStatsRateEst::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => TcaStatsAttrs::Queue({
                    let res = PushGnetStatsQueue::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => TcaStatsAttrs::RateEst64({
                    let res = PushGnetStatsRateEst64::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => TcaStatsAttrs::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => TcaStatsAttrs::BasicHw({
                    let res = PushGnetStatsBasic::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => TcaStatsAttrs::Pkt64({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "TcaStatsAttrs",
            r#type.and_then(|t| TcaStatsAttrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, TcaStatsAttrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("TcaStatsAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                TcaStatsAttrs::Basic(val) => fmt.field("Basic", &val),
                TcaStatsAttrs::RateEst(val) => fmt.field("RateEst", &val),
                TcaStatsAttrs::Queue(val) => fmt.field("Queue", &val),
                TcaStatsAttrs::App(val) => fmt.field("App", &val),
                TcaStatsAttrs::RateEst64(val) => fmt.field("RateEst64", &val),
                TcaStatsAttrs::Pad(val) => fmt.field("Pad", &val),
                TcaStatsAttrs::BasicHw(val) => fmt.field("BasicHw", &val),
                TcaStatsAttrs::Pkt64(val) => fmt.field("Pkt64", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, TcaStatsAttrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("TcaStatsAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| TcaStatsAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                TcaStatsAttrs::Basic(val) => {
                    if last_off == offset {
                        stack.push(("Basic", last_off));
                        break;
                    }
                }
                TcaStatsAttrs::RateEst(val) => {
                    if last_off == offset {
                        stack.push(("RateEst", last_off));
                        break;
                    }
                }
                TcaStatsAttrs::Queue(val) => {
                    if last_off == offset {
                        stack.push(("Queue", last_off));
                        break;
                    }
                }
                TcaStatsAttrs::App(val) => {
                    if last_off == offset {
                        stack.push(("App", last_off));
                        break;
                    }
                }
                TcaStatsAttrs::RateEst64(val) => {
                    if last_off == offset {
                        stack.push(("RateEst64", last_off));
                        break;
                    }
                }
                TcaStatsAttrs::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                TcaStatsAttrs::BasicHw(val) => {
                    if last_off == offset {
                        stack.push(("BasicHw", last_off));
                        break;
                    }
                }
                TcaStatsAttrs::Pkt64(val) => {
                    if last_off == offset {
                        stack.push(("Pkt64", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("TcaStatsAttrs", cur));
        }
        (stack, None)
    }
}
#[doc = "Original name: \"u32-attrs\""]
#[derive(Clone)]
pub enum U32Attrs<'a> {
    Classid(u32),
    Hash(u32),
    Link(u32),
    Divisor(u32),
    Sel(PushTcU32Sel),
    Police(Iterable<'a, PoliceAttrs<'a>>),
    Act(Iterable<'a, Iterable<'a, ActAttrs<'a>>>),
    Indev(&'a CStr),
    Pcnt(PushTcU32Pcnt),
    Mark(PushTcU32Mark),
    Flags(u32),
    Pad(&'a [u8]),
}
impl<'a> Iterable<'a, U32Attrs<'a>> {
    pub fn get_classid(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let U32Attrs::Classid(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("U32Attrs", "Classid"))
    }
    pub fn get_hash(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let U32Attrs::Hash(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("U32Attrs", "Hash"))
    }
    pub fn get_link(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let U32Attrs::Link(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("U32Attrs", "Link"))
    }
    pub fn get_divisor(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let U32Attrs::Divisor(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("U32Attrs", "Divisor"))
    }
    pub fn get_sel(&self) -> Result<PushTcU32Sel, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let U32Attrs::Sel(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("U32Attrs", "Sel"))
    }
    pub fn get_police(&self) -> Result<Iterable<'a, PoliceAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let U32Attrs::Police(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("U32Attrs", "Police"))
    }
    pub fn get_act(
        &self,
    ) -> Result<
        ArrayIterable<Iterable<'a, Iterable<'a, ActAttrs<'a>>>, Iterable<'a, ActAttrs<'a>>>,
        ErrorContext,
    > {
        for attr in self.clone() {
            if let U32Attrs::Act(val) = attr? {
                return Ok(ArrayIterable::new(val));
            }
        }
        Err(self.error_missing("U32Attrs", "Act"))
    }
    pub fn get_indev(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let U32Attrs::Indev(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("U32Attrs", "Indev"))
    }
    pub fn get_pcnt(&self) -> Result<PushTcU32Pcnt, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let U32Attrs::Pcnt(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("U32Attrs", "Pcnt"))
    }
    pub fn get_mark(&self) -> Result<PushTcU32Mark, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let U32Attrs::Mark(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("U32Attrs", "Mark"))
    }
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let U32Attrs::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("U32Attrs", "Flags"))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let U32Attrs::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("U32Attrs", "Pad"))
    }
}
impl<'a> U32Attrs<'a> {
    pub fn new(buf: &'a [u8]) -> Iterable<'a, U32Attrs<'a>> {
        Iterable::new(buf)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Classid",
            2u16 => "Hash",
            3u16 => "Link",
            4u16 => "Divisor",
            5u16 => "Sel",
            6u16 => "Police",
            7u16 => "Act",
            8u16 => "Indev",
            9u16 => "Pcnt",
            10u16 => "Mark",
            11u16 => "Flags",
            12u16 => "Pad",
            _ => return None,
        };
        Some(res)
    }
}
impl<'a> Iterator for Iterable<'a, U32Attrs<'a>> {
    type Item = Result<U32Attrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => U32Attrs::Classid({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => U32Attrs::Hash({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => U32Attrs::Link({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => U32Attrs::Divisor({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => U32Attrs::Sel({
                    let res = PushTcU32Sel::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => U32Attrs::Police({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => U32Attrs::Act({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => U32Attrs::Indev({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => U32Attrs::Pcnt({
                    let res = PushTcU32Pcnt::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => U32Attrs::Mark({
                    let res = PushTcU32Mark::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => U32Attrs::Flags({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                12u16 => U32Attrs::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "U32Attrs",
            r#type.and_then(|t| U32Attrs::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, U32Attrs<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("U32Attrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                U32Attrs::Classid(val) => fmt.field("Classid", &val),
                U32Attrs::Hash(val) => fmt.field("Hash", &val),
                U32Attrs::Link(val) => fmt.field("Link", &val),
                U32Attrs::Divisor(val) => fmt.field("Divisor", &val),
                U32Attrs::Sel(val) => fmt.field("Sel", &val),
                U32Attrs::Police(val) => fmt.field("Police", &val),
                U32Attrs::Act(val) => fmt.field("Act", &val),
                U32Attrs::Indev(val) => fmt.field("Indev", &val),
                U32Attrs::Pcnt(val) => fmt.field("Pcnt", &val),
                U32Attrs::Mark(val) => fmt.field("Mark", &val),
                U32Attrs::Flags(val) => fmt.field("Flags", &val),
                U32Attrs::Pad(val) => fmt.field("Pad", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, U32Attrs<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("U32Attrs", offset));
            return (
                stack,
                missing_type.and_then(|t| U32Attrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                U32Attrs::Classid(val) => {
                    if last_off == offset {
                        stack.push(("Classid", last_off));
                        break;
                    }
                }
                U32Attrs::Hash(val) => {
                    if last_off == offset {
                        stack.push(("Hash", last_off));
                        break;
                    }
                }
                U32Attrs::Link(val) => {
                    if last_off == offset {
                        stack.push(("Link", last_off));
                        break;
                    }
                }
                U32Attrs::Divisor(val) => {
                    if last_off == offset {
                        stack.push(("Divisor", last_off));
                        break;
                    }
                }
                U32Attrs::Sel(val) => {
                    if last_off == offset {
                        stack.push(("Sel", last_off));
                        break;
                    }
                }
                U32Attrs::Police(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                U32Attrs::Act(val) => {
                    for entry in val {
                        let Ok(attr) = entry else { break };
                        (stack, missing) = attr.lookup_attr(offset, missing_type);
                        if !stack.is_empty() {
                            break;
                        }
                    }
                    if !stack.is_empty() {
                        stack.push(("Act", last_off));
                        break;
                    }
                }
                U32Attrs::Indev(val) => {
                    if last_off == offset {
                        stack.push(("Indev", last_off));
                        break;
                    }
                }
                U32Attrs::Pcnt(val) => {
                    if last_off == offset {
                        stack.push(("Pcnt", last_off));
                        break;
                    }
                }
                U32Attrs::Mark(val) => {
                    if last_off == offset {
                        stack.push(("Mark", last_off));
                        break;
                    }
                }
                U32Attrs::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                U32Attrs::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("U32Attrs", cur));
        }
        (stack, missing)
    }
}
pub struct PushAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_kind(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_kind_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_basic(mut self) -> PushBasicAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"basic");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushBasicAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_bpf(mut self) -> PushBpfAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"bpf");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushBpfAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_bfifo(mut self, fixed_header: &PushTcFifoQopt) -> Self {
        self = self.push_kind(c"bfifo");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_cake(mut self) -> PushCakeAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"cake");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushCakeAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_cbs(mut self) -> PushCbsAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"cbs");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushCbsAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_cgroup(mut self) -> PushCgroupAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"cgroup");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushCgroupAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_choke(mut self) -> PushChokeAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"choke");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushChokeAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_clsact(mut self) -> Self {
        self = self.push_kind(c"clsact");
        push_nested_header(self.as_rec_mut(), 2u16);
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_codel(mut self) -> PushCodelAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"codel");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushCodelAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_drr(mut self) -> PushDrrAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"drr");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushDrrAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_dualpi2(mut self) -> PushDualpi2Attrs<PushDummy<Prev>> {
        self = self.push_kind(c"dualpi2");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushDualpi2Attrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_etf(mut self) -> PushEtfAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"etf");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushEtfAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_ets(mut self) -> PushEtsAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"ets");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushEtsAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_flow(mut self) -> PushFlowAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"flow");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFlowAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_flower(mut self) -> PushFlowerAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"flower");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFlowerAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_fq(mut self) -> PushFqAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"fq");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFqAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_fq_codel(mut self) -> PushFqCodelAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"fq_codel");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFqCodelAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_fq_pie(mut self) -> PushFqPieAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"fq_pie");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFqPieAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_fw(mut self) -> PushFwAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"fw");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFwAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_gred(mut self) -> PushGredAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"gred");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushGredAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_hfsc(mut self, fixed_header: &PushTcHfscQopt) -> Self {
        self = self.push_kind(c"hfsc");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_hhf(mut self) -> PushHhfAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"hhf");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushHhfAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_htb(mut self) -> PushHtbAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"htb");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushHtbAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_ingress(mut self) -> Self {
        self = self.push_kind(c"ingress");
        push_nested_header(self.as_rec_mut(), 2u16);
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_matchall(mut self) -> PushMatchallAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"matchall");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushMatchallAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_mq(mut self) -> Self {
        self = self.push_kind(c"mq");
        push_nested_header(self.as_rec_mut(), 2u16);
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_mqprio(mut self, fixed_header: &PushTcMqprioQopt) -> Self {
        self = self.push_kind(c"mqprio");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_multiq(mut self, fixed_header: &PushTcMultiqQopt) -> Self {
        self = self.push_kind(c"multiq");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_netem(
        mut self,
        fixed_header: &PushTcNetemQopt,
    ) -> PushNetemAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"netem");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        let Self {
            prev,
            header_offset,
        } = self;
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushNetemAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_pfifo(mut self, fixed_header: &PushTcFifoQopt) -> Self {
        self = self.push_kind(c"pfifo");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_pfifo_fast(mut self, fixed_header: &PushTcPrioQopt) -> Self {
        self = self.push_kind(c"pfifo_fast");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_pfifo_head_drop(mut self, fixed_header: &PushTcFifoQopt) -> Self {
        self = self.push_kind(c"pfifo_head_drop");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_pie(mut self) -> PushPieAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"pie");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushPieAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_plug(mut self, fixed_header: &PushTcPlugQopt) -> Self {
        self = self.push_kind(c"plug");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_prio(mut self, fixed_header: &PushTcPrioQopt) -> Self {
        self = self.push_kind(c"prio");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_qfq(mut self) -> PushQfqAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"qfq");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushQfqAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_red(mut self) -> PushRedAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"red");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushRedAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_route(mut self) -> PushRouteAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"route");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushRouteAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_sfb(mut self, fixed_header: &PushTcSfbQopt) -> Self {
        self = self.push_kind(c"sfb");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_sfq(mut self, fixed_header: &PushTcSfqQoptV1) -> Self {
        self = self.push_kind(c"sfq");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_taprio(mut self) -> PushTaprioAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"taprio");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushTaprioAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_tbf(mut self) -> PushTbfAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"tbf");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushTbfAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_u32(mut self) -> PushU32Attrs<PushDummy<Prev>> {
        self = self.push_kind(c"u32");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushU32Attrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    pub fn push_stats(mut self, value: PushTcStats) -> Self {
        push_header(self.as_rec_mut(), 3u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_cake(mut self) -> PushCakeStatsAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"cake");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushCakeStatsAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_choke(mut self, fixed_header: &PushTcChokeXstats) -> Self {
        self = self.push_kind(c"choke");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_codel(mut self, fixed_header: &PushTcCodelXstats) -> Self {
        self = self.push_kind(c"codel");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_dualpi2(mut self, fixed_header: &PushTcDualpi2Xstats) -> Self {
        self = self.push_kind(c"dualpi2");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_fq(mut self, fixed_header: &PushTcFqQdStats) -> Self {
        self = self.push_kind(c"fq");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_fq_codel(mut self, fixed_header: &PushTcFqCodelXstats) -> Self {
        self = self.push_kind(c"fq_codel");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_fq_pie(mut self, fixed_header: &PushTcFqPieXstats) -> Self {
        self = self.push_kind(c"fq_pie");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_hhf(mut self, fixed_header: &PushTcHhfXstats) -> Self {
        self = self.push_kind(c"hhf");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_pie(mut self, fixed_header: &PushTcPieXstats) -> Self {
        self = self.push_kind(c"pie");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_red(mut self, fixed_header: &PushTcRedXstats) -> Self {
        self = self.push_kind(c"red");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_sfb(mut self, fixed_header: &PushTcSfbXstats) -> Self {
        self = self.push_kind(c"sfb");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_sfq(mut self, fixed_header: &PushTcSfqXstats) -> Self {
        self = self.push_kind(c"sfq");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    pub fn push_rate(mut self, value: PushGnetEstimator) -> Self {
        push_header(self.as_rec_mut(), 5u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_fcnt(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn nested_stats2(mut self) -> PushTcaStatsAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 7u16);
        PushTcaStatsAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn nested_stab(mut self) -> PushTcaStabAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 8u16);
        PushTcaStabAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 9u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_dump_invisible(mut self, value: ()) -> Self {
        push_header(self.as_rec_mut(), 10u16, 0 as u16);
        self
    }
    pub fn push_chain(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 11u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_hw_offload(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 12u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_ingress_block(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 13u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_egress_block(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 14u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_dump_flags(mut self, value: PushBuiltinBitfield32) -> Self {
        push_header(self.as_rec_mut(), 15u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_ext_warn_msg(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            16u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_ext_warn_msg_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 16u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushActAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushActAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushActAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_kind(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_kind_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_bpf(mut self) -> PushActBpfAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"bpf");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushActBpfAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_connmark(mut self) -> PushActConnmarkAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"connmark");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushActConnmarkAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_csum(mut self) -> PushActCsumAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"csum");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushActCsumAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_ct(mut self) -> PushActCtAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"ct");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushActCtAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_ctinfo(mut self) -> PushActCtinfoAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"ctinfo");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushActCtinfoAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_gact(mut self) -> PushActGactAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"gact");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushActGactAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_gate(mut self) -> PushActGateAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"gate");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushActGateAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_ife(mut self) -> PushActIfeAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"ife");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushActIfeAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_mirred(mut self) -> PushActMirredAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"mirred");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushActMirredAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_mpls(mut self) -> PushActMplsAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"mpls");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushActMplsAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_nat(mut self) -> PushActNatAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"nat");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushActNatAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_pedit(mut self) -> PushActPeditAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"pedit");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushActPeditAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_police(mut self) -> PushPoliceAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"police");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushPoliceAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_sample(mut self) -> PushActSampleAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"sample");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushActSampleAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_simple(mut self) -> PushActSimpleAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"simple");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushActSimpleAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_skbedit(mut self) -> PushActSkbeditAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"skbedit");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushActSkbeditAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_skbmod(mut self) -> PushActSkbmodAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"skbmod");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushActSkbmodAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_tunnel_key(mut self) -> PushActTunnelKeyAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"tunnel_key");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushActTunnelKeyAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_vlan(mut self) -> PushActVlanAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"vlan");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushActVlanAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    pub fn push_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn nested_stats(mut self) -> PushTcaStatsAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushTcaStatsAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 5u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_cookie(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 6u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_flags(mut self, value: PushBuiltinBitfield32) -> Self {
        push_header(self.as_rec_mut(), 7u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_hw_stats(mut self, value: PushBuiltinBitfield32) -> Self {
        push_header(self.as_rec_mut(), 8u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_used_hw_stats(mut self, value: PushBuiltinBitfield32) -> Self {
        push_header(self.as_rec_mut(), 9u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_in_hw_count(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 10u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushActAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushActBpfAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushActBpfAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushActBpfAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_tm(mut self, value: PushTcfT) -> Self {
        push_header(self.as_rec_mut(), 1u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_parms(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_ops_len(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 3u16, 2 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_ops(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 4u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_fd(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            6u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 6u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 7u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_tag(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 8u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_id(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 9u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushActBpfAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushActConnmarkAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushActConnmarkAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushActConnmarkAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_parms(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_tm(mut self, value: PushTcfT) -> Self {
        push_header(self.as_rec_mut(), 2u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 3u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushActConnmarkAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushActCsumAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushActCsumAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushActCsumAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_parms(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_tm(mut self, value: PushTcfT) -> Self {
        push_header(self.as_rec_mut(), 2u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 3u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushActCsumAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushActCtAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushActCtAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushActCtAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_parms(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_tm(mut self, value: PushTcfT) -> Self {
        push_header(self.as_rec_mut(), 2u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_action(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 3u16, 2 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_zone(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 4u16, 2 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_mark(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_mark_mask(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_labels(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 7u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_labels_mask(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 8u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_nat_ipv4_min(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 9u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_nat_ipv4_max(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 10u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_nat_ipv6_min(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 11u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_nat_ipv6_max(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 12u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_nat_port_min(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 13u16, 2 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_nat_port_max(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 14u16, 2 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 15u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_helper_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            16u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_helper_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 16u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_helper_family(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 17u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_helper_proto(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 18u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushActCtAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushActCtinfoAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushActCtinfoAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushActCtinfoAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_tm(mut self, value: PushTcfT) -> Self {
        push_header(self.as_rec_mut(), 2u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_act(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 3u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_zone(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 4u16, 2 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_parms_dscp_mask(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_parms_dscp_statemask(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_parms_cpmark_mask(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 7u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_stats_dscp_set(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 8u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_stats_dscp_error(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 9u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_stats_cpmark_set(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 10u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushActCtinfoAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushActGateAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushActGateAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushActGateAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_tm(mut self, value: PushTcfT) -> Self {
        push_header(self.as_rec_mut(), 1u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_parms(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 3u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_priority(mut self, value: i32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_entry_list(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 5u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_base_time(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 6u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_cycle_time(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 7u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_cycle_time_ext(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 8u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 9u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_clockid(mut self, value: i32) -> Self {
        push_header(self.as_rec_mut(), 10u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushActGateAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushActIfeAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushActIfeAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushActIfeAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_parms(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_tm(mut self, value: PushTcfT) -> Self {
        push_header(self.as_rec_mut(), 2u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_dmac(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 3u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_smac(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 4u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_type(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 5u16, 2 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_metalst(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 6u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 7u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushActIfeAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushActMirredAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushActMirredAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushActMirredAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_tm(mut self, value: PushTcfT) -> Self {
        push_header(self.as_rec_mut(), 1u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_parms(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 3u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_blockid(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 4u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushActMirredAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushActMplsAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushActMplsAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushActMplsAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_tm(mut self, value: PushTcfT) -> Self {
        push_header(self.as_rec_mut(), 1u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_parms(mut self, value: PushTcMpls) -> Self {
        push_header(self.as_rec_mut(), 2u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 3u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_proto(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 4u16, 2 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_label(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_tc(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 6u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_ttl(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 7u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_bos(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 8u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushActMplsAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushActNatAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushActNatAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushActNatAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_parms(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_tm(mut self, value: PushTcfT) -> Self {
        push_header(self.as_rec_mut(), 2u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 3u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushActNatAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushActPeditAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushActPeditAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushActPeditAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_tm(mut self, value: PushTcfT) -> Self {
        push_header(self.as_rec_mut(), 1u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_parms(mut self, value: PushTcPeditSel) -> Self {
        push_header(self.as_rec_mut(), 2u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 3u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_parms_ex(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 4u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_keys_ex(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 5u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_key_ex(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 6u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushActPeditAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushActSimpleAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushActSimpleAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushActSimpleAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_tm(mut self, value: PushTcfT) -> Self {
        push_header(self.as_rec_mut(), 1u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_parms(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_data(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 3u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 4u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushActSimpleAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushActSkbeditAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushActSkbeditAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushActSkbeditAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_tm(mut self, value: PushTcfT) -> Self {
        push_header(self.as_rec_mut(), 1u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_parms(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_priority(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_queue_mapping(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 4u16, 2 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_mark(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 6u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_ptype(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 7u16, 2 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_mask(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 8u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_flags(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 9u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_queue_mapping_max(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 10u16, 2 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushActSkbeditAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushActSkbmodAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushActSkbmodAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushActSkbmodAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_tm(mut self, value: PushTcfT) -> Self {
        push_header(self.as_rec_mut(), 1u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_parms(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_dmac(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 3u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_smac(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 4u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_etype(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 5u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 6u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushActSkbmodAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushActTunnelKeyAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushActTunnelKeyAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushActTunnelKeyAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_tm(mut self, value: PushTcfT) -> Self {
        push_header(self.as_rec_mut(), 1u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_parms(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_enc_ipv4_src(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_enc_ipv4_dst(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_enc_ipv6_src(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 5u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_enc_ipv6_dst(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 6u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_enc_key_id(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 7u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 8u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_enc_dst_port(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 9u16, 2 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_no_csum(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 10u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_enc_opts(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 11u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_enc_tos(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 12u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_enc_ttl(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 13u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_no_frag(mut self, value: ()) -> Self {
        push_header(self.as_rec_mut(), 14u16, 0 as u16);
        self
    }
}
impl<Prev: Rec> Drop for PushActTunnelKeyAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushActVlanAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushActVlanAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushActVlanAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_tm(mut self, value: PushTcfT) -> Self {
        push_header(self.as_rec_mut(), 1u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_parms(mut self, value: PushTcVlan) -> Self {
        push_header(self.as_rec_mut(), 2u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_push_vlan_id(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 3u16, 2 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_push_vlan_protocol(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 4u16, 2 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 5u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_push_vlan_priority(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 6u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_push_eth_dst(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 7u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_push_eth_src(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 8u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushActVlanAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushBasicAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushBasicAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
pub struct PushArrayActAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
    pub(crate) counter: u16,
}
impl<Prev: Rec> Rec for PushArrayActAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushArrayActAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
            counter: 0,
        }
    }
    pub fn end_array(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn entry_nested(mut self) -> PushActAttrs<Self> {
        let index = self.counter;
        self.counter += 1;
        let header_offset = push_nested_header(self.as_rec_mut(), index);
        PushActAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushArrayActAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
impl<Prev: Rec> PushBasicAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_classid(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn nested_ematches(mut self) -> PushEmatchAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        PushEmatchAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn array_act(mut self) -> PushArrayActAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 3u16);
        PushArrayActAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
            counter: 0,
        }
    }
    pub fn nested_police(mut self) -> PushPoliceAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushPoliceAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_pcnt(mut self, value: PushTcBasicPcnt) -> Self {
        push_header(self.as_rec_mut(), 5u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 6u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushBasicAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushBpfAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushBpfAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushBpfAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn array_act(mut self) -> PushArrayActAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 1u16);
        PushArrayActAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
            counter: 0,
        }
    }
    pub fn nested_police(mut self) -> PushPoliceAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        PushPoliceAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_classid(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_ops_len(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 4u16, 2 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_ops(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 5u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_fd(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            7u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 7u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 8u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_flags_gen(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 9u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_tag(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 10u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 11u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushBpfAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushCakeAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushCakeAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushCakeAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_base_rate64(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 2u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_diffserv_mode(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_atm(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_flow_mode(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_overhead(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_rtt(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 7u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_target(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 8u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_autorate(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 9u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_memory(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 10u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_nat(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 11u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_raw(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 12u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_wash(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 13u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_mpu(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 14u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_ingress(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 15u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_ack_filter(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 16u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_split_gso(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 17u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_fwmark(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 18u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushCakeAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushCakeStatsAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushCakeStatsAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
pub struct PushArrayCakeTinStatsAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
    pub(crate) counter: u16,
}
impl<Prev: Rec> Rec for PushArrayCakeTinStatsAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushArrayCakeTinStatsAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
            counter: 0,
        }
    }
    pub fn end_array(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn entry_nested(mut self) -> PushCakeTinStatsAttrs<Self> {
        let index = self.counter;
        self.counter += 1;
        let header_offset = push_nested_header(self.as_rec_mut(), index);
        PushCakeTinStatsAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushArrayCakeTinStatsAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
impl<Prev: Rec> PushCakeStatsAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_capacity_estimate64(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 2u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_memory_limit(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_memory_used(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_avg_netoff(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_min_netlen(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_max_netlen(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 7u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_min_adjlen(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 8u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_max_adjlen(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 9u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn array_tin_stats(mut self) -> PushArrayCakeTinStatsAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 10u16);
        PushArrayCakeTinStatsAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
            counter: 0,
        }
    }
    pub fn push_deficit(mut self, value: i32) -> Self {
        push_header(self.as_rec_mut(), 11u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_cobalt_count(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 12u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_dropping(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 13u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_drop_next_us(mut self, value: i32) -> Self {
        push_header(self.as_rec_mut(), 14u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_p_drop(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 15u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_blue_timer_us(mut self, value: i32) -> Self {
        push_header(self.as_rec_mut(), 16u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushCakeStatsAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushCakeTinStatsAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushCakeTinStatsAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushCakeTinStatsAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_sent_packets(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_sent_bytes64(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 3u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_dropped_packets(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_dropped_bytes64(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 5u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_acks_dropped_packets(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_acks_dropped_bytes64(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 7u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_ecn_marked_packets(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 8u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_ecn_marked_bytes64(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 9u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_backlog_packets(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 10u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_backlog_bytes(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 11u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_threshold_rate64(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 12u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_target_us(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 13u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_interval_us(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 14u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_way_indirect_hits(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 15u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_way_misses(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 16u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_way_collisions(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 17u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_peak_delay_us(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 18u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_avg_delay_us(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 19u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_base_delay_us(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 20u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_sparse_flows(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 21u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_bulk_flows(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 22u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_unresponsive_flows(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 23u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_max_skblen(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 24u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_flow_quantum(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 25u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushCakeTinStatsAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushCbsAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushCbsAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushCbsAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_parms(mut self, value: PushTcCbsQopt) -> Self {
        push_header(self.as_rec_mut(), 1u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
}
impl<Prev: Rec> Drop for PushCbsAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushCgroupAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushCgroupAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushCgroupAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn array_act(mut self) -> PushArrayActAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 1u16);
        PushArrayActAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
            counter: 0,
        }
    }
    pub fn nested_police(mut self) -> PushPoliceAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        PushPoliceAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_ematches(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 3u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushCgroupAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushChokeAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushChokeAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushChokeAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_parms(mut self, value: PushTcRedQopt) -> Self {
        push_header(self.as_rec_mut(), 1u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_stab(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_max_p(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushChokeAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushCodelAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushCodelAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushCodelAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_target(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_limit(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_interval(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_ecn(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_ce_threshold(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushCodelAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushDrrAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushDrrAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushDrrAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_quantum(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushDrrAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushDualpi2Attrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushDualpi2Attrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushDualpi2Attrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "Limit of total number of packets in queue"]
    pub fn push_limit(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Memory limit of total number of packets in queue"]
    pub fn push_memory_limit(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Classic target delay in microseconds"]
    pub fn push_target(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Drop probability update interval time in microseconds"]
    pub fn push_tupdate(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Integral gain factor in Hz for PI controller"]
    pub fn push_alpha(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Proportional gain factor in Hz for PI controller"]
    pub fn push_beta(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "L4S step marking threshold in packets"]
    pub fn push_step_thresh_pkts(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 7u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "L4S Step marking threshold in microseconds"]
    pub fn push_step_thresh_us(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 8u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Packets enqueued to the L-queue can apply the step threshold when the queue length of L-queue is larger than this value. (0 is recommended)"]
    pub fn push_min_qlen_step(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 9u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Probability coupling factor between Classic and L4S (2 is recommended)"]
    pub fn push_coupling(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 10u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Control the overload strategy (drop to preserve latency or let the queue overflow)\nAssociated type: \"Dualpi2DropOverload\" (enum)"]
    pub fn push_drop_overload(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 11u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Decide where the Classic packets are PI-based dropped or marked\nAssociated type: \"Dualpi2DropEarly\" (enum)"]
    pub fn push_drop_early(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 12u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Classic WRR weight in percentage (from 0 to 100)"]
    pub fn push_c_protection(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 13u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Configure the L-queue ECN classifier\nAssociated type: \"Dualpi2EcnMask\" (enum)"]
    pub fn push_ecn_mask(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 14u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Split aggregated skb or not\nAssociated type: \"Dualpi2SplitGso\" (enum)"]
    pub fn push_split_gso(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 15u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushDualpi2Attrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushEmatchAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushEmatchAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushEmatchAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_tree_hdr(mut self, value: PushTcfEmatchTreeHdr) -> Self {
        push_header(self.as_rec_mut(), 1u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_tree_list(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushEmatchAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushFlowAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushFlowAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushFlowAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_keys(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_mode(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_baseclass(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_rshift(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_addend(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_mask(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_xor(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 7u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_divisor(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 8u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_act(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 9u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn nested_police(mut self) -> PushPoliceAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 10u16);
        PushPoliceAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_ematches(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 11u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_perturb(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 12u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushFlowAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushFlowerAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushFlowerAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushFlowerAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_classid(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_indev(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_indev_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn array_act(mut self) -> PushArrayActAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 3u16);
        PushArrayActAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
            counter: 0,
        }
    }
    pub fn push_key_eth_dst(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 4u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_key_eth_dst_mask(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 5u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_key_eth_src(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 6u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_key_eth_src_mask(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 7u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_key_eth_type(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 8u16, 2 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_key_ip_proto(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 9u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_key_ipv4_src(mut self, value: std::net::Ipv4Addr) -> Self {
        push_header(self.as_rec_mut(), 10u16, 4 as u16);
        self.as_rec_mut().extend(&value.to_bits().to_be_bytes());
        self
    }
    pub fn push_key_ipv4_src_mask(mut self, value: std::net::Ipv4Addr) -> Self {
        push_header(self.as_rec_mut(), 11u16, 4 as u16);
        self.as_rec_mut().extend(&value.to_bits().to_be_bytes());
        self
    }
    pub fn push_key_ipv4_dst(mut self, value: std::net::Ipv4Addr) -> Self {
        push_header(self.as_rec_mut(), 12u16, 4 as u16);
        self.as_rec_mut().extend(&value.to_bits().to_be_bytes());
        self
    }
    pub fn push_key_ipv4_dst_mask(mut self, value: std::net::Ipv4Addr) -> Self {
        push_header(self.as_rec_mut(), 13u16, 4 as u16);
        self.as_rec_mut().extend(&value.to_bits().to_be_bytes());
        self
    }
    pub fn push_key_ipv6_src(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 14u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_key_ipv6_src_mask(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 15u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_key_ipv6_dst(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 16u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_key_ipv6_dst_mask(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 17u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_key_tcp_src(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 18u16, 2 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_key_tcp_dst(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 19u16, 2 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_key_udp_src(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 20u16, 2 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_key_udp_dst(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 21u16, 2 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "Associated type: \"ClsFlags\" (1 bit per enumeration)"]
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 22u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_key_vlan_id(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 23u16, 2 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_key_vlan_prio(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 24u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_key_vlan_eth_type(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 25u16, 2 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_key_enc_key_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 26u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_key_enc_ipv4_src(mut self, value: std::net::Ipv4Addr) -> Self {
        push_header(self.as_rec_mut(), 27u16, 4 as u16);
        self.as_rec_mut().extend(&value.to_bits().to_be_bytes());
        self
    }
    pub fn push_key_enc_ipv4_src_mask(mut self, value: std::net::Ipv4Addr) -> Self {
        push_header(self.as_rec_mut(), 28u16, 4 as u16);
        self.as_rec_mut().extend(&value.to_bits().to_be_bytes());
        self
    }
    pub fn push_key_enc_ipv4_dst(mut self, value: std::net::Ipv4Addr) -> Self {
        push_header(self.as_rec_mut(), 29u16, 4 as u16);
        self.as_rec_mut().extend(&value.to_bits().to_be_bytes());
        self
    }
    pub fn push_key_enc_ipv4_dst_mask(mut self, value: std::net::Ipv4Addr) -> Self {
        push_header(self.as_rec_mut(), 30u16, 4 as u16);
        self.as_rec_mut().extend(&value.to_bits().to_be_bytes());
        self
    }
    pub fn push_key_enc_ipv6_src(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 31u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_key_enc_ipv6_src_mask(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 32u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_key_enc_ipv6_dst(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 33u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_key_enc_ipv6_dst_mask(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 34u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_key_tcp_src_mask(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 35u16, 2 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_key_tcp_dst_mask(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 36u16, 2 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_key_udp_src_mask(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 37u16, 2 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_key_udp_dst_mask(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 38u16, 2 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_key_sctp_src_mask(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 39u16, 2 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_key_sctp_dst_mask(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 40u16, 2 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_key_sctp_src(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 41u16, 2 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_key_sctp_dst(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 42u16, 2 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_key_enc_udp_src_port(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 43u16, 2 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_key_enc_udp_src_port_mask(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 44u16, 2 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_key_enc_udp_dst_port(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 45u16, 2 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_key_enc_udp_dst_port_mask(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 46u16, 2 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "Associated type: \"FlowerKeyCtrlFlags\" (1 bit per enumeration)"]
    pub fn push_key_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 47u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "Associated type: \"FlowerKeyCtrlFlags\" (1 bit per enumeration)"]
    pub fn push_key_flags_mask(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 48u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_key_icmpv4_code(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 49u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_key_icmpv4_code_mask(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 50u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_key_icmpv4_type(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 51u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_key_icmpv4_type_mask(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 52u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_key_icmpv6_code(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 53u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_key_icmpv6_code_mask(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 54u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_key_icmpv6_type(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 55u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_key_icmpv6_type_mask(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 56u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_key_arp_sip(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 57u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_key_arp_sip_mask(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 58u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_key_arp_tip(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 59u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_key_arp_tip_mask(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 60u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_key_arp_op(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 61u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_key_arp_op_mask(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 62u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_key_arp_sha(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 63u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_key_arp_sha_mask(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 64u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_key_arp_tha(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 65u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_key_arp_tha_mask(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 66u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_key_mpls_ttl(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 67u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_key_mpls_bos(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 68u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_key_mpls_tc(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 69u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_key_mpls_label(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 70u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_key_tcp_flags(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 71u16, 2 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_key_tcp_flags_mask(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 72u16, 2 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_key_ip_tos(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 73u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_key_ip_tos_mask(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 74u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_key_ip_ttl(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 75u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_key_ip_ttl_mask(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 76u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_key_cvlan_id(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 77u16, 2 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_key_cvlan_prio(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 78u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_key_cvlan_eth_type(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 79u16, 2 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_key_enc_ip_tos(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 80u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_key_enc_ip_tos_mask(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 81u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_key_enc_ip_ttl(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 82u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_key_enc_ip_ttl_mask(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 83u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn nested_key_enc_opts(mut self) -> PushFlowerKeyEncOptsAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 84u16);
        PushFlowerKeyEncOptsAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn nested_key_enc_opts_mask(mut self) -> PushFlowerKeyEncOptsAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 85u16);
        PushFlowerKeyEncOptsAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_in_hw_count(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 86u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_key_port_src_min(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 87u16, 2 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_key_port_src_max(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 88u16, 2 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_key_port_dst_min(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 89u16, 2 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_key_port_dst_max(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 90u16, 2 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_key_ct_state(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 91u16, 2 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_key_ct_state_mask(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 92u16, 2 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_key_ct_zone(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 93u16, 2 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_key_ct_zone_mask(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 94u16, 2 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_key_ct_mark(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 95u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_key_ct_mark_mask(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 96u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_key_ct_labels(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 97u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_key_ct_labels_mask(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 98u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn nested_key_mpls_opts(mut self) -> PushFlowerKeyMplsOptAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 99u16);
        PushFlowerKeyMplsOptAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_key_hash(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 100u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_key_hash_mask(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 101u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_key_num_of_vlans(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 102u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_key_pppoe_sid(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 103u16, 2 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_key_ppp_proto(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 104u16, 2 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_key_l2tpv3_sid(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 105u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_l2_miss(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 106u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn nested_key_cfm(mut self) -> PushFlowerKeyCfmAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 107u16);
        PushFlowerKeyCfmAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_key_spi(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 108u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_key_spi_mask(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 109u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "Associated type: \"FlowerKeyCtrlFlags\" (1 bit per enumeration)"]
    pub fn push_key_enc_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 110u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "Associated type: \"FlowerKeyCtrlFlags\" (1 bit per enumeration)"]
    pub fn push_key_enc_flags_mask(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 111u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushFlowerAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushFlowerKeyEncOptsAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushFlowerKeyEncOptsAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushFlowerKeyEncOptsAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn nested_geneve(mut self) -> PushFlowerKeyEncOptGeneveAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 1u16);
        PushFlowerKeyEncOptGeneveAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn nested_vxlan(mut self) -> PushFlowerKeyEncOptVxlanAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        PushFlowerKeyEncOptVxlanAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn nested_erspan(mut self) -> PushFlowerKeyEncOptErspanAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 3u16);
        PushFlowerKeyEncOptErspanAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn nested_gtp(mut self) -> PushFlowerKeyEncOptGtpAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushFlowerKeyEncOptGtpAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushFlowerKeyEncOptsAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushFlowerKeyEncOptGeneveAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushFlowerKeyEncOptGeneveAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushFlowerKeyEncOptGeneveAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_class(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 1u16, 2 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_type(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 2u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_data(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 3u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushFlowerKeyEncOptGeneveAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushFlowerKeyEncOptVxlanAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushFlowerKeyEncOptVxlanAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushFlowerKeyEncOptVxlanAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_gbp(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushFlowerKeyEncOptVxlanAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushFlowerKeyEncOptErspanAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushFlowerKeyEncOptErspanAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushFlowerKeyEncOptErspanAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_ver(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 1u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_dir(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 3u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_hwid(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 4u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushFlowerKeyEncOptErspanAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushFlowerKeyEncOptGtpAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushFlowerKeyEncOptGtpAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushFlowerKeyEncOptGtpAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_pdu_type(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 1u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_qfi(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 2u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushFlowerKeyEncOptGtpAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushFlowerKeyMplsOptAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushFlowerKeyMplsOptAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushFlowerKeyMplsOptAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_lse_depth(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 1u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_lse_ttl(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 2u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_lse_bos(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 3u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_lse_tc(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 4u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_lse_label(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushFlowerKeyMplsOptAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushFlowerKeyCfmAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushFlowerKeyCfmAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushFlowerKeyCfmAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_md_level(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 1u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_opcode(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 2u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushFlowerKeyCfmAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushFwAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushFwAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushFwAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_classid(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn nested_police(mut self) -> PushPoliceAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        PushPoliceAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_indev(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            3u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_indev_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 3u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn array_act(mut self) -> PushArrayActAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushArrayActAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
            counter: 0,
        }
    }
    pub fn push_mask(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushFwAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushGredAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushGredAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushGredAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_parms(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_stab(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_dps(mut self, value: PushTcGredSopt) -> Self {
        push_header(self.as_rec_mut(), 3u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_max_p(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 4u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_limit(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn nested_vq_list(mut self) -> PushTcaGredVqListAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 6u16);
        PushTcaGredVqListAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushGredAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushTcaGredVqListAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushTcaGredVqListAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushTcaGredVqListAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn nested_entry(mut self) -> PushTcaGredVqEntryAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 1u16);
        PushTcaGredVqEntryAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushTcaGredVqListAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushTcaGredVqEntryAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushTcaGredVqEntryAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushTcaGredVqEntryAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_dp(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_stat_bytes(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 3u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_stat_packets(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_stat_backlog(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_stat_prob_drop(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_stat_prob_mark(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 7u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_stat_forced_drop(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 8u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_stat_forced_mark(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 9u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_stat_pdrop(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 10u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_stat_other(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 11u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 12u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushTcaGredVqEntryAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushHfscAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushHfscAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushHfscAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_rsc(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_fsc(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_usc(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 3u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushHfscAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushHhfAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushHhfAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushHhfAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_backlog_limit(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_quantum(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_hh_flows_limit(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_reset_timeout(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_admit_bytes(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_evict_timeout(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_non_hh_weight(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 7u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushHhfAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushHtbAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushHtbAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushHtbAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_parms(mut self, value: PushTcHtbOpt) -> Self {
        push_header(self.as_rec_mut(), 1u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_init(mut self, value: PushTcHtbGlob) -> Self {
        push_header(self.as_rec_mut(), 2u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_ctab(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 3u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_rtab(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 4u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_direct_qlen(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_rate64(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 6u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_ceil64(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 7u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 8u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_offload(mut self, value: ()) -> Self {
        push_header(self.as_rec_mut(), 9u16, 0 as u16);
        self
    }
}
impl<Prev: Rec> Drop for PushHtbAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushMatchallAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushMatchallAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushMatchallAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_classid(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn array_act(mut self) -> PushArrayActAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        PushArrayActAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
            counter: 0,
        }
    }
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_pcnt(mut self, value: PushTcMatchallPcnt) -> Self {
        push_header(self.as_rec_mut(), 4u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 5u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushMatchallAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushEtfAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushEtfAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushEtfAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_parms(mut self, value: PushTcEtfQopt) -> Self {
        push_header(self.as_rec_mut(), 1u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
}
impl<Prev: Rec> Drop for PushEtfAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushEtsAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushEtsAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushEtsAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_nbands(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 1u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_nstrict(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 2u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn nested_quanta(mut self) -> PushEtsAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 3u16);
        PushEtsAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn push_quanta_band(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn nested_priomap(mut self) -> PushEtsAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 5u16);
        PushEtsAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn push_priomap_band(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 6u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushEtsAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushFqAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushFqAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushFqAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "Limit of total number of packets in queue"]
    pub fn push_plimit(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Limit of packets per flow"]
    pub fn push_flow_plimit(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "RR quantum"]
    pub fn push_quantum(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "RR quantum for new flow"]
    pub fn push_initial_quantum(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Enable / disable rate limiting"]
    pub fn push_rate_enable(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Obsolete, do not use"]
    pub fn push_flow_default_rate(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Per flow max rate"]
    pub fn push_flow_max_rate(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 7u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "log2(number of buckets)"]
    pub fn push_buckets_log(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 8u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Flow credit refill delay in usec"]
    pub fn push_flow_refill_delay(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 9u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Mask applied to orphaned skb hashes"]
    pub fn push_orphan_mask(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 10u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Per packet delay under this rate"]
    pub fn push_low_rate_threshold(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 11u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "DCTCP-like CE marking threshold"]
    pub fn push_ce_threshold(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 12u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_timer_slack(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 13u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Time horizon in usec"]
    pub fn push_horizon(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 14u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Drop packets beyond horizon, or cap their EDT"]
    pub fn push_horizon_drop(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 15u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_priomap(mut self, value: PushTcPrioQopt) -> Self {
        push_header(self.as_rec_mut(), 16u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    #[doc = "Weights for each band"]
    pub fn push_weights(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 17u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushFqAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushFqCodelAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushFqCodelAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushFqCodelAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_target(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_limit(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_interval(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_ecn(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_flows(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_quantum(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_ce_threshold(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 7u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_drop_batch_size(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 8u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_memory_limit(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 9u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_ce_threshold_selector(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 10u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_ce_threshold_mask(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 11u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushFqCodelAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushFqPieAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushFqPieAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushFqPieAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_limit(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_flows(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_target(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_tupdate(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_alpha(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_beta(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_quantum(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 7u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_memory_limit(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 8u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_ecn_prob(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 9u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_ecn(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 10u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_bytemode(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 11u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_dq_rate_estimator(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 12u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushFqPieAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushNetemAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushNetemAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushNetemAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_corr(mut self, value: PushTcNetemCorr) -> Self {
        push_header(self.as_rec_mut(), 1u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_delay_dist(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_reorder(mut self, value: PushTcNetemReorder) -> Self {
        push_header(self.as_rec_mut(), 3u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_corrupt(mut self, value: PushTcNetemCorrupt) -> Self {
        push_header(self.as_rec_mut(), 4u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn nested_loss(mut self) -> PushNetemLossAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 5u16);
        PushNetemLossAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_rate(mut self, value: PushTcNetemRate) -> Self {
        push_header(self.as_rec_mut(), 6u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_ecn(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 7u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_rate64(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 8u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_pad(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 9u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_latency64(mut self, value: i64) -> Self {
        push_header(self.as_rec_mut(), 10u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_jitter64(mut self, value: i64) -> Self {
        push_header(self.as_rec_mut(), 11u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_slot(mut self, value: PushTcNetemSlot) -> Self {
        push_header(self.as_rec_mut(), 12u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_slot_dist(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 13u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_prng_seed(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 14u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushNetemAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushNetemLossAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushNetemLossAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushNetemLossAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "General Intuitive - 4 state model"]
    pub fn push_gi(mut self, value: PushTcNetemGimodel) -> Self {
        push_header(self.as_rec_mut(), 1u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    #[doc = "Gilbert Elliot models"]
    pub fn push_ge(mut self, value: PushTcNetemGemodel) -> Self {
        push_header(self.as_rec_mut(), 2u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
}
impl<Prev: Rec> Drop for PushNetemLossAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushPieAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushPieAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushPieAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_target(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_limit(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_tupdate(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_alpha(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_beta(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_ecn(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_bytemode(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 7u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_dq_rate_estimator(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 8u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushPieAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushPoliceAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushPoliceAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushPoliceAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_tbf(mut self, value: PushTcPolice) -> Self {
        push_header(self.as_rec_mut(), 1u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_rate(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_peakrate(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 3u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_avrate(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_result(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_tm(mut self, value: PushTcfT) -> Self {
        push_header(self.as_rec_mut(), 6u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 7u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_rate64(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 8u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_peakrate64(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 9u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_pktrate64(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 10u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_pktburst64(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 11u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushPoliceAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushQfqAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushQfqAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushQfqAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_weight(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_lmax(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushQfqAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushRedAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushRedAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushRedAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_parms(mut self, value: PushTcRedQopt) -> Self {
        push_header(self.as_rec_mut(), 1u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_stab(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_max_p(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_flags(mut self, value: PushBuiltinBitfield32) -> Self {
        push_header(self.as_rec_mut(), 4u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_early_drop_block(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_mark_block(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushRedAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushRouteAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushRouteAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushRouteAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_classid(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_to(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_from(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_iif(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn nested_police(mut self) -> PushPoliceAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 5u16);
        PushPoliceAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn array_act(mut self) -> PushArrayActAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 6u16);
        PushArrayActAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
            counter: 0,
        }
    }
}
impl<Prev: Rec> Drop for PushRouteAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushTaprioAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushTaprioAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushTaprioAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_priomap(mut self, value: PushTcMqprioQopt) -> Self {
        push_header(self.as_rec_mut(), 1u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn nested_sched_entry_list(mut self) -> PushTaprioSchedEntryList<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        PushTaprioSchedEntryList {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_sched_base_time(mut self, value: i64) -> Self {
        push_header(self.as_rec_mut(), 3u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn nested_sched_single_entry(mut self) -> PushTaprioSchedEntry<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushTaprioSchedEntry {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_sched_clockid(mut self, value: i32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 6u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_admin_sched(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 7u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_sched_cycle_time(mut self, value: i64) -> Self {
        push_header(self.as_rec_mut(), 8u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_sched_cycle_time_extension(mut self, value: i64) -> Self {
        push_header(self.as_rec_mut(), 9u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 10u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_txtime_delay(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 11u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn nested_tc_entry(mut self) -> PushTaprioTcEntryAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 12u16);
        PushTaprioTcEntryAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushTaprioAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushTaprioSchedEntryList<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushTaprioSchedEntryList<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushTaprioSchedEntryList<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn nested_entry(mut self) -> PushTaprioSchedEntry<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 1u16);
        PushTaprioSchedEntry {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushTaprioSchedEntryList<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushTaprioSchedEntry<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushTaprioSchedEntry<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushTaprioSchedEntry<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_cmd(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 2u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_gate_mask(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_interval(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushTaprioSchedEntry<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushTaprioTcEntryAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushTaprioTcEntryAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushTaprioTcEntryAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_max_sdu(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_fp(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushTaprioTcEntryAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushTbfAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushTbfAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushTbfAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_parms(mut self, value: PushTcTbfQopt) -> Self {
        push_header(self.as_rec_mut(), 1u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_rtab(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_ptab(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 3u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_rate64(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 4u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_prate64(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 5u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_burst(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_pburst(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 7u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 8u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushTbfAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushActSampleAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushActSampleAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushActSampleAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_tm(mut self, value: PushTcfT) -> Self {
        push_header(self.as_rec_mut(), 1u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_parms(mut self, value: PushTcGact) -> Self {
        push_header(self.as_rec_mut(), 2u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_rate(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_trunc_size(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_psample_group(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 6u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushActSampleAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushActGactAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushActGactAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushActGactAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_tm(mut self, value: PushTcfT) -> Self {
        push_header(self.as_rec_mut(), 1u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_parms(mut self, value: PushTcGact) -> Self {
        push_header(self.as_rec_mut(), 2u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_prob(mut self, value: PushTcGactP) -> Self {
        push_header(self.as_rec_mut(), 3u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 4u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushActGactAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushTcaStabAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushTcaStabAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushTcaStabAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_base(mut self, value: PushTcSizespec) -> Self {
        push_header(self.as_rec_mut(), 1u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_data(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushTcaStabAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushTcaStatsAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushTcaStatsAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushTcaStatsAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_basic(mut self, value: PushGnetStatsBasic) -> Self {
        push_header(self.as_rec_mut(), 1u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_rate_est(mut self, value: PushGnetStatsRateEst) -> Self {
        push_header(self.as_rec_mut(), 2u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_queue(mut self, value: PushGnetStatsQueue) -> Self {
        push_header(self.as_rec_mut(), 3u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_rate_est64(mut self, value: PushGnetStatsRateEst64) -> Self {
        push_header(self.as_rec_mut(), 5u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 6u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_basic_hw(mut self, value: PushGnetStatsBasic) -> Self {
        push_header(self.as_rec_mut(), 7u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_pkt64(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 8u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushTcaStatsAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushU32Attrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushU32Attrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushU32Attrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_classid(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_hash(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_link(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_divisor(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_sel(mut self, value: PushTcU32Sel) -> Self {
        push_header(self.as_rec_mut(), 5u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn nested_police(mut self) -> PushPoliceAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 6u16);
        PushPoliceAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn array_act(mut self) -> PushArrayActAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 7u16);
        PushArrayActAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
            counter: 0,
        }
    }
    pub fn push_indev(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            8u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_indev_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 8u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_pcnt(mut self, value: PushTcU32Pcnt) -> Self {
        push_header(self.as_rec_mut(), 9u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_mark(mut self, value: PushTcU32Mark) -> Self {
        push_header(self.as_rec_mut(), 10u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 11u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 12u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushU32Attrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Original name: \"tcmsg\""]
#[derive(Clone)]
pub struct PushTcmsg {
    pub(crate) buf: [u8; 20usize],
}
impl PushTcmsg {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        20usize
    }
    pub fn family(&self) -> u8 {
        parse_u8(&self.buf[0usize..1usize]).unwrap()
    }
    pub fn set_family(&mut self, value: u8) {
        self.buf[0usize..1usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn ifindex(&self) -> i32 {
        parse_i32(&self.buf[4usize..8usize]).unwrap()
    }
    pub fn set_ifindex(&mut self, value: i32) {
        self.buf[4usize..8usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn handle(&self) -> u32 {
        parse_u32(&self.buf[8usize..12usize]).unwrap()
    }
    pub fn set_handle(&mut self, value: u32) {
        self.buf[8usize..12usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn parent(&self) -> u32 {
        parse_u32(&self.buf[12usize..16usize]).unwrap()
    }
    pub fn set_parent(&mut self, value: u32) {
        self.buf[12usize..16usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn info(&self) -> u32 {
        parse_u32(&self.buf[16usize..20usize]).unwrap()
    }
    pub fn set_info(&mut self, value: u32) {
        self.buf[16usize..20usize].copy_from_slice(&value.to_ne_bytes())
    }
}
impl std::fmt::Debug for PushTcmsg {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("Tcmsg")
            .field("family", &self.family())
            .field("ifindex", &self.ifindex())
            .field("handle", &self.handle())
            .field("parent", &self.parent())
            .field("info", &self.info())
            .finish()
    }
}
#[doc = "Original name: \"tc-stats\""]
#[derive(Clone)]
pub struct PushTcStats {
    pub(crate) buf: [u8; 40usize],
}
impl PushTcStats {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        40usize
    }
    #[doc = "Number of enqueued bytes"]
    pub fn bytes(&self) -> u64 {
        parse_u64(&self.buf[0usize..8usize]).unwrap()
    }
    #[doc = "Number of enqueued bytes"]
    pub fn set_bytes(&mut self, value: u64) {
        self.buf[0usize..8usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Number of enqueued packets"]
    pub fn packets(&self) -> u32 {
        parse_u32(&self.buf[8usize..12usize]).unwrap()
    }
    #[doc = "Number of enqueued packets"]
    pub fn set_packets(&mut self, value: u32) {
        self.buf[8usize..12usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Packets dropped because of lack of resources"]
    pub fn drops(&self) -> u32 {
        parse_u32(&self.buf[12usize..16usize]).unwrap()
    }
    #[doc = "Packets dropped because of lack of resources"]
    pub fn set_drops(&mut self, value: u32) {
        self.buf[12usize..16usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Number of throttle events when this flow goes out of allocated\nbandwidth\n"]
    pub fn overlimits(&self) -> u32 {
        parse_u32(&self.buf[16usize..20usize]).unwrap()
    }
    #[doc = "Number of throttle events when this flow goes out of allocated\nbandwidth\n"]
    pub fn set_overlimits(&mut self, value: u32) {
        self.buf[16usize..20usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Current flow byte rate"]
    pub fn bps(&self) -> u32 {
        parse_u32(&self.buf[20usize..24usize]).unwrap()
    }
    #[doc = "Current flow byte rate"]
    pub fn set_bps(&mut self, value: u32) {
        self.buf[20usize..24usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Current flow packet rate"]
    pub fn pps(&self) -> u32 {
        parse_u32(&self.buf[24usize..28usize]).unwrap()
    }
    #[doc = "Current flow packet rate"]
    pub fn set_pps(&mut self, value: u32) {
        self.buf[24usize..28usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn qlen(&self) -> u32 {
        parse_u32(&self.buf[28usize..32usize]).unwrap()
    }
    pub fn set_qlen(&mut self, value: u32) {
        self.buf[28usize..32usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn backlog(&self) -> u32 {
        parse_u32(&self.buf[32usize..36usize]).unwrap()
    }
    pub fn set_backlog(&mut self, value: u32) {
        self.buf[32usize..36usize].copy_from_slice(&value.to_ne_bytes())
    }
}
impl std::fmt::Debug for PushTcStats {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("TcStats")
            .field("bytes", &self.bytes())
            .field("packets", &self.packets())
            .field("drops", &self.drops())
            .field("overlimits", &self.overlimits())
            .field("bps", &self.bps())
            .field("pps", &self.pps())
            .field("qlen", &self.qlen())
            .field("backlog", &self.backlog())
            .finish()
    }
}
#[doc = "Original name: \"tc-cbs-qopt\""]
#[derive(Clone)]
pub struct PushTcCbsQopt {
    pub(crate) buf: [u8; 20usize],
}
impl PushTcCbsQopt {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        20usize
    }
    pub fn offload(&self) -> u8 {
        parse_u8(&self.buf[0usize..1usize]).unwrap()
    }
    pub fn set_offload(&mut self, value: u8) {
        self.buf[0usize..1usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn hicredit(&self) -> i32 {
        parse_i32(&self.buf[4usize..8usize]).unwrap()
    }
    pub fn set_hicredit(&mut self, value: i32) {
        self.buf[4usize..8usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn locredit(&self) -> i32 {
        parse_i32(&self.buf[8usize..12usize]).unwrap()
    }
    pub fn set_locredit(&mut self, value: i32) {
        self.buf[8usize..12usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn idleslope(&self) -> i32 {
        parse_i32(&self.buf[12usize..16usize]).unwrap()
    }
    pub fn set_idleslope(&mut self, value: i32) {
        self.buf[12usize..16usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn sendslope(&self) -> i32 {
        parse_i32(&self.buf[16usize..20usize]).unwrap()
    }
    pub fn set_sendslope(&mut self, value: i32) {
        self.buf[16usize..20usize].copy_from_slice(&value.to_ne_bytes())
    }
}
impl std::fmt::Debug for PushTcCbsQopt {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("TcCbsQopt")
            .field("offload", &self.offload())
            .field("hicredit", &self.hicredit())
            .field("locredit", &self.locredit())
            .field("idleslope", &self.idleslope())
            .field("sendslope", &self.sendslope())
            .finish()
    }
}
#[doc = "Original name: \"tc-etf-qopt\""]
#[derive(Clone)]
pub struct PushTcEtfQopt {
    pub(crate) buf: [u8; 12usize],
}
impl PushTcEtfQopt {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        12usize
    }
    pub fn delta(&self) -> i32 {
        parse_i32(&self.buf[0usize..4usize]).unwrap()
    }
    pub fn set_delta(&mut self, value: i32) {
        self.buf[0usize..4usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn clockid(&self) -> i32 {
        parse_i32(&self.buf[4usize..8usize]).unwrap()
    }
    pub fn set_clockid(&mut self, value: i32) {
        self.buf[4usize..8usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn flags(&self) -> i32 {
        parse_i32(&self.buf[8usize..12usize]).unwrap()
    }
    pub fn set_flags(&mut self, value: i32) {
        self.buf[8usize..12usize].copy_from_slice(&value.to_ne_bytes())
    }
}
impl std::fmt::Debug for PushTcEtfQopt {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("TcEtfQopt")
            .field("delta", &self.delta())
            .field("clockid", &self.clockid())
            .field("flags", &self.flags())
            .finish()
    }
}
#[doc = "Original name: \"tc-fifo-qopt\""]
#[derive(Clone)]
pub struct PushTcFifoQopt {
    pub(crate) buf: [u8; 4usize],
}
impl PushTcFifoQopt {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        4usize
    }
    #[doc = "Queue length; bytes for bfifo, packets for pfifo"]
    pub fn limit(&self) -> u32 {
        parse_u32(&self.buf[0usize..4usize]).unwrap()
    }
    #[doc = "Queue length; bytes for bfifo, packets for pfifo"]
    pub fn set_limit(&mut self, value: u32) {
        self.buf[0usize..4usize].copy_from_slice(&value.to_ne_bytes())
    }
}
impl std::fmt::Debug for PushTcFifoQopt {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("TcFifoQopt")
            .field("limit", &self.limit())
            .finish()
    }
}
#[doc = "Original name: \"tc-htb-opt\""]
#[derive(Clone)]
pub struct PushTcHtbOpt {
    pub(crate) buf: [u8; 20usize],
}
impl PushTcHtbOpt {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        20usize
    }
    pub fn rate(&self) -> PushTcRatespec {
        PushTcRatespec::new_from_slice(&self.buf[0usize..12usize]).unwrap()
    }
    pub fn set_rate(&mut self, value: PushTcRatespec) {
        self.buf[0usize..12usize].copy_from_slice(&value.as_slice())
    }
    pub fn ceil(&self) -> PushTcRatespec {
        PushTcRatespec::new_from_slice(&self.buf[0usize..12usize]).unwrap()
    }
    pub fn set_ceil(&mut self, value: PushTcRatespec) {
        self.buf[0usize..12usize].copy_from_slice(&value.as_slice())
    }
    pub fn buffer(&self) -> u32 {
        parse_u32(&self.buf[0usize..4usize]).unwrap()
    }
    pub fn set_buffer(&mut self, value: u32) {
        self.buf[0usize..4usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn cbuffer(&self) -> u32 {
        parse_u32(&self.buf[4usize..8usize]).unwrap()
    }
    pub fn set_cbuffer(&mut self, value: u32) {
        self.buf[4usize..8usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn quantum(&self) -> u32 {
        parse_u32(&self.buf[8usize..12usize]).unwrap()
    }
    pub fn set_quantum(&mut self, value: u32) {
        self.buf[8usize..12usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn level(&self) -> u32 {
        parse_u32(&self.buf[12usize..16usize]).unwrap()
    }
    pub fn set_level(&mut self, value: u32) {
        self.buf[12usize..16usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn prio(&self) -> u32 {
        parse_u32(&self.buf[16usize..20usize]).unwrap()
    }
    pub fn set_prio(&mut self, value: u32) {
        self.buf[16usize..20usize].copy_from_slice(&value.to_ne_bytes())
    }
}
impl std::fmt::Debug for PushTcHtbOpt {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("TcHtbOpt")
            .field("rate", &self.rate())
            .field("ceil", &self.ceil())
            .field("buffer", &self.buffer())
            .field("cbuffer", &self.cbuffer())
            .field("quantum", &self.quantum())
            .field("level", &self.level())
            .field("prio", &self.prio())
            .finish()
    }
}
#[doc = "Original name: \"tc-htb-glob\""]
#[derive(Clone)]
pub struct PushTcHtbGlob {
    pub(crate) buf: [u8; 20usize],
}
impl PushTcHtbGlob {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        20usize
    }
    pub fn version(&self) -> u32 {
        parse_u32(&self.buf[0usize..4usize]).unwrap()
    }
    pub fn set_version(&mut self, value: u32) {
        self.buf[0usize..4usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "bps->quantum divisor"]
    pub fn rate2quantum(&self) -> u32 {
        parse_u32(&self.buf[4usize..8usize]).unwrap()
    }
    #[doc = "bps->quantum divisor"]
    pub fn set_rate2quantum(&mut self, value: u32) {
        self.buf[4usize..8usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Default class number"]
    pub fn defcls(&self) -> u32 {
        parse_u32(&self.buf[8usize..12usize]).unwrap()
    }
    #[doc = "Default class number"]
    pub fn set_defcls(&mut self, value: u32) {
        self.buf[8usize..12usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Debug flags"]
    pub fn debug(&self) -> u32 {
        parse_u32(&self.buf[12usize..16usize]).unwrap()
    }
    #[doc = "Debug flags"]
    pub fn set_debug(&mut self, value: u32) {
        self.buf[12usize..16usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Count of non shaped packets"]
    pub fn direct_pkts(&self) -> u32 {
        parse_u32(&self.buf[16usize..20usize]).unwrap()
    }
    #[doc = "Count of non shaped packets"]
    pub fn set_direct_pkts(&mut self, value: u32) {
        self.buf[16usize..20usize].copy_from_slice(&value.to_ne_bytes())
    }
}
impl std::fmt::Debug for PushTcHtbGlob {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("TcHtbGlob")
            .field("version", &self.version())
            .field("rate2quantum", &self.rate2quantum())
            .field("defcls", &self.defcls())
            .field("debug", &self.debug())
            .field("direct_pkts", &self.direct_pkts())
            .finish()
    }
}
#[doc = "Original name: \"tc-gred-qopt\""]
#[derive(Clone)]
pub struct PushTcGredQopt {
    pub(crate) buf: [u8; 52usize],
}
impl PushTcGredQopt {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        52usize
    }
    #[doc = "HARD maximal queue length in bytes"]
    pub fn limit(&self) -> u32 {
        parse_u32(&self.buf[0usize..4usize]).unwrap()
    }
    #[doc = "HARD maximal queue length in bytes"]
    pub fn set_limit(&mut self, value: u32) {
        self.buf[0usize..4usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Min average length threshold in bytes"]
    pub fn qth_min(&self) -> u32 {
        parse_u32(&self.buf[4usize..8usize]).unwrap()
    }
    #[doc = "Min average length threshold in bytes"]
    pub fn set_qth_min(&mut self, value: u32) {
        self.buf[4usize..8usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Max average length threshold in bytes"]
    pub fn qth_max(&self) -> u32 {
        parse_u32(&self.buf[8usize..12usize]).unwrap()
    }
    #[doc = "Max average length threshold in bytes"]
    pub fn set_qth_max(&mut self, value: u32) {
        self.buf[8usize..12usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Up to 2^32 DPs"]
    pub fn DP(&self) -> u32 {
        parse_u32(&self.buf[12usize..16usize]).unwrap()
    }
    #[doc = "Up to 2^32 DPs"]
    pub fn set_DP(&mut self, value: u32) {
        self.buf[12usize..16usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn backlog(&self) -> u32 {
        parse_u32(&self.buf[16usize..20usize]).unwrap()
    }
    pub fn set_backlog(&mut self, value: u32) {
        self.buf[16usize..20usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn qave(&self) -> u32 {
        parse_u32(&self.buf[20usize..24usize]).unwrap()
    }
    pub fn set_qave(&mut self, value: u32) {
        self.buf[20usize..24usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn forced(&self) -> u32 {
        parse_u32(&self.buf[24usize..28usize]).unwrap()
    }
    pub fn set_forced(&mut self, value: u32) {
        self.buf[24usize..28usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn early(&self) -> u32 {
        parse_u32(&self.buf[28usize..32usize]).unwrap()
    }
    pub fn set_early(&mut self, value: u32) {
        self.buf[28usize..32usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn other(&self) -> u32 {
        parse_u32(&self.buf[32usize..36usize]).unwrap()
    }
    pub fn set_other(&mut self, value: u32) {
        self.buf[32usize..36usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn pdrop(&self) -> u32 {
        parse_u32(&self.buf[36usize..40usize]).unwrap()
    }
    pub fn set_pdrop(&mut self, value: u32) {
        self.buf[36usize..40usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "log(W)"]
    pub fn Wlog(&self) -> u8 {
        parse_u8(&self.buf[40usize..41usize]).unwrap()
    }
    #[doc = "log(W)"]
    pub fn set_Wlog(&mut self, value: u8) {
        self.buf[40usize..41usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "log(P_max / (qth-max - qth-min))"]
    pub fn Plog(&self) -> u8 {
        parse_u8(&self.buf[41usize..42usize]).unwrap()
    }
    #[doc = "log(P_max / (qth-max - qth-min))"]
    pub fn set_Plog(&mut self, value: u8) {
        self.buf[41usize..42usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "cell size for idle damping"]
    pub fn Scell_log(&self) -> u8 {
        parse_u8(&self.buf[42usize..43usize]).unwrap()
    }
    #[doc = "cell size for idle damping"]
    pub fn set_Scell_log(&mut self, value: u8) {
        self.buf[42usize..43usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Priority of this VQ"]
    pub fn prio(&self) -> u8 {
        parse_u8(&self.buf[43usize..44usize]).unwrap()
    }
    #[doc = "Priority of this VQ"]
    pub fn set_prio(&mut self, value: u8) {
        self.buf[43usize..44usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn packets(&self) -> u32 {
        parse_u32(&self.buf[44usize..48usize]).unwrap()
    }
    pub fn set_packets(&mut self, value: u32) {
        self.buf[44usize..48usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn bytesin(&self) -> u32 {
        parse_u32(&self.buf[48usize..52usize]).unwrap()
    }
    pub fn set_bytesin(&mut self, value: u32) {
        self.buf[48usize..52usize].copy_from_slice(&value.to_ne_bytes())
    }
}
impl std::fmt::Debug for PushTcGredQopt {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("TcGredQopt")
            .field("limit", &self.limit())
            .field("qth_min", &self.qth_min())
            .field("qth_max", &self.qth_max())
            .field("DP", &self.DP())
            .field("backlog", &self.backlog())
            .field("qave", &self.qave())
            .field("forced", &self.forced())
            .field("early", &self.early())
            .field("other", &self.other())
            .field("pdrop", &self.pdrop())
            .field("Wlog", &self.Wlog())
            .field("Plog", &self.Plog())
            .field("Scell_log", &self.Scell_log())
            .field("prio", &self.prio())
            .field("packets", &self.packets())
            .field("bytesin", &self.bytesin())
            .finish()
    }
}
#[doc = "Original name: \"tc-gred-sopt\""]
#[derive(Clone)]
pub struct PushTcGredSopt {
    pub(crate) buf: [u8; 12usize],
}
impl PushTcGredSopt {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        12usize
    }
    pub fn DPs(&self) -> u32 {
        parse_u32(&self.buf[0usize..4usize]).unwrap()
    }
    pub fn set_DPs(&mut self, value: u32) {
        self.buf[0usize..4usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn def_DP(&self) -> u32 {
        parse_u32(&self.buf[4usize..8usize]).unwrap()
    }
    pub fn set_def_DP(&mut self, value: u32) {
        self.buf[4usize..8usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn grio(&self) -> u8 {
        parse_u8(&self.buf[8usize..9usize]).unwrap()
    }
    pub fn set_grio(&mut self, value: u8) {
        self.buf[8usize..9usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn flags(&self) -> u8 {
        parse_u8(&self.buf[9usize..10usize]).unwrap()
    }
    pub fn set_flags(&mut self, value: u8) {
        self.buf[9usize..10usize].copy_from_slice(&value.to_ne_bytes())
    }
}
impl std::fmt::Debug for PushTcGredSopt {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("TcGredSopt")
            .field("DPs", &self.DPs())
            .field("def_DP", &self.def_DP())
            .field("grio", &self.grio())
            .field("flags", &self.flags())
            .finish()
    }
}
#[doc = "Original name: \"tc-hfsc-qopt\""]
#[derive(Clone)]
pub struct PushTcHfscQopt {
    pub(crate) buf: [u8; 2usize],
}
impl PushTcHfscQopt {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        2usize
    }
    pub fn defcls(&self) -> u16 {
        parse_u16(&self.buf[0usize..2usize]).unwrap()
    }
    pub fn set_defcls(&mut self, value: u16) {
        self.buf[0usize..2usize].copy_from_slice(&value.to_ne_bytes())
    }
}
impl std::fmt::Debug for PushTcHfscQopt {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("TcHfscQopt")
            .field("defcls", &self.defcls())
            .finish()
    }
}
#[doc = "Original name: \"tc-mqprio-qopt\""]
#[derive(Clone)]
pub struct PushTcMqprioQopt {
    pub(crate) buf: [u8; 2usize],
}
impl PushTcMqprioQopt {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        2usize
    }
    pub fn num_tc(&self) -> u8 {
        parse_u8(&self.buf[0usize..1usize]).unwrap()
    }
    pub fn set_num_tc(&mut self, value: u8) {
        self.buf[0usize..1usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn prio_tc_map(&self) -> [u8; 16usize] {
        self.buf[1usize..17usize].try_into().unwrap()
    }
    pub fn set_prio_tc_map(&mut self, value: [u8; 16usize]) {
        self.buf[1usize..17usize].copy_from_slice(&value)
    }
    pub fn hw(&self) -> u8 {
        parse_u8(&self.buf[1usize..2usize]).unwrap()
    }
    pub fn set_hw(&mut self, value: u8) {
        self.buf[1usize..2usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn count(&self) -> [u8; 32usize] {
        self.buf[2usize..34usize].try_into().unwrap()
    }
    pub fn set_count(&mut self, value: [u8; 32usize]) {
        self.buf[2usize..34usize].copy_from_slice(&value)
    }
    pub fn offset(&self) -> [u8; 32usize] {
        self.buf[2usize..34usize].try_into().unwrap()
    }
    pub fn set_offset(&mut self, value: [u8; 32usize]) {
        self.buf[2usize..34usize].copy_from_slice(&value)
    }
}
impl std::fmt::Debug for PushTcMqprioQopt {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("TcMqprioQopt")
            .field("num_tc", &self.num_tc())
            .field("prio_tc_map", &self.prio_tc_map())
            .field("hw", &self.hw())
            .field("count", &self.count())
            .field("offset", &self.offset())
            .finish()
    }
}
#[doc = "Original name: \"tc-multiq-qopt\""]
#[derive(Clone)]
pub struct PushTcMultiqQopt {
    pub(crate) buf: [u8; 4usize],
}
impl PushTcMultiqQopt {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        4usize
    }
    #[doc = "Number of bands"]
    pub fn bands(&self) -> u16 {
        parse_u16(&self.buf[0usize..2usize]).unwrap()
    }
    #[doc = "Number of bands"]
    pub fn set_bands(&mut self, value: u16) {
        self.buf[0usize..2usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Maximum number of queues"]
    pub fn max_bands(&self) -> u16 {
        parse_u16(&self.buf[2usize..4usize]).unwrap()
    }
    #[doc = "Maximum number of queues"]
    pub fn set_max_bands(&mut self, value: u16) {
        self.buf[2usize..4usize].copy_from_slice(&value.to_ne_bytes())
    }
}
impl std::fmt::Debug for PushTcMultiqQopt {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("TcMultiqQopt")
            .field("bands", &self.bands())
            .field("max_bands", &self.max_bands())
            .finish()
    }
}
#[doc = "Original name: \"tc-netem-qopt\""]
#[derive(Clone)]
pub struct PushTcNetemQopt {
    pub(crate) buf: [u8; 24usize],
}
impl PushTcNetemQopt {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        24usize
    }
    #[doc = "Added delay in microseconds"]
    pub fn latency(&self) -> u32 {
        parse_u32(&self.buf[0usize..4usize]).unwrap()
    }
    #[doc = "Added delay in microseconds"]
    pub fn set_latency(&mut self, value: u32) {
        self.buf[0usize..4usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Fifo limit in packets"]
    pub fn limit(&self) -> u32 {
        parse_u32(&self.buf[4usize..8usize]).unwrap()
    }
    #[doc = "Fifo limit in packets"]
    pub fn set_limit(&mut self, value: u32) {
        self.buf[4usize..8usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Random packet loss (0=none, ~0=100%)"]
    pub fn loss(&self) -> u32 {
        parse_u32(&self.buf[8usize..12usize]).unwrap()
    }
    #[doc = "Random packet loss (0=none, ~0=100%)"]
    pub fn set_loss(&mut self, value: u32) {
        self.buf[8usize..12usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Re-ordering gap (0 for none)"]
    pub fn gap(&self) -> u32 {
        parse_u32(&self.buf[12usize..16usize]).unwrap()
    }
    #[doc = "Re-ordering gap (0 for none)"]
    pub fn set_gap(&mut self, value: u32) {
        self.buf[12usize..16usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Random packet duplication (0=none, ~0=100%)"]
    pub fn duplicate(&self) -> u32 {
        parse_u32(&self.buf[16usize..20usize]).unwrap()
    }
    #[doc = "Random packet duplication (0=none, ~0=100%)"]
    pub fn set_duplicate(&mut self, value: u32) {
        self.buf[16usize..20usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Random jitter latency in microseconds"]
    pub fn jitter(&self) -> u32 {
        parse_u32(&self.buf[20usize..24usize]).unwrap()
    }
    #[doc = "Random jitter latency in microseconds"]
    pub fn set_jitter(&mut self, value: u32) {
        self.buf[20usize..24usize].copy_from_slice(&value.to_ne_bytes())
    }
}
impl std::fmt::Debug for PushTcNetemQopt {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("TcNetemQopt")
            .field("latency", &self.latency())
            .field("limit", &self.limit())
            .field("loss", &self.loss())
            .field("gap", &self.gap())
            .field("duplicate", &self.duplicate())
            .field("jitter", &self.jitter())
            .finish()
    }
}
#[doc = "Original name: \"tc-netem-gimodel\""]
#[derive(Clone)]
pub struct PushTcNetemGimodel {
    pub(crate) buf: [u8; 20usize],
}
impl PushTcNetemGimodel {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        20usize
    }
    pub fn p13(&self) -> u32 {
        parse_u32(&self.buf[0usize..4usize]).unwrap()
    }
    pub fn set_p13(&mut self, value: u32) {
        self.buf[0usize..4usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn p31(&self) -> u32 {
        parse_u32(&self.buf[4usize..8usize]).unwrap()
    }
    pub fn set_p31(&mut self, value: u32) {
        self.buf[4usize..8usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn p32(&self) -> u32 {
        parse_u32(&self.buf[8usize..12usize]).unwrap()
    }
    pub fn set_p32(&mut self, value: u32) {
        self.buf[8usize..12usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn p14(&self) -> u32 {
        parse_u32(&self.buf[12usize..16usize]).unwrap()
    }
    pub fn set_p14(&mut self, value: u32) {
        self.buf[12usize..16usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn p23(&self) -> u32 {
        parse_u32(&self.buf[16usize..20usize]).unwrap()
    }
    pub fn set_p23(&mut self, value: u32) {
        self.buf[16usize..20usize].copy_from_slice(&value.to_ne_bytes())
    }
}
impl std::fmt::Debug for PushTcNetemGimodel {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("TcNetemGimodel")
            .field("p13", &self.p13())
            .field("p31", &self.p31())
            .field("p32", &self.p32())
            .field("p14", &self.p14())
            .field("p23", &self.p23())
            .finish()
    }
}
#[doc = "Original name: \"tc-netem-gemodel\""]
#[derive(Clone)]
pub struct PushTcNetemGemodel {
    pub(crate) buf: [u8; 16usize],
}
impl PushTcNetemGemodel {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        16usize
    }
    pub fn p(&self) -> u32 {
        parse_u32(&self.buf[0usize..4usize]).unwrap()
    }
    pub fn set_p(&mut self, value: u32) {
        self.buf[0usize..4usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn r(&self) -> u32 {
        parse_u32(&self.buf[4usize..8usize]).unwrap()
    }
    pub fn set_r(&mut self, value: u32) {
        self.buf[4usize..8usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn h(&self) -> u32 {
        parse_u32(&self.buf[8usize..12usize]).unwrap()
    }
    pub fn set_h(&mut self, value: u32) {
        self.buf[8usize..12usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn k1(&self) -> u32 {
        parse_u32(&self.buf[12usize..16usize]).unwrap()
    }
    pub fn set_k1(&mut self, value: u32) {
        self.buf[12usize..16usize].copy_from_slice(&value.to_ne_bytes())
    }
}
impl std::fmt::Debug for PushTcNetemGemodel {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("TcNetemGemodel")
            .field("p", &self.p())
            .field("r", &self.r())
            .field("h", &self.h())
            .field("k1", &self.k1())
            .finish()
    }
}
#[doc = "Original name: \"tc-netem-corr\""]
#[derive(Clone)]
pub struct PushTcNetemCorr {
    pub(crate) buf: [u8; 12usize],
}
impl PushTcNetemCorr {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        12usize
    }
    #[doc = "Delay correlation"]
    pub fn delay_corr(&self) -> u32 {
        parse_u32(&self.buf[0usize..4usize]).unwrap()
    }
    #[doc = "Delay correlation"]
    pub fn set_delay_corr(&mut self, value: u32) {
        self.buf[0usize..4usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Packet loss correlation"]
    pub fn loss_corr(&self) -> u32 {
        parse_u32(&self.buf[4usize..8usize]).unwrap()
    }
    #[doc = "Packet loss correlation"]
    pub fn set_loss_corr(&mut self, value: u32) {
        self.buf[4usize..8usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Duplicate correlation"]
    pub fn dup_corr(&self) -> u32 {
        parse_u32(&self.buf[8usize..12usize]).unwrap()
    }
    #[doc = "Duplicate correlation"]
    pub fn set_dup_corr(&mut self, value: u32) {
        self.buf[8usize..12usize].copy_from_slice(&value.to_ne_bytes())
    }
}
impl std::fmt::Debug for PushTcNetemCorr {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("TcNetemCorr")
            .field("delay_corr", &self.delay_corr())
            .field("loss_corr", &self.loss_corr())
            .field("dup_corr", &self.dup_corr())
            .finish()
    }
}
#[doc = "Original name: \"tc-netem-reorder\""]
#[derive(Clone)]
pub struct PushTcNetemReorder {
    pub(crate) buf: [u8; 8usize],
}
impl PushTcNetemReorder {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        8usize
    }
    pub fn probability(&self) -> u32 {
        parse_u32(&self.buf[0usize..4usize]).unwrap()
    }
    pub fn set_probability(&mut self, value: u32) {
        self.buf[0usize..4usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn correlation(&self) -> u32 {
        parse_u32(&self.buf[4usize..8usize]).unwrap()
    }
    pub fn set_correlation(&mut self, value: u32) {
        self.buf[4usize..8usize].copy_from_slice(&value.to_ne_bytes())
    }
}
impl std::fmt::Debug for PushTcNetemReorder {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("TcNetemReorder")
            .field("probability", &self.probability())
            .field("correlation", &self.correlation())
            .finish()
    }
}
#[doc = "Original name: \"tc-netem-corrupt\""]
#[derive(Clone)]
pub struct PushTcNetemCorrupt {
    pub(crate) buf: [u8; 8usize],
}
impl PushTcNetemCorrupt {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        8usize
    }
    pub fn probability(&self) -> u32 {
        parse_u32(&self.buf[0usize..4usize]).unwrap()
    }
    pub fn set_probability(&mut self, value: u32) {
        self.buf[0usize..4usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn correlation(&self) -> u32 {
        parse_u32(&self.buf[4usize..8usize]).unwrap()
    }
    pub fn set_correlation(&mut self, value: u32) {
        self.buf[4usize..8usize].copy_from_slice(&value.to_ne_bytes())
    }
}
impl std::fmt::Debug for PushTcNetemCorrupt {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("TcNetemCorrupt")
            .field("probability", &self.probability())
            .field("correlation", &self.correlation())
            .finish()
    }
}
#[doc = "Original name: \"tc-netem-rate\""]
#[derive(Clone)]
pub struct PushTcNetemRate {
    pub(crate) buf: [u8; 16usize],
}
impl PushTcNetemRate {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        16usize
    }
    pub fn rate(&self) -> u32 {
        parse_u32(&self.buf[0usize..4usize]).unwrap()
    }
    pub fn set_rate(&mut self, value: u32) {
        self.buf[0usize..4usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn packet_overhead(&self) -> i32 {
        parse_i32(&self.buf[4usize..8usize]).unwrap()
    }
    pub fn set_packet_overhead(&mut self, value: i32) {
        self.buf[4usize..8usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn cell_size(&self) -> u32 {
        parse_u32(&self.buf[8usize..12usize]).unwrap()
    }
    pub fn set_cell_size(&mut self, value: u32) {
        self.buf[8usize..12usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn cell_overhead(&self) -> i32 {
        parse_i32(&self.buf[12usize..16usize]).unwrap()
    }
    pub fn set_cell_overhead(&mut self, value: i32) {
        self.buf[12usize..16usize].copy_from_slice(&value.to_ne_bytes())
    }
}
impl std::fmt::Debug for PushTcNetemRate {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("TcNetemRate")
            .field("rate", &self.rate())
            .field("packet_overhead", &self.packet_overhead())
            .field("cell_size", &self.cell_size())
            .field("cell_overhead", &self.cell_overhead())
            .finish()
    }
}
#[doc = "Original name: \"tc-netem-slot\""]
#[derive(Clone)]
pub struct PushTcNetemSlot {
    pub(crate) buf: [u8; 40usize],
}
impl PushTcNetemSlot {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        40usize
    }
    pub fn min_delay(&self) -> i64 {
        parse_i64(&self.buf[0usize..8usize]).unwrap()
    }
    pub fn set_min_delay(&mut self, value: i64) {
        self.buf[0usize..8usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn max_delay(&self) -> i64 {
        parse_i64(&self.buf[8usize..16usize]).unwrap()
    }
    pub fn set_max_delay(&mut self, value: i64) {
        self.buf[8usize..16usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn max_packets(&self) -> i32 {
        parse_i32(&self.buf[16usize..20usize]).unwrap()
    }
    pub fn set_max_packets(&mut self, value: i32) {
        self.buf[16usize..20usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn max_bytes(&self) -> i32 {
        parse_i32(&self.buf[20usize..24usize]).unwrap()
    }
    pub fn set_max_bytes(&mut self, value: i32) {
        self.buf[20usize..24usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn dist_delay(&self) -> i64 {
        parse_i64(&self.buf[24usize..32usize]).unwrap()
    }
    pub fn set_dist_delay(&mut self, value: i64) {
        self.buf[24usize..32usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn dist_jitter(&self) -> i64 {
        parse_i64(&self.buf[32usize..40usize]).unwrap()
    }
    pub fn set_dist_jitter(&mut self, value: i64) {
        self.buf[32usize..40usize].copy_from_slice(&value.to_ne_bytes())
    }
}
impl std::fmt::Debug for PushTcNetemSlot {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("TcNetemSlot")
            .field("min_delay", &self.min_delay())
            .field("max_delay", &self.max_delay())
            .field("max_packets", &self.max_packets())
            .field("max_bytes", &self.max_bytes())
            .field("dist_delay", &self.dist_delay())
            .field("dist_jitter", &self.dist_jitter())
            .finish()
    }
}
#[doc = "Original name: \"tc-plug-qopt\""]
#[derive(Clone)]
pub struct PushTcPlugQopt {
    pub(crate) buf: [u8; 8usize],
}
impl PushTcPlugQopt {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        8usize
    }
    pub fn action(&self) -> i32 {
        parse_i32(&self.buf[0usize..4usize]).unwrap()
    }
    pub fn set_action(&mut self, value: i32) {
        self.buf[0usize..4usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn limit(&self) -> u32 {
        parse_u32(&self.buf[4usize..8usize]).unwrap()
    }
    pub fn set_limit(&mut self, value: u32) {
        self.buf[4usize..8usize].copy_from_slice(&value.to_ne_bytes())
    }
}
impl std::fmt::Debug for PushTcPlugQopt {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("TcPlugQopt")
            .field("action", &self.action())
            .field("limit", &self.limit())
            .finish()
    }
}
#[doc = "Original name: \"tc-prio-qopt\""]
#[derive(Clone)]
pub struct PushTcPrioQopt {
    pub(crate) buf: [u8; 4usize],
}
impl PushTcPrioQopt {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        4usize
    }
    #[doc = "Number of bands"]
    pub fn bands(&self) -> u32 {
        parse_u32(&self.buf[0usize..4usize]).unwrap()
    }
    #[doc = "Number of bands"]
    pub fn set_bands(&mut self, value: u32) {
        self.buf[0usize..4usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Map of logical priority -> PRIO band"]
    pub fn priomap(&self) -> [u8; 16usize] {
        self.buf[4usize..20usize].try_into().unwrap()
    }
    #[doc = "Map of logical priority -> PRIO band"]
    pub fn set_priomap(&mut self, value: [u8; 16usize]) {
        self.buf[4usize..20usize].copy_from_slice(&value)
    }
}
impl std::fmt::Debug for PushTcPrioQopt {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("TcPrioQopt")
            .field("bands", &self.bands())
            .field("priomap", &self.priomap())
            .finish()
    }
}
#[doc = "Original name: \"tc-red-qopt\""]
#[derive(Clone)]
pub struct PushTcRedQopt {
    pub(crate) buf: [u8; 16usize],
}
impl PushTcRedQopt {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        16usize
    }
    #[doc = "Hard queue length in packets"]
    pub fn limit(&self) -> u32 {
        parse_u32(&self.buf[0usize..4usize]).unwrap()
    }
    #[doc = "Hard queue length in packets"]
    pub fn set_limit(&mut self, value: u32) {
        self.buf[0usize..4usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Min average threshold in packets"]
    pub fn qth_min(&self) -> u32 {
        parse_u32(&self.buf[4usize..8usize]).unwrap()
    }
    #[doc = "Min average threshold in packets"]
    pub fn set_qth_min(&mut self, value: u32) {
        self.buf[4usize..8usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Max average threshold in packets"]
    pub fn qth_max(&self) -> u32 {
        parse_u32(&self.buf[8usize..12usize]).unwrap()
    }
    #[doc = "Max average threshold in packets"]
    pub fn set_qth_max(&mut self, value: u32) {
        self.buf[8usize..12usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "log(W)"]
    pub fn Wlog(&self) -> u8 {
        parse_u8(&self.buf[12usize..13usize]).unwrap()
    }
    #[doc = "log(W)"]
    pub fn set_Wlog(&mut self, value: u8) {
        self.buf[12usize..13usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "log(P_max / (qth-max - qth-min))"]
    pub fn Plog(&self) -> u8 {
        parse_u8(&self.buf[13usize..14usize]).unwrap()
    }
    #[doc = "log(P_max / (qth-max - qth-min))"]
    pub fn set_Plog(&mut self, value: u8) {
        self.buf[13usize..14usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Cell size for idle damping"]
    pub fn Scell_log(&self) -> u8 {
        parse_u8(&self.buf[14usize..15usize]).unwrap()
    }
    #[doc = "Cell size for idle damping"]
    pub fn set_Scell_log(&mut self, value: u8) {
        self.buf[14usize..15usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn flags(&self) -> u8 {
        parse_u8(&self.buf[15usize..16usize]).unwrap()
    }
    pub fn set_flags(&mut self, value: u8) {
        self.buf[15usize..16usize].copy_from_slice(&value.to_ne_bytes())
    }
}
impl std::fmt::Debug for PushTcRedQopt {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("TcRedQopt")
            .field("limit", &self.limit())
            .field("qth_min", &self.qth_min())
            .field("qth_max", &self.qth_max())
            .field("Wlog", &self.Wlog())
            .field("Plog", &self.Plog())
            .field("Scell_log", &self.Scell_log())
            .field("flags", &self.flags())
            .finish()
    }
}
#[doc = "Original name: \"tc-sfb-qopt\""]
#[derive(Clone)]
pub struct PushTcSfbQopt {
    pub(crate) buf: [u8; 36usize],
}
impl PushTcSfbQopt {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        36usize
    }
    pub fn rehash_interval(&self) -> u32 {
        parse_u32(&self.buf[0usize..4usize]).unwrap()
    }
    pub fn set_rehash_interval(&mut self, value: u32) {
        self.buf[0usize..4usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn warmup_time(&self) -> u32 {
        parse_u32(&self.buf[4usize..8usize]).unwrap()
    }
    pub fn set_warmup_time(&mut self, value: u32) {
        self.buf[4usize..8usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn max(&self) -> u32 {
        parse_u32(&self.buf[8usize..12usize]).unwrap()
    }
    pub fn set_max(&mut self, value: u32) {
        self.buf[8usize..12usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn bin_size(&self) -> u32 {
        parse_u32(&self.buf[12usize..16usize]).unwrap()
    }
    pub fn set_bin_size(&mut self, value: u32) {
        self.buf[12usize..16usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn increment(&self) -> u32 {
        parse_u32(&self.buf[16usize..20usize]).unwrap()
    }
    pub fn set_increment(&mut self, value: u32) {
        self.buf[16usize..20usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn decrement(&self) -> u32 {
        parse_u32(&self.buf[20usize..24usize]).unwrap()
    }
    pub fn set_decrement(&mut self, value: u32) {
        self.buf[20usize..24usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn limit(&self) -> u32 {
        parse_u32(&self.buf[24usize..28usize]).unwrap()
    }
    pub fn set_limit(&mut self, value: u32) {
        self.buf[24usize..28usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn penalty_rate(&self) -> u32 {
        parse_u32(&self.buf[28usize..32usize]).unwrap()
    }
    pub fn set_penalty_rate(&mut self, value: u32) {
        self.buf[28usize..32usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn penalty_burst(&self) -> u32 {
        parse_u32(&self.buf[32usize..36usize]).unwrap()
    }
    pub fn set_penalty_burst(&mut self, value: u32) {
        self.buf[32usize..36usize].copy_from_slice(&value.to_ne_bytes())
    }
}
impl std::fmt::Debug for PushTcSfbQopt {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("TcSfbQopt")
            .field("rehash_interval", &self.rehash_interval())
            .field("warmup_time", &self.warmup_time())
            .field("max", &self.max())
            .field("bin_size", &self.bin_size())
            .field("increment", &self.increment())
            .field("decrement", &self.decrement())
            .field("limit", &self.limit())
            .field("penalty_rate", &self.penalty_rate())
            .field("penalty_burst", &self.penalty_burst())
            .finish()
    }
}
#[doc = "Original name: \"tc-sfq-qopt\""]
#[derive(Clone)]
pub struct PushTcSfqQopt {
    pub(crate) buf: [u8; 20usize],
}
impl PushTcSfqQopt {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        20usize
    }
    #[doc = "Bytes per round allocated to flow"]
    pub fn quantum(&self) -> u32 {
        parse_u32(&self.buf[0usize..4usize]).unwrap()
    }
    #[doc = "Bytes per round allocated to flow"]
    pub fn set_quantum(&mut self, value: u32) {
        self.buf[0usize..4usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Period of hash perturbation"]
    pub fn perturb_period(&self) -> i32 {
        parse_i32(&self.buf[4usize..8usize]).unwrap()
    }
    #[doc = "Period of hash perturbation"]
    pub fn set_perturb_period(&mut self, value: i32) {
        self.buf[4usize..8usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Maximal packets in queue"]
    pub fn limit(&self) -> u32 {
        parse_u32(&self.buf[8usize..12usize]).unwrap()
    }
    #[doc = "Maximal packets in queue"]
    pub fn set_limit(&mut self, value: u32) {
        self.buf[8usize..12usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Hash divisor"]
    pub fn divisor(&self) -> u32 {
        parse_u32(&self.buf[12usize..16usize]).unwrap()
    }
    #[doc = "Hash divisor"]
    pub fn set_divisor(&mut self, value: u32) {
        self.buf[12usize..16usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Maximal number of flows"]
    pub fn flows(&self) -> u32 {
        parse_u32(&self.buf[16usize..20usize]).unwrap()
    }
    #[doc = "Maximal number of flows"]
    pub fn set_flows(&mut self, value: u32) {
        self.buf[16usize..20usize].copy_from_slice(&value.to_ne_bytes())
    }
}
impl std::fmt::Debug for PushTcSfqQopt {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("TcSfqQopt")
            .field("quantum", &self.quantum())
            .field("perturb_period", &self.perturb_period())
            .field("limit", &self.limit())
            .field("divisor", &self.divisor())
            .field("flows", &self.flows())
            .finish()
    }
}
#[doc = "Original name: \"tc-sfqred-stats\""]
#[derive(Clone)]
pub struct PushTcSfqredStats {
    pub(crate) buf: [u8; 24usize],
}
impl PushTcSfqredStats {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        24usize
    }
    #[doc = "Early drops, below max threshold"]
    pub fn prob_drop(&self) -> u32 {
        parse_u32(&self.buf[0usize..4usize]).unwrap()
    }
    #[doc = "Early drops, below max threshold"]
    pub fn set_prob_drop(&mut self, value: u32) {
        self.buf[0usize..4usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Early drops, after max threshold"]
    pub fn forced_drop(&self) -> u32 {
        parse_u32(&self.buf[4usize..8usize]).unwrap()
    }
    #[doc = "Early drops, after max threshold"]
    pub fn set_forced_drop(&mut self, value: u32) {
        self.buf[4usize..8usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Marked packets, below max threshold"]
    pub fn prob_mark(&self) -> u32 {
        parse_u32(&self.buf[8usize..12usize]).unwrap()
    }
    #[doc = "Marked packets, below max threshold"]
    pub fn set_prob_mark(&mut self, value: u32) {
        self.buf[8usize..12usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Marked packets, after max threshold"]
    pub fn forced_mark(&self) -> u32 {
        parse_u32(&self.buf[12usize..16usize]).unwrap()
    }
    #[doc = "Marked packets, after max threshold"]
    pub fn set_forced_mark(&mut self, value: u32) {
        self.buf[12usize..16usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Marked packets, below max threshold"]
    pub fn prob_mark_head(&self) -> u32 {
        parse_u32(&self.buf[16usize..20usize]).unwrap()
    }
    #[doc = "Marked packets, below max threshold"]
    pub fn set_prob_mark_head(&mut self, value: u32) {
        self.buf[16usize..20usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Marked packets, after max threshold"]
    pub fn forced_mark_head(&self) -> u32 {
        parse_u32(&self.buf[20usize..24usize]).unwrap()
    }
    #[doc = "Marked packets, after max threshold"]
    pub fn set_forced_mark_head(&mut self, value: u32) {
        self.buf[20usize..24usize].copy_from_slice(&value.to_ne_bytes())
    }
}
impl std::fmt::Debug for PushTcSfqredStats {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("TcSfqredStats")
            .field("prob_drop", &self.prob_drop())
            .field("forced_drop", &self.forced_drop())
            .field("prob_mark", &self.prob_mark())
            .field("forced_mark", &self.forced_mark())
            .field("prob_mark_head", &self.prob_mark_head())
            .field("forced_mark_head", &self.forced_mark_head())
            .finish()
    }
}
#[doc = "Original name: \"tc-sfq-qopt-v1\""]
#[derive(Clone)]
pub struct PushTcSfqQoptV1 {
    pub(crate) buf: [u8; 28usize],
}
impl PushTcSfqQoptV1 {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        28usize
    }
    pub fn v0(&self) -> PushTcSfqQopt {
        PushTcSfqQopt::new_from_slice(&self.buf[0usize..20usize]).unwrap()
    }
    pub fn set_v0(&mut self, value: PushTcSfqQopt) {
        self.buf[0usize..20usize].copy_from_slice(&value.as_slice())
    }
    #[doc = "Maximum number of packets per flow"]
    pub fn depth(&self) -> u32 {
        parse_u32(&self.buf[0usize..4usize]).unwrap()
    }
    #[doc = "Maximum number of packets per flow"]
    pub fn set_depth(&mut self, value: u32) {
        self.buf[0usize..4usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn headdrop(&self) -> u32 {
        parse_u32(&self.buf[4usize..8usize]).unwrap()
    }
    pub fn set_headdrop(&mut self, value: u32) {
        self.buf[4usize..8usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "HARD maximal flow queue length in bytes"]
    pub fn limit(&self) -> u32 {
        parse_u32(&self.buf[8usize..12usize]).unwrap()
    }
    #[doc = "HARD maximal flow queue length in bytes"]
    pub fn set_limit(&mut self, value: u32) {
        self.buf[8usize..12usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Min average length threshold in bytes"]
    pub fn qth_min(&self) -> u32 {
        parse_u32(&self.buf[12usize..16usize]).unwrap()
    }
    #[doc = "Min average length threshold in bytes"]
    pub fn set_qth_min(&mut self, value: u32) {
        self.buf[12usize..16usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Max average length threshold in bytes"]
    pub fn qth_max(&self) -> u32 {
        parse_u32(&self.buf[16usize..20usize]).unwrap()
    }
    #[doc = "Max average length threshold in bytes"]
    pub fn set_qth_max(&mut self, value: u32) {
        self.buf[16usize..20usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "log(W)"]
    pub fn Wlog(&self) -> u8 {
        parse_u8(&self.buf[20usize..21usize]).unwrap()
    }
    #[doc = "log(W)"]
    pub fn set_Wlog(&mut self, value: u8) {
        self.buf[20usize..21usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "log(P_max / (qth-max - qth-min))"]
    pub fn Plog(&self) -> u8 {
        parse_u8(&self.buf[21usize..22usize]).unwrap()
    }
    #[doc = "log(P_max / (qth-max - qth-min))"]
    pub fn set_Plog(&mut self, value: u8) {
        self.buf[21usize..22usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Cell size for idle damping"]
    pub fn Scell_log(&self) -> u8 {
        parse_u8(&self.buf[22usize..23usize]).unwrap()
    }
    #[doc = "Cell size for idle damping"]
    pub fn set_Scell_log(&mut self, value: u8) {
        self.buf[22usize..23usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn flags(&self) -> u8 {
        parse_u8(&self.buf[23usize..24usize]).unwrap()
    }
    pub fn set_flags(&mut self, value: u8) {
        self.buf[23usize..24usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "probability, high resolution"]
    pub fn max_P(&self) -> u32 {
        parse_u32(&self.buf[24usize..28usize]).unwrap()
    }
    #[doc = "probability, high resolution"]
    pub fn set_max_P(&mut self, value: u32) {
        self.buf[24usize..28usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn stats(&self) -> PushTcSfqredStats {
        PushTcSfqredStats::new_from_slice(&self.buf[28usize..52usize]).unwrap()
    }
    pub fn set_stats(&mut self, value: PushTcSfqredStats) {
        self.buf[28usize..52usize].copy_from_slice(&value.as_slice())
    }
}
impl std::fmt::Debug for PushTcSfqQoptV1 {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("TcSfqQoptV1")
            .field("v0", &self.v0())
            .field("depth", &self.depth())
            .field("headdrop", &self.headdrop())
            .field("limit", &self.limit())
            .field("qth_min", &self.qth_min())
            .field("qth_max", &self.qth_max())
            .field("Wlog", &self.Wlog())
            .field("Plog", &self.Plog())
            .field("Scell_log", &self.Scell_log())
            .field("flags", &self.flags())
            .field("max_P", &self.max_P())
            .field("stats", &self.stats())
            .finish()
    }
}
#[doc = "Original name: \"tc-ratespec\""]
#[derive(Clone)]
pub struct PushTcRatespec {
    pub(crate) buf: [u8; 12usize],
}
impl PushTcRatespec {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        12usize
    }
    pub fn cell_log(&self) -> u8 {
        parse_u8(&self.buf[0usize..1usize]).unwrap()
    }
    pub fn set_cell_log(&mut self, value: u8) {
        self.buf[0usize..1usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn linklayer(&self) -> u8 {
        parse_u8(&self.buf[1usize..2usize]).unwrap()
    }
    pub fn set_linklayer(&mut self, value: u8) {
        self.buf[1usize..2usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn overhead(&self) -> u8 {
        parse_u8(&self.buf[2usize..3usize]).unwrap()
    }
    pub fn set_overhead(&mut self, value: u8) {
        self.buf[2usize..3usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn cell_align(&self) -> u8 {
        parse_u8(&self.buf[3usize..4usize]).unwrap()
    }
    pub fn set_cell_align(&mut self, value: u8) {
        self.buf[3usize..4usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn mpu(&self) -> u8 {
        parse_u8(&self.buf[4usize..5usize]).unwrap()
    }
    pub fn set_mpu(&mut self, value: u8) {
        self.buf[4usize..5usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn rate(&self) -> u32 {
        parse_u32(&self.buf[8usize..12usize]).unwrap()
    }
    pub fn set_rate(&mut self, value: u32) {
        self.buf[8usize..12usize].copy_from_slice(&value.to_ne_bytes())
    }
}
impl std::fmt::Debug for PushTcRatespec {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("TcRatespec")
            .field("cell_log", &self.cell_log())
            .field("linklayer", &self.linklayer())
            .field("overhead", &self.overhead())
            .field("cell_align", &self.cell_align())
            .field("mpu", &self.mpu())
            .field("rate", &self.rate())
            .finish()
    }
}
#[doc = "Original name: \"tc-tbf-qopt\""]
#[derive(Clone)]
pub struct PushTcTbfQopt {
    pub(crate) buf: [u8; 12usize],
}
impl PushTcTbfQopt {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        12usize
    }
    pub fn rate(&self) -> PushTcRatespec {
        PushTcRatespec::new_from_slice(&self.buf[0usize..12usize]).unwrap()
    }
    pub fn set_rate(&mut self, value: PushTcRatespec) {
        self.buf[0usize..12usize].copy_from_slice(&value.as_slice())
    }
    pub fn peakrate(&self) -> PushTcRatespec {
        PushTcRatespec::new_from_slice(&self.buf[0usize..12usize]).unwrap()
    }
    pub fn set_peakrate(&mut self, value: PushTcRatespec) {
        self.buf[0usize..12usize].copy_from_slice(&value.as_slice())
    }
    pub fn limit(&self) -> u32 {
        parse_u32(&self.buf[0usize..4usize]).unwrap()
    }
    pub fn set_limit(&mut self, value: u32) {
        self.buf[0usize..4usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn buffer(&self) -> u32 {
        parse_u32(&self.buf[4usize..8usize]).unwrap()
    }
    pub fn set_buffer(&mut self, value: u32) {
        self.buf[4usize..8usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn mtu(&self) -> u32 {
        parse_u32(&self.buf[8usize..12usize]).unwrap()
    }
    pub fn set_mtu(&mut self, value: u32) {
        self.buf[8usize..12usize].copy_from_slice(&value.to_ne_bytes())
    }
}
impl std::fmt::Debug for PushTcTbfQopt {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("TcTbfQopt")
            .field("rate", &self.rate())
            .field("peakrate", &self.peakrate())
            .field("limit", &self.limit())
            .field("buffer", &self.buffer())
            .field("mtu", &self.mtu())
            .finish()
    }
}
#[doc = "Original name: \"tc-sizespec\""]
#[derive(Clone)]
pub struct PushTcSizespec {
    pub(crate) buf: [u8; 24usize],
}
impl PushTcSizespec {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        24usize
    }
    pub fn cell_log(&self) -> u8 {
        parse_u8(&self.buf[0usize..1usize]).unwrap()
    }
    pub fn set_cell_log(&mut self, value: u8) {
        self.buf[0usize..1usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn size_log(&self) -> u8 {
        parse_u8(&self.buf[1usize..2usize]).unwrap()
    }
    pub fn set_size_log(&mut self, value: u8) {
        self.buf[1usize..2usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn cell_align(&self) -> i16 {
        parse_i16(&self.buf[2usize..4usize]).unwrap()
    }
    pub fn set_cell_align(&mut self, value: i16) {
        self.buf[2usize..4usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn overhead(&self) -> i32 {
        parse_i32(&self.buf[4usize..8usize]).unwrap()
    }
    pub fn set_overhead(&mut self, value: i32) {
        self.buf[4usize..8usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn linklayer(&self) -> u32 {
        parse_u32(&self.buf[8usize..12usize]).unwrap()
    }
    pub fn set_linklayer(&mut self, value: u32) {
        self.buf[8usize..12usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn mpu(&self) -> u32 {
        parse_u32(&self.buf[12usize..16usize]).unwrap()
    }
    pub fn set_mpu(&mut self, value: u32) {
        self.buf[12usize..16usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn mtu(&self) -> u32 {
        parse_u32(&self.buf[16usize..20usize]).unwrap()
    }
    pub fn set_mtu(&mut self, value: u32) {
        self.buf[16usize..20usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn tsize(&self) -> u32 {
        parse_u32(&self.buf[20usize..24usize]).unwrap()
    }
    pub fn set_tsize(&mut self, value: u32) {
        self.buf[20usize..24usize].copy_from_slice(&value.to_ne_bytes())
    }
}
impl std::fmt::Debug for PushTcSizespec {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("TcSizespec")
            .field("cell_log", &self.cell_log())
            .field("size_log", &self.size_log())
            .field("cell_align", &self.cell_align())
            .field("overhead", &self.overhead())
            .field("linklayer", &self.linklayer())
            .field("mpu", &self.mpu())
            .field("mtu", &self.mtu())
            .field("tsize", &self.tsize())
            .finish()
    }
}
#[doc = "Original name: \"gnet-estimator\""]
#[derive(Clone)]
pub struct PushGnetEstimator {
    pub(crate) buf: [u8; 2usize],
}
impl PushGnetEstimator {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        2usize
    }
    #[doc = "Sampling period"]
    pub fn interval(&self) -> i8 {
        parse_i8(&self.buf[0usize..1usize]).unwrap()
    }
    #[doc = "Sampling period"]
    pub fn set_interval(&mut self, value: i8) {
        self.buf[0usize..1usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "The log() of measurement window weight"]
    pub fn ewma_log(&self) -> u8 {
        parse_u8(&self.buf[1usize..2usize]).unwrap()
    }
    #[doc = "The log() of measurement window weight"]
    pub fn set_ewma_log(&mut self, value: u8) {
        self.buf[1usize..2usize].copy_from_slice(&value.to_ne_bytes())
    }
}
impl std::fmt::Debug for PushGnetEstimator {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("GnetEstimator")
            .field("interval", &self.interval())
            .field("ewma_log", &self.ewma_log())
            .finish()
    }
}
#[doc = "Original name: \"tc-choke-xstats\""]
#[derive(Clone)]
pub struct PushTcChokeXstats {
    pub(crate) buf: [u8; 20usize],
}
impl PushTcChokeXstats {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        20usize
    }
    #[doc = "Early drops"]
    pub fn early(&self) -> u32 {
        parse_u32(&self.buf[0usize..4usize]).unwrap()
    }
    #[doc = "Early drops"]
    pub fn set_early(&mut self, value: u32) {
        self.buf[0usize..4usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Drops due to queue limits"]
    pub fn pdrop(&self) -> u32 {
        parse_u32(&self.buf[4usize..8usize]).unwrap()
    }
    #[doc = "Drops due to queue limits"]
    pub fn set_pdrop(&mut self, value: u32) {
        self.buf[4usize..8usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Drops due to drop() calls"]
    pub fn other(&self) -> u32 {
        parse_u32(&self.buf[8usize..12usize]).unwrap()
    }
    #[doc = "Drops due to drop() calls"]
    pub fn set_other(&mut self, value: u32) {
        self.buf[8usize..12usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Marked packets"]
    pub fn marked(&self) -> u32 {
        parse_u32(&self.buf[12usize..16usize]).unwrap()
    }
    #[doc = "Marked packets"]
    pub fn set_marked(&mut self, value: u32) {
        self.buf[12usize..16usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Drops due to flow match"]
    pub fn matched(&self) -> u32 {
        parse_u32(&self.buf[16usize..20usize]).unwrap()
    }
    #[doc = "Drops due to flow match"]
    pub fn set_matched(&mut self, value: u32) {
        self.buf[16usize..20usize].copy_from_slice(&value.to_ne_bytes())
    }
}
impl std::fmt::Debug for PushTcChokeXstats {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("TcChokeXstats")
            .field("early", &self.early())
            .field("pdrop", &self.pdrop())
            .field("other", &self.other())
            .field("marked", &self.marked())
            .field("matched", &self.matched())
            .finish()
    }
}
#[doc = "Original name: \"tc-codel-xstats\""]
#[derive(Clone)]
pub struct PushTcCodelXstats {
    pub(crate) buf: [u8; 36usize],
}
impl PushTcCodelXstats {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        36usize
    }
    #[doc = "Largest packet we've seen so far"]
    pub fn maxpacket(&self) -> u32 {
        parse_u32(&self.buf[0usize..4usize]).unwrap()
    }
    #[doc = "Largest packet we've seen so far"]
    pub fn set_maxpacket(&mut self, value: u32) {
        self.buf[0usize..4usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "How many drops we've done since the last time we entered dropping\nstate\n"]
    pub fn count(&self) -> u32 {
        parse_u32(&self.buf[4usize..8usize]).unwrap()
    }
    #[doc = "How many drops we've done since the last time we entered dropping\nstate\n"]
    pub fn set_count(&mut self, value: u32) {
        self.buf[4usize..8usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Count at entry to dropping state"]
    pub fn lastcount(&self) -> u32 {
        parse_u32(&self.buf[8usize..12usize]).unwrap()
    }
    #[doc = "Count at entry to dropping state"]
    pub fn set_lastcount(&mut self, value: u32) {
        self.buf[8usize..12usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "in-queue delay seen by most recently dequeued packet"]
    pub fn ldelay(&self) -> u32 {
        parse_u32(&self.buf[12usize..16usize]).unwrap()
    }
    #[doc = "in-queue delay seen by most recently dequeued packet"]
    pub fn set_ldelay(&mut self, value: u32) {
        self.buf[12usize..16usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Time to drop next packet"]
    pub fn drop_next(&self) -> i32 {
        parse_i32(&self.buf[16usize..20usize]).unwrap()
    }
    #[doc = "Time to drop next packet"]
    pub fn set_drop_next(&mut self, value: i32) {
        self.buf[16usize..20usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Number of times max qdisc packet limit was hit"]
    pub fn drop_overlimit(&self) -> u32 {
        parse_u32(&self.buf[20usize..24usize]).unwrap()
    }
    #[doc = "Number of times max qdisc packet limit was hit"]
    pub fn set_drop_overlimit(&mut self, value: u32) {
        self.buf[20usize..24usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Number of packets we've ECN marked instead of dropped"]
    pub fn ecn_mark(&self) -> u32 {
        parse_u32(&self.buf[24usize..28usize]).unwrap()
    }
    #[doc = "Number of packets we've ECN marked instead of dropped"]
    pub fn set_ecn_mark(&mut self, value: u32) {
        self.buf[24usize..28usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Are we in a dropping state?"]
    pub fn dropping(&self) -> u32 {
        parse_u32(&self.buf[28usize..32usize]).unwrap()
    }
    #[doc = "Are we in a dropping state?"]
    pub fn set_dropping(&mut self, value: u32) {
        self.buf[28usize..32usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Number of CE marked packets because of ce-threshold"]
    pub fn ce_mark(&self) -> u32 {
        parse_u32(&self.buf[32usize..36usize]).unwrap()
    }
    #[doc = "Number of CE marked packets because of ce-threshold"]
    pub fn set_ce_mark(&mut self, value: u32) {
        self.buf[32usize..36usize].copy_from_slice(&value.to_ne_bytes())
    }
}
impl std::fmt::Debug for PushTcCodelXstats {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("TcCodelXstats")
            .field("maxpacket", &self.maxpacket())
            .field("count", &self.count())
            .field("lastcount", &self.lastcount())
            .field("ldelay", &self.ldelay())
            .field("drop_next", &self.drop_next())
            .field("drop_overlimit", &self.drop_overlimit())
            .field("ecn_mark", &self.ecn_mark())
            .field("dropping", &self.dropping())
            .field("ce_mark", &self.ce_mark())
            .finish()
    }
}
#[doc = "Original name: \"tc-fq-codel-xstats\""]
#[derive(Clone)]
pub struct PushTcFqCodelXstats {
    pub(crate) buf: [u8; 40usize],
}
impl PushTcFqCodelXstats {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        40usize
    }
    pub fn get_type(&self) -> u32 {
        parse_u32(&self.buf[0usize..4usize]).unwrap()
    }
    pub fn set_type(&mut self, value: u32) {
        self.buf[0usize..4usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Largest packet we've seen so far"]
    pub fn maxpacket(&self) -> u32 {
        parse_u32(&self.buf[4usize..8usize]).unwrap()
    }
    #[doc = "Largest packet we've seen so far"]
    pub fn set_maxpacket(&mut self, value: u32) {
        self.buf[4usize..8usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Number of times max qdisc packet limit was hit"]
    pub fn drop_overlimit(&self) -> u32 {
        parse_u32(&self.buf[8usize..12usize]).unwrap()
    }
    #[doc = "Number of times max qdisc packet limit was hit"]
    pub fn set_drop_overlimit(&mut self, value: u32) {
        self.buf[8usize..12usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Number of packets we ECN marked instead of being dropped"]
    pub fn ecn_mark(&self) -> u32 {
        parse_u32(&self.buf[12usize..16usize]).unwrap()
    }
    #[doc = "Number of packets we ECN marked instead of being dropped"]
    pub fn set_ecn_mark(&mut self, value: u32) {
        self.buf[12usize..16usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Number of times packets created a new flow"]
    pub fn new_flow_count(&self) -> u32 {
        parse_u32(&self.buf[16usize..20usize]).unwrap()
    }
    #[doc = "Number of times packets created a new flow"]
    pub fn set_new_flow_count(&mut self, value: u32) {
        self.buf[16usize..20usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Count of flows in new list"]
    pub fn new_flows_len(&self) -> u32 {
        parse_u32(&self.buf[20usize..24usize]).unwrap()
    }
    #[doc = "Count of flows in new list"]
    pub fn set_new_flows_len(&mut self, value: u32) {
        self.buf[20usize..24usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Count of flows in old list"]
    pub fn old_flows_len(&self) -> u32 {
        parse_u32(&self.buf[24usize..28usize]).unwrap()
    }
    #[doc = "Count of flows in old list"]
    pub fn set_old_flows_len(&mut self, value: u32) {
        self.buf[24usize..28usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Packets above ce-threshold"]
    pub fn ce_mark(&self) -> u32 {
        parse_u32(&self.buf[28usize..32usize]).unwrap()
    }
    #[doc = "Packets above ce-threshold"]
    pub fn set_ce_mark(&mut self, value: u32) {
        self.buf[28usize..32usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Memory usage in bytes"]
    pub fn memory_usage(&self) -> u32 {
        parse_u32(&self.buf[32usize..36usize]).unwrap()
    }
    #[doc = "Memory usage in bytes"]
    pub fn set_memory_usage(&mut self, value: u32) {
        self.buf[32usize..36usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn drop_overmemory(&self) -> u32 {
        parse_u32(&self.buf[36usize..40usize]).unwrap()
    }
    pub fn set_drop_overmemory(&mut self, value: u32) {
        self.buf[36usize..40usize].copy_from_slice(&value.to_ne_bytes())
    }
}
impl std::fmt::Debug for PushTcFqCodelXstats {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("TcFqCodelXstats")
            .field("type", &self.get_type())
            .field("maxpacket", &self.maxpacket())
            .field("drop_overlimit", &self.drop_overlimit())
            .field("ecn_mark", &self.ecn_mark())
            .field("new_flow_count", &self.new_flow_count())
            .field("new_flows_len", &self.new_flows_len())
            .field("old_flows_len", &self.old_flows_len())
            .field("ce_mark", &self.ce_mark())
            .field("memory_usage", &self.memory_usage())
            .field("drop_overmemory", &self.drop_overmemory())
            .finish()
    }
}
#[doc = "Original name: \"tc-dualpi2-xstats\""]
#[derive(Clone)]
pub struct PushTcDualpi2Xstats {
    pub(crate) buf: [u8; 48usize],
}
impl PushTcDualpi2Xstats {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        48usize
    }
    #[doc = "Current base PI probability"]
    pub fn prob(&self) -> u32 {
        parse_u32(&self.buf[0usize..4usize]).unwrap()
    }
    #[doc = "Current base PI probability"]
    pub fn set_prob(&mut self, value: u32) {
        self.buf[0usize..4usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Current C-queue delay in microseconds"]
    pub fn delay_c(&self) -> u32 {
        parse_u32(&self.buf[4usize..8usize]).unwrap()
    }
    #[doc = "Current C-queue delay in microseconds"]
    pub fn set_delay_c(&mut self, value: u32) {
        self.buf[4usize..8usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Current L-queue delay in microseconds"]
    pub fn delay_l(&self) -> u32 {
        parse_u32(&self.buf[8usize..12usize]).unwrap()
    }
    #[doc = "Current L-queue delay in microseconds"]
    pub fn set_delay_l(&mut self, value: u32) {
        self.buf[8usize..12usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Number of packets enqueued in the C-queue"]
    pub fn pkts_in_c(&self) -> u32 {
        parse_u32(&self.buf[12usize..16usize]).unwrap()
    }
    #[doc = "Number of packets enqueued in the C-queue"]
    pub fn set_pkts_in_c(&mut self, value: u32) {
        self.buf[12usize..16usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Number of packets enqueued in the L-queue"]
    pub fn pkts_in_l(&self) -> u32 {
        parse_u32(&self.buf[16usize..20usize]).unwrap()
    }
    #[doc = "Number of packets enqueued in the L-queue"]
    pub fn set_pkts_in_l(&mut self, value: u32) {
        self.buf[16usize..20usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Maximum number of packets seen by the DualPI2"]
    pub fn maxq(&self) -> u32 {
        parse_u32(&self.buf[20usize..24usize]).unwrap()
    }
    #[doc = "Maximum number of packets seen by the DualPI2"]
    pub fn set_maxq(&mut self, value: u32) {
        self.buf[20usize..24usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "All packets marked with ECN"]
    pub fn ecn_mark(&self) -> u32 {
        parse_u32(&self.buf[24usize..28usize]).unwrap()
    }
    #[doc = "All packets marked with ECN"]
    pub fn set_ecn_mark(&mut self, value: u32) {
        self.buf[24usize..28usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Only packets marked with ECN due to L-queue step AQM"]
    pub fn step_mark(&self) -> u32 {
        parse_u32(&self.buf[28usize..32usize]).unwrap()
    }
    #[doc = "Only packets marked with ECN due to L-queue step AQM"]
    pub fn set_step_mark(&mut self, value: u32) {
        self.buf[28usize..32usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Current credit value for WRR"]
    pub fn credit(&self) -> i32 {
        parse_i32(&self.buf[32usize..36usize]).unwrap()
    }
    #[doc = "Current credit value for WRR"]
    pub fn set_credit(&mut self, value: i32) {
        self.buf[32usize..36usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Memory used in bytes by the DualPI2"]
    pub fn memory_used(&self) -> u32 {
        parse_u32(&self.buf[36usize..40usize]).unwrap()
    }
    #[doc = "Memory used in bytes by the DualPI2"]
    pub fn set_memory_used(&mut self, value: u32) {
        self.buf[36usize..40usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Maximum memory used in bytes by the DualPI2"]
    pub fn max_memory_used(&self) -> u32 {
        parse_u32(&self.buf[40usize..44usize]).unwrap()
    }
    #[doc = "Maximum memory used in bytes by the DualPI2"]
    pub fn set_max_memory_used(&mut self, value: u32) {
        self.buf[40usize..44usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Memory limit in bytes"]
    pub fn memory_limit(&self) -> u32 {
        parse_u32(&self.buf[44usize..48usize]).unwrap()
    }
    #[doc = "Memory limit in bytes"]
    pub fn set_memory_limit(&mut self, value: u32) {
        self.buf[44usize..48usize].copy_from_slice(&value.to_ne_bytes())
    }
}
impl std::fmt::Debug for PushTcDualpi2Xstats {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("TcDualpi2Xstats")
            .field("prob", &self.prob())
            .field("delay_c", &self.delay_c())
            .field("delay_l", &self.delay_l())
            .field("pkts_in_c", &self.pkts_in_c())
            .field("pkts_in_l", &self.pkts_in_l())
            .field("maxq", &self.maxq())
            .field("ecn_mark", &self.ecn_mark())
            .field("step_mark", &self.step_mark())
            .field("credit", &self.credit())
            .field("memory_used", &self.memory_used())
            .field("max_memory_used", &self.max_memory_used())
            .field("memory_limit", &self.memory_limit())
            .finish()
    }
}
#[doc = "Original name: \"tc-fq-pie-xstats\""]
#[derive(Clone)]
pub struct PushTcFqPieXstats {
    pub(crate) buf: [u8; 36usize],
}
impl PushTcFqPieXstats {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        36usize
    }
    #[doc = "Total number of packets enqueued"]
    pub fn packets_in(&self) -> u32 {
        parse_u32(&self.buf[0usize..4usize]).unwrap()
    }
    #[doc = "Total number of packets enqueued"]
    pub fn set_packets_in(&mut self, value: u32) {
        self.buf[0usize..4usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Packets dropped due to fq_pie_action"]
    pub fn dropped(&self) -> u32 {
        parse_u32(&self.buf[4usize..8usize]).unwrap()
    }
    #[doc = "Packets dropped due to fq_pie_action"]
    pub fn set_dropped(&mut self, value: u32) {
        self.buf[4usize..8usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Dropped due to lack of space in queue"]
    pub fn overlimit(&self) -> u32 {
        parse_u32(&self.buf[8usize..12usize]).unwrap()
    }
    #[doc = "Dropped due to lack of space in queue"]
    pub fn set_overlimit(&mut self, value: u32) {
        self.buf[8usize..12usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Dropped due to lack of memory in queue"]
    pub fn overmemory(&self) -> u32 {
        parse_u32(&self.buf[12usize..16usize]).unwrap()
    }
    #[doc = "Dropped due to lack of memory in queue"]
    pub fn set_overmemory(&mut self, value: u32) {
        self.buf[12usize..16usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Packets marked with ECN"]
    pub fn ecn_mark(&self) -> u32 {
        parse_u32(&self.buf[16usize..20usize]).unwrap()
    }
    #[doc = "Packets marked with ECN"]
    pub fn set_ecn_mark(&mut self, value: u32) {
        self.buf[16usize..20usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Count of new flows created by packets"]
    pub fn new_flow_count(&self) -> u32 {
        parse_u32(&self.buf[20usize..24usize]).unwrap()
    }
    #[doc = "Count of new flows created by packets"]
    pub fn set_new_flow_count(&mut self, value: u32) {
        self.buf[20usize..24usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Count of flows in new list"]
    pub fn new_flows_len(&self) -> u32 {
        parse_u32(&self.buf[24usize..28usize]).unwrap()
    }
    #[doc = "Count of flows in new list"]
    pub fn set_new_flows_len(&mut self, value: u32) {
        self.buf[24usize..28usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Count of flows in old list"]
    pub fn old_flows_len(&self) -> u32 {
        parse_u32(&self.buf[28usize..32usize]).unwrap()
    }
    #[doc = "Count of flows in old list"]
    pub fn set_old_flows_len(&mut self, value: u32) {
        self.buf[28usize..32usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Total memory across all queues"]
    pub fn memory_usage(&self) -> u32 {
        parse_u32(&self.buf[32usize..36usize]).unwrap()
    }
    #[doc = "Total memory across all queues"]
    pub fn set_memory_usage(&mut self, value: u32) {
        self.buf[32usize..36usize].copy_from_slice(&value.to_ne_bytes())
    }
}
impl std::fmt::Debug for PushTcFqPieXstats {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("TcFqPieXstats")
            .field("packets_in", &self.packets_in())
            .field("dropped", &self.dropped())
            .field("overlimit", &self.overlimit())
            .field("overmemory", &self.overmemory())
            .field("ecn_mark", &self.ecn_mark())
            .field("new_flow_count", &self.new_flow_count())
            .field("new_flows_len", &self.new_flows_len())
            .field("old_flows_len", &self.old_flows_len())
            .field("memory_usage", &self.memory_usage())
            .finish()
    }
}
#[doc = "Original name: \"tc-fq-qd-stats\""]
#[derive(Clone)]
pub struct PushTcFqQdStats {
    pub(crate) buf: [u8; 120usize],
}
impl PushTcFqQdStats {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        120usize
    }
    pub fn gc_flows(&self) -> u64 {
        parse_u64(&self.buf[0usize..8usize]).unwrap()
    }
    pub fn set_gc_flows(&mut self, value: u64) {
        self.buf[0usize..8usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "obsolete"]
    pub fn highprio_packets(&self) -> u64 {
        parse_u64(&self.buf[8usize..16usize]).unwrap()
    }
    #[doc = "obsolete"]
    pub fn set_highprio_packets(&mut self, value: u64) {
        self.buf[8usize..16usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "obsolete"]
    pub fn tcp_retrans(&self) -> u64 {
        parse_u64(&self.buf[16usize..24usize]).unwrap()
    }
    #[doc = "obsolete"]
    pub fn set_tcp_retrans(&mut self, value: u64) {
        self.buf[16usize..24usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn throttled(&self) -> u64 {
        parse_u64(&self.buf[24usize..32usize]).unwrap()
    }
    pub fn set_throttled(&mut self, value: u64) {
        self.buf[24usize..32usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn flows_plimit(&self) -> u64 {
        parse_u64(&self.buf[32usize..40usize]).unwrap()
    }
    pub fn set_flows_plimit(&mut self, value: u64) {
        self.buf[32usize..40usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn pkts_too_long(&self) -> u64 {
        parse_u64(&self.buf[40usize..48usize]).unwrap()
    }
    pub fn set_pkts_too_long(&mut self, value: u64) {
        self.buf[40usize..48usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn allocation_errors(&self) -> u64 {
        parse_u64(&self.buf[48usize..56usize]).unwrap()
    }
    pub fn set_allocation_errors(&mut self, value: u64) {
        self.buf[48usize..56usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn time_next_delayed_flow(&self) -> i64 {
        parse_i64(&self.buf[56usize..64usize]).unwrap()
    }
    pub fn set_time_next_delayed_flow(&mut self, value: i64) {
        self.buf[56usize..64usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn flows(&self) -> u32 {
        parse_u32(&self.buf[64usize..68usize]).unwrap()
    }
    pub fn set_flows(&mut self, value: u32) {
        self.buf[64usize..68usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn inactive_flows(&self) -> u32 {
        parse_u32(&self.buf[68usize..72usize]).unwrap()
    }
    pub fn set_inactive_flows(&mut self, value: u32) {
        self.buf[68usize..72usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn throttled_flows(&self) -> u32 {
        parse_u32(&self.buf[72usize..76usize]).unwrap()
    }
    pub fn set_throttled_flows(&mut self, value: u32) {
        self.buf[72usize..76usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn unthrottle_latency_ns(&self) -> u32 {
        parse_u32(&self.buf[76usize..80usize]).unwrap()
    }
    pub fn set_unthrottle_latency_ns(&mut self, value: u32) {
        self.buf[76usize..80usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Packets above ce-threshold"]
    pub fn ce_mark(&self) -> u64 {
        parse_u64(&self.buf[80usize..88usize]).unwrap()
    }
    #[doc = "Packets above ce-threshold"]
    pub fn set_ce_mark(&mut self, value: u64) {
        self.buf[80usize..88usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn horizon_drops(&self) -> u64 {
        parse_u64(&self.buf[88usize..96usize]).unwrap()
    }
    pub fn set_horizon_drops(&mut self, value: u64) {
        self.buf[88usize..96usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn horizon_caps(&self) -> u64 {
        parse_u64(&self.buf[96usize..104usize]).unwrap()
    }
    pub fn set_horizon_caps(&mut self, value: u64) {
        self.buf[96usize..104usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn fastpath_packets(&self) -> u64 {
        parse_u64(&self.buf[104usize..112usize]).unwrap()
    }
    pub fn set_fastpath_packets(&mut self, value: u64) {
        self.buf[104usize..112usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn band_drops(&self) -> [u8; 24usize] {
        self.buf[112usize..136usize].try_into().unwrap()
    }
    pub fn set_band_drops(&mut self, value: [u8; 24usize]) {
        self.buf[112usize..136usize].copy_from_slice(&value)
    }
    pub fn band_pkt_count(&self) -> [u8; 12usize] {
        self.buf[112usize..124usize].try_into().unwrap()
    }
    pub fn set_band_pkt_count(&mut self, value: [u8; 12usize]) {
        self.buf[112usize..124usize].copy_from_slice(&value)
    }
}
impl std::fmt::Debug for PushTcFqQdStats {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("TcFqQdStats")
            .field("gc_flows", &self.gc_flows())
            .field("highprio_packets", &self.highprio_packets())
            .field("tcp_retrans", &self.tcp_retrans())
            .field("throttled", &self.throttled())
            .field("flows_plimit", &self.flows_plimit())
            .field("pkts_too_long", &self.pkts_too_long())
            .field("allocation_errors", &self.allocation_errors())
            .field("time_next_delayed_flow", &self.time_next_delayed_flow())
            .field("flows", &self.flows())
            .field("inactive_flows", &self.inactive_flows())
            .field("throttled_flows", &self.throttled_flows())
            .field("unthrottle_latency_ns", &self.unthrottle_latency_ns())
            .field("ce_mark", &self.ce_mark())
            .field("horizon_drops", &self.horizon_drops())
            .field("horizon_caps", &self.horizon_caps())
            .field("fastpath_packets", &self.fastpath_packets())
            .field("band_drops", &self.band_drops())
            .field("band_pkt_count", &self.band_pkt_count())
            .finish()
    }
}
#[doc = "Original name: \"tc-hhf-xstats\""]
#[derive(Clone)]
pub struct PushTcHhfXstats {
    pub(crate) buf: [u8; 16usize],
}
impl PushTcHhfXstats {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        16usize
    }
    #[doc = "Number of times max qdisc packet limit was hit"]
    pub fn drop_overlimit(&self) -> u32 {
        parse_u32(&self.buf[0usize..4usize]).unwrap()
    }
    #[doc = "Number of times max qdisc packet limit was hit"]
    pub fn set_drop_overlimit(&mut self, value: u32) {
        self.buf[0usize..4usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Number of times max heavy-hitters was hit"]
    pub fn hh_overlimit(&self) -> u32 {
        parse_u32(&self.buf[4usize..8usize]).unwrap()
    }
    #[doc = "Number of times max heavy-hitters was hit"]
    pub fn set_hh_overlimit(&mut self, value: u32) {
        self.buf[4usize..8usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Number of captured heavy-hitters so far"]
    pub fn hh_tot_count(&self) -> u32 {
        parse_u32(&self.buf[8usize..12usize]).unwrap()
    }
    #[doc = "Number of captured heavy-hitters so far"]
    pub fn set_hh_tot_count(&mut self, value: u32) {
        self.buf[8usize..12usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Number of current heavy-hitters"]
    pub fn hh_cur_count(&self) -> u32 {
        parse_u32(&self.buf[12usize..16usize]).unwrap()
    }
    #[doc = "Number of current heavy-hitters"]
    pub fn set_hh_cur_count(&mut self, value: u32) {
        self.buf[12usize..16usize].copy_from_slice(&value.to_ne_bytes())
    }
}
impl std::fmt::Debug for PushTcHhfXstats {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("TcHhfXstats")
            .field("drop_overlimit", &self.drop_overlimit())
            .field("hh_overlimit", &self.hh_overlimit())
            .field("hh_tot_count", &self.hh_tot_count())
            .field("hh_cur_count", &self.hh_cur_count())
            .finish()
    }
}
#[doc = "Original name: \"tc-pie-xstats\""]
#[derive(Clone)]
pub struct PushTcPieXstats {
    pub(crate) buf: [u8; 40usize],
}
impl PushTcPieXstats {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        40usize
    }
    #[doc = "Current probability"]
    pub fn prob(&self) -> u64 {
        parse_u64(&self.buf[0usize..8usize]).unwrap()
    }
    #[doc = "Current probability"]
    pub fn set_prob(&mut self, value: u64) {
        self.buf[0usize..8usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Current delay in ms"]
    pub fn delay(&self) -> u32 {
        parse_u32(&self.buf[8usize..12usize]).unwrap()
    }
    #[doc = "Current delay in ms"]
    pub fn set_delay(&mut self, value: u32) {
        self.buf[8usize..12usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Current average dq rate in bits/pie-time"]
    pub fn avg_dq_rate(&self) -> u32 {
        parse_u32(&self.buf[12usize..16usize]).unwrap()
    }
    #[doc = "Current average dq rate in bits/pie-time"]
    pub fn set_avg_dq_rate(&mut self, value: u32) {
        self.buf[12usize..16usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Is avg-dq-rate being calculated?"]
    pub fn dq_rate_estimating(&self) -> u32 {
        parse_u32(&self.buf[16usize..20usize]).unwrap()
    }
    #[doc = "Is avg-dq-rate being calculated?"]
    pub fn set_dq_rate_estimating(&mut self, value: u32) {
        self.buf[16usize..20usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Total number of packets enqueued"]
    pub fn packets_in(&self) -> u32 {
        parse_u32(&self.buf[20usize..24usize]).unwrap()
    }
    #[doc = "Total number of packets enqueued"]
    pub fn set_packets_in(&mut self, value: u32) {
        self.buf[20usize..24usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Packets dropped due to pie action"]
    pub fn dropped(&self) -> u32 {
        parse_u32(&self.buf[24usize..28usize]).unwrap()
    }
    #[doc = "Packets dropped due to pie action"]
    pub fn set_dropped(&mut self, value: u32) {
        self.buf[24usize..28usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Dropped due to lack of space in queue"]
    pub fn overlimit(&self) -> u32 {
        parse_u32(&self.buf[28usize..32usize]).unwrap()
    }
    #[doc = "Dropped due to lack of space in queue"]
    pub fn set_overlimit(&mut self, value: u32) {
        self.buf[28usize..32usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Maximum queue size"]
    pub fn maxq(&self) -> u32 {
        parse_u32(&self.buf[32usize..36usize]).unwrap()
    }
    #[doc = "Maximum queue size"]
    pub fn set_maxq(&mut self, value: u32) {
        self.buf[32usize..36usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Packets marked with ECN"]
    pub fn ecn_mark(&self) -> u32 {
        parse_u32(&self.buf[36usize..40usize]).unwrap()
    }
    #[doc = "Packets marked with ECN"]
    pub fn set_ecn_mark(&mut self, value: u32) {
        self.buf[36usize..40usize].copy_from_slice(&value.to_ne_bytes())
    }
}
impl std::fmt::Debug for PushTcPieXstats {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("TcPieXstats")
            .field("prob", &self.prob())
            .field("delay", &self.delay())
            .field("avg_dq_rate", &self.avg_dq_rate())
            .field("dq_rate_estimating", &self.dq_rate_estimating())
            .field("packets_in", &self.packets_in())
            .field("dropped", &self.dropped())
            .field("overlimit", &self.overlimit())
            .field("maxq", &self.maxq())
            .field("ecn_mark", &self.ecn_mark())
            .finish()
    }
}
#[doc = "Original name: \"tc-red-xstats\""]
#[derive(Clone)]
pub struct PushTcRedXstats {
    pub(crate) buf: [u8; 16usize],
}
impl PushTcRedXstats {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        16usize
    }
    #[doc = "Early drops"]
    pub fn early(&self) -> u32 {
        parse_u32(&self.buf[0usize..4usize]).unwrap()
    }
    #[doc = "Early drops"]
    pub fn set_early(&mut self, value: u32) {
        self.buf[0usize..4usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Drops due to queue limits"]
    pub fn pdrop(&self) -> u32 {
        parse_u32(&self.buf[4usize..8usize]).unwrap()
    }
    #[doc = "Drops due to queue limits"]
    pub fn set_pdrop(&mut self, value: u32) {
        self.buf[4usize..8usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Drops due to drop() calls"]
    pub fn other(&self) -> u32 {
        parse_u32(&self.buf[8usize..12usize]).unwrap()
    }
    #[doc = "Drops due to drop() calls"]
    pub fn set_other(&mut self, value: u32) {
        self.buf[8usize..12usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "Marked packets"]
    pub fn marked(&self) -> u32 {
        parse_u32(&self.buf[12usize..16usize]).unwrap()
    }
    #[doc = "Marked packets"]
    pub fn set_marked(&mut self, value: u32) {
        self.buf[12usize..16usize].copy_from_slice(&value.to_ne_bytes())
    }
}
impl std::fmt::Debug for PushTcRedXstats {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("TcRedXstats")
            .field("early", &self.early())
            .field("pdrop", &self.pdrop())
            .field("other", &self.other())
            .field("marked", &self.marked())
            .finish()
    }
}
#[doc = "Original name: \"tc-sfb-xstats\""]
#[derive(Clone)]
pub struct PushTcSfbXstats {
    pub(crate) buf: [u8; 36usize],
}
impl PushTcSfbXstats {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        36usize
    }
    pub fn earlydrop(&self) -> u32 {
        parse_u32(&self.buf[0usize..4usize]).unwrap()
    }
    pub fn set_earlydrop(&mut self, value: u32) {
        self.buf[0usize..4usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn penaltydrop(&self) -> u32 {
        parse_u32(&self.buf[4usize..8usize]).unwrap()
    }
    pub fn set_penaltydrop(&mut self, value: u32) {
        self.buf[4usize..8usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn bucketdrop(&self) -> u32 {
        parse_u32(&self.buf[8usize..12usize]).unwrap()
    }
    pub fn set_bucketdrop(&mut self, value: u32) {
        self.buf[8usize..12usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn queuedrop(&self) -> u32 {
        parse_u32(&self.buf[12usize..16usize]).unwrap()
    }
    pub fn set_queuedrop(&mut self, value: u32) {
        self.buf[12usize..16usize].copy_from_slice(&value.to_ne_bytes())
    }
    #[doc = "drops in child qdisc"]
    pub fn childdrop(&self) -> u32 {
        parse_u32(&self.buf[16usize..20usize]).unwrap()
    }
    #[doc = "drops in child qdisc"]
    pub fn set_childdrop(&mut self, value: u32) {
        self.buf[16usize..20usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn marked(&self) -> u32 {
        parse_u32(&self.buf[20usize..24usize]).unwrap()
    }
    pub fn set_marked(&mut self, value: u32) {
        self.buf[20usize..24usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn maxqlen(&self) -> u32 {
        parse_u32(&self.buf[24usize..28usize]).unwrap()
    }
    pub fn set_maxqlen(&mut self, value: u32) {
        self.buf[24usize..28usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn maxprob(&self) -> u32 {
        parse_u32(&self.buf[28usize..32usize]).unwrap()
    }
    pub fn set_maxprob(&mut self, value: u32) {
        self.buf[28usize..32usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn avgprob(&self) -> u32 {
        parse_u32(&self.buf[32usize..36usize]).unwrap()
    }
    pub fn set_avgprob(&mut self, value: u32) {
        self.buf[32usize..36usize].copy_from_slice(&value.to_ne_bytes())
    }
}
impl std::fmt::Debug for PushTcSfbXstats {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("TcSfbXstats")
            .field("earlydrop", &self.earlydrop())
            .field("penaltydrop", &self.penaltydrop())
            .field("bucketdrop", &self.bucketdrop())
            .field("queuedrop", &self.queuedrop())
            .field("childdrop", &self.childdrop())
            .field("marked", &self.marked())
            .field("maxqlen", &self.maxqlen())
            .field("maxprob", &self.maxprob())
            .field("avgprob", &self.avgprob())
            .finish()
    }
}
#[doc = "Original name: \"tc-sfq-xstats\""]
#[derive(Clone)]
pub struct PushTcSfqXstats {
    pub(crate) buf: [u8; 4usize],
}
impl PushTcSfqXstats {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        4usize
    }
    pub fn allot(&self) -> i32 {
        parse_i32(&self.buf[0usize..4usize]).unwrap()
    }
    pub fn set_allot(&mut self, value: i32) {
        self.buf[0usize..4usize].copy_from_slice(&value.to_ne_bytes())
    }
}
impl std::fmt::Debug for PushTcSfqXstats {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("TcSfqXstats")
            .field("allot", &self.allot())
            .finish()
    }
}
#[doc = "Original name: \"gnet-stats-basic\""]
#[derive(Clone)]
pub struct PushGnetStatsBasic {
    pub(crate) buf: [u8; 16usize],
}
impl PushGnetStatsBasic {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        16usize
    }
    pub fn bytes(&self) -> u64 {
        parse_u64(&self.buf[0usize..8usize]).unwrap()
    }
    pub fn set_bytes(&mut self, value: u64) {
        self.buf[0usize..8usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn packets(&self) -> u32 {
        parse_u32(&self.buf[8usize..12usize]).unwrap()
    }
    pub fn set_packets(&mut self, value: u32) {
        self.buf[8usize..12usize].copy_from_slice(&value.to_ne_bytes())
    }
}
impl std::fmt::Debug for PushGnetStatsBasic {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("GnetStatsBasic")
            .field("bytes", &self.bytes())
            .field("packets", &self.packets())
            .finish()
    }
}
#[doc = "Original name: \"gnet-stats-rate-est\""]
#[derive(Clone)]
pub struct PushGnetStatsRateEst {
    pub(crate) buf: [u8; 8usize],
}
impl PushGnetStatsRateEst {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        8usize
    }
    pub fn bps(&self) -> u32 {
        parse_u32(&self.buf[0usize..4usize]).unwrap()
    }
    pub fn set_bps(&mut self, value: u32) {
        self.buf[0usize..4usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn pps(&self) -> u32 {
        parse_u32(&self.buf[4usize..8usize]).unwrap()
    }
    pub fn set_pps(&mut self, value: u32) {
        self.buf[4usize..8usize].copy_from_slice(&value.to_ne_bytes())
    }
}
impl std::fmt::Debug for PushGnetStatsRateEst {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("GnetStatsRateEst")
            .field("bps", &self.bps())
            .field("pps", &self.pps())
            .finish()
    }
}
#[doc = "Original name: \"gnet-stats-rate-est64\""]
#[derive(Clone)]
pub struct PushGnetStatsRateEst64 {
    pub(crate) buf: [u8; 16usize],
}
impl PushGnetStatsRateEst64 {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        16usize
    }
    pub fn bps(&self) -> u64 {
        parse_u64(&self.buf[0usize..8usize]).unwrap()
    }
    pub fn set_bps(&mut self, value: u64) {
        self.buf[0usize..8usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn pps(&self) -> u64 {
        parse_u64(&self.buf[8usize..16usize]).unwrap()
    }
    pub fn set_pps(&mut self, value: u64) {
        self.buf[8usize..16usize].copy_from_slice(&value.to_ne_bytes())
    }
}
impl std::fmt::Debug for PushGnetStatsRateEst64 {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("GnetStatsRateEst64")
            .field("bps", &self.bps())
            .field("pps", &self.pps())
            .finish()
    }
}
#[doc = "Original name: \"gnet-stats-queue\""]
#[derive(Clone)]
pub struct PushGnetStatsQueue {
    pub(crate) buf: [u8; 20usize],
}
impl PushGnetStatsQueue {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        20usize
    }
    pub fn qlen(&self) -> u32 {
        parse_u32(&self.buf[0usize..4usize]).unwrap()
    }
    pub fn set_qlen(&mut self, value: u32) {
        self.buf[0usize..4usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn backlog(&self) -> u32 {
        parse_u32(&self.buf[4usize..8usize]).unwrap()
    }
    pub fn set_backlog(&mut self, value: u32) {
        self.buf[4usize..8usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn drops(&self) -> u32 {
        parse_u32(&self.buf[8usize..12usize]).unwrap()
    }
    pub fn set_drops(&mut self, value: u32) {
        self.buf[8usize..12usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn requeues(&self) -> u32 {
        parse_u32(&self.buf[12usize..16usize]).unwrap()
    }
    pub fn set_requeues(&mut self, value: u32) {
        self.buf[12usize..16usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn overlimits(&self) -> u32 {
        parse_u32(&self.buf[16usize..20usize]).unwrap()
    }
    pub fn set_overlimits(&mut self, value: u32) {
        self.buf[16usize..20usize].copy_from_slice(&value.to_ne_bytes())
    }
}
impl std::fmt::Debug for PushGnetStatsQueue {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("GnetStatsQueue")
            .field("qlen", &self.qlen())
            .field("backlog", &self.backlog())
            .field("drops", &self.drops())
            .field("requeues", &self.requeues())
            .field("overlimits", &self.overlimits())
            .finish()
    }
}
#[doc = "Original name: \"tc-u32-key\""]
#[derive(Clone)]
pub struct PushTcU32Key {
    pub(crate) buf: [u8; 16usize],
}
impl PushTcU32Key {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        16usize
    }
    pub fn mask(&self) -> u32 {
        parse_be_u32(&self.buf[0usize..4usize]).unwrap()
    }
    pub fn set_mask(&mut self, value: u32) {
        self.buf[0usize..4usize].copy_from_slice(&value.to_be_bytes())
    }
    pub fn val(&self) -> u32 {
        parse_be_u32(&self.buf[4usize..8usize]).unwrap()
    }
    pub fn set_val(&mut self, value: u32) {
        self.buf[4usize..8usize].copy_from_slice(&value.to_be_bytes())
    }
    pub fn off(&self) -> i32 {
        parse_i32(&self.buf[8usize..12usize]).unwrap()
    }
    pub fn set_off(&mut self, value: i32) {
        self.buf[8usize..12usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn offmask(&self) -> i32 {
        parse_i32(&self.buf[12usize..16usize]).unwrap()
    }
    pub fn set_offmask(&mut self, value: i32) {
        self.buf[12usize..16usize].copy_from_slice(&value.to_ne_bytes())
    }
}
impl std::fmt::Debug for PushTcU32Key {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("TcU32Key")
            .field("mask", &self.mask())
            .field("val", &self.val())
            .field("off", &self.off())
            .field("offmask", &self.offmask())
            .finish()
    }
}
#[doc = "Original name: \"tc-u32-mark\""]
#[derive(Clone)]
pub struct PushTcU32Mark {
    pub(crate) buf: [u8; 12usize],
}
impl PushTcU32Mark {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        12usize
    }
    pub fn val(&self) -> u32 {
        parse_u32(&self.buf[0usize..4usize]).unwrap()
    }
    pub fn set_val(&mut self, value: u32) {
        self.buf[0usize..4usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn mask(&self) -> u32 {
        parse_u32(&self.buf[4usize..8usize]).unwrap()
    }
    pub fn set_mask(&mut self, value: u32) {
        self.buf[4usize..8usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn success(&self) -> u32 {
        parse_u32(&self.buf[8usize..12usize]).unwrap()
    }
    pub fn set_success(&mut self, value: u32) {
        self.buf[8usize..12usize].copy_from_slice(&value.to_ne_bytes())
    }
}
impl std::fmt::Debug for PushTcU32Mark {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("TcU32Mark")
            .field("val", &self.val())
            .field("mask", &self.mask())
            .field("success", &self.success())
            .finish()
    }
}
#[doc = "Original name: \"tc-u32-sel\""]
#[derive(Clone)]
pub struct PushTcU32Sel {
    pub(crate) buf: [u8; 16usize],
}
impl PushTcU32Sel {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        16usize
    }
    pub fn flags(&self) -> u8 {
        parse_u8(&self.buf[0usize..1usize]).unwrap()
    }
    pub fn set_flags(&mut self, value: u8) {
        self.buf[0usize..1usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn offshift(&self) -> u8 {
        parse_u8(&self.buf[1usize..2usize]).unwrap()
    }
    pub fn set_offshift(&mut self, value: u8) {
        self.buf[1usize..2usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn nkeys(&self) -> u8 {
        parse_u8(&self.buf[2usize..3usize]).unwrap()
    }
    pub fn set_nkeys(&mut self, value: u8) {
        self.buf[2usize..3usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn offmask(&self) -> u16 {
        parse_be_u16(&self.buf[4usize..6usize]).unwrap()
    }
    pub fn set_offmask(&mut self, value: u16) {
        self.buf[4usize..6usize].copy_from_slice(&value.to_be_bytes())
    }
    pub fn off(&self) -> u16 {
        parse_u16(&self.buf[6usize..8usize]).unwrap()
    }
    pub fn set_off(&mut self, value: u16) {
        self.buf[6usize..8usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn offoff(&self) -> i16 {
        parse_i16(&self.buf[8usize..10usize]).unwrap()
    }
    pub fn set_offoff(&mut self, value: i16) {
        self.buf[8usize..10usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn hoff(&self) -> i16 {
        parse_i16(&self.buf[10usize..12usize]).unwrap()
    }
    pub fn set_hoff(&mut self, value: i16) {
        self.buf[10usize..12usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn hmask(&self) -> u32 {
        parse_be_u32(&self.buf[12usize..16usize]).unwrap()
    }
    pub fn set_hmask(&mut self, value: u32) {
        self.buf[12usize..16usize].copy_from_slice(&value.to_be_bytes())
    }
    pub fn keys(&self) -> PushTcU32Key {
        PushTcU32Key::new_from_slice(&self.buf[16usize..32usize]).unwrap()
    }
    pub fn set_keys(&mut self, value: PushTcU32Key) {
        self.buf[16usize..32usize].copy_from_slice(&value.as_slice())
    }
}
impl std::fmt::Debug for PushTcU32Sel {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("TcU32Sel")
            .field("flags", &self.flags())
            .field("offshift", &self.offshift())
            .field("nkeys", &self.nkeys())
            .field("offmask", &self.offmask())
            .field("off", &self.off())
            .field("offoff", &self.offoff())
            .field("hoff", &self.hoff())
            .field("hmask", &self.hmask())
            .field("keys", &self.keys())
            .finish()
    }
}
#[doc = "Original name: \"tc-u32-pcnt\""]
#[derive(Clone)]
pub struct PushTcU32Pcnt {
    pub(crate) buf: [u8; 24usize],
}
impl PushTcU32Pcnt {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        24usize
    }
    pub fn rcnt(&self) -> u64 {
        parse_u64(&self.buf[0usize..8usize]).unwrap()
    }
    pub fn set_rcnt(&mut self, value: u64) {
        self.buf[0usize..8usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn rhit(&self) -> u64 {
        parse_u64(&self.buf[8usize..16usize]).unwrap()
    }
    pub fn set_rhit(&mut self, value: u64) {
        self.buf[8usize..16usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn kcnts(&self) -> u64 {
        parse_u64(&self.buf[16usize..24usize]).unwrap()
    }
    pub fn set_kcnts(&mut self, value: u64) {
        self.buf[16usize..24usize].copy_from_slice(&value.to_ne_bytes())
    }
}
impl std::fmt::Debug for PushTcU32Pcnt {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("TcU32Pcnt")
            .field("rcnt", &self.rcnt())
            .field("rhit", &self.rhit())
            .field("kcnts", &self.kcnts())
            .finish()
    }
}
#[doc = "Original name: \"tcf-t\""]
#[derive(Clone)]
pub struct PushTcfT {
    pub(crate) buf: [u8; 32usize],
}
impl PushTcfT {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        32usize
    }
    pub fn install(&self) -> u64 {
        parse_u64(&self.buf[0usize..8usize]).unwrap()
    }
    pub fn set_install(&mut self, value: u64) {
        self.buf[0usize..8usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn lastuse(&self) -> u64 {
        parse_u64(&self.buf[8usize..16usize]).unwrap()
    }
    pub fn set_lastuse(&mut self, value: u64) {
        self.buf[8usize..16usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn expires(&self) -> u64 {
        parse_u64(&self.buf[16usize..24usize]).unwrap()
    }
    pub fn set_expires(&mut self, value: u64) {
        self.buf[16usize..24usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn firstuse(&self) -> u64 {
        parse_u64(&self.buf[24usize..32usize]).unwrap()
    }
    pub fn set_firstuse(&mut self, value: u64) {
        self.buf[24usize..32usize].copy_from_slice(&value.to_ne_bytes())
    }
}
impl std::fmt::Debug for PushTcfT {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("TcfT")
            .field("install", &self.install())
            .field("lastuse", &self.lastuse())
            .field("expires", &self.expires())
            .field("firstuse", &self.firstuse())
            .finish()
    }
}
#[doc = "Original name: \"tc-gact\""]
#[derive(Clone)]
pub struct PushTcGact {
    pub(crate) buf: [u8; 20usize],
}
impl PushTcGact {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        20usize
    }
    pub fn index(&self) -> u32 {
        parse_u32(&self.buf[0usize..4usize]).unwrap()
    }
    pub fn set_index(&mut self, value: u32) {
        self.buf[0usize..4usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn capab(&self) -> u32 {
        parse_u32(&self.buf[4usize..8usize]).unwrap()
    }
    pub fn set_capab(&mut self, value: u32) {
        self.buf[4usize..8usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn action(&self) -> i32 {
        parse_i32(&self.buf[8usize..12usize]).unwrap()
    }
    pub fn set_action(&mut self, value: i32) {
        self.buf[8usize..12usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn refcnt(&self) -> i32 {
        parse_i32(&self.buf[12usize..16usize]).unwrap()
    }
    pub fn set_refcnt(&mut self, value: i32) {
        self.buf[12usize..16usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn bindcnt(&self) -> i32 {
        parse_i32(&self.buf[16usize..20usize]).unwrap()
    }
    pub fn set_bindcnt(&mut self, value: i32) {
        self.buf[16usize..20usize].copy_from_slice(&value.to_ne_bytes())
    }
}
impl std::fmt::Debug for PushTcGact {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("TcGact")
            .field("index", &self.index())
            .field("capab", &self.capab())
            .field("action", &self.action())
            .field("refcnt", &self.refcnt())
            .field("bindcnt", &self.bindcnt())
            .finish()
    }
}
#[doc = "Original name: \"tc-gact-p\""]
#[derive(Clone)]
pub struct PushTcGactP {
    pub(crate) buf: [u8; 8usize],
}
impl PushTcGactP {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        8usize
    }
    pub fn ptype(&self) -> u16 {
        parse_u16(&self.buf[0usize..2usize]).unwrap()
    }
    pub fn set_ptype(&mut self, value: u16) {
        self.buf[0usize..2usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn pval(&self) -> u16 {
        parse_u16(&self.buf[2usize..4usize]).unwrap()
    }
    pub fn set_pval(&mut self, value: u16) {
        self.buf[2usize..4usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn paction(&self) -> i32 {
        parse_i32(&self.buf[4usize..8usize]).unwrap()
    }
    pub fn set_paction(&mut self, value: i32) {
        self.buf[4usize..8usize].copy_from_slice(&value.to_ne_bytes())
    }
}
impl std::fmt::Debug for PushTcGactP {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("TcGactP")
            .field("ptype", &self.ptype())
            .field("pval", &self.pval())
            .field("paction", &self.paction())
            .finish()
    }
}
#[doc = "Original name: \"tcf-ematch-tree-hdr\""]
#[derive(Clone)]
pub struct PushTcfEmatchTreeHdr {
    pub(crate) buf: [u8; 4usize],
}
impl PushTcfEmatchTreeHdr {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        4usize
    }
    pub fn nmatches(&self) -> u16 {
        parse_u16(&self.buf[0usize..2usize]).unwrap()
    }
    pub fn set_nmatches(&mut self, value: u16) {
        self.buf[0usize..2usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn progid(&self) -> u16 {
        parse_u16(&self.buf[2usize..4usize]).unwrap()
    }
    pub fn set_progid(&mut self, value: u16) {
        self.buf[2usize..4usize].copy_from_slice(&value.to_ne_bytes())
    }
}
impl std::fmt::Debug for PushTcfEmatchTreeHdr {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("TcfEmatchTreeHdr")
            .field("nmatches", &self.nmatches())
            .field("progid", &self.progid())
            .finish()
    }
}
#[doc = "Original name: \"tc-basic-pcnt\""]
#[derive(Clone)]
pub struct PushTcBasicPcnt {
    pub(crate) buf: [u8; 16usize],
}
impl PushTcBasicPcnt {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        16usize
    }
    pub fn rcnt(&self) -> u64 {
        parse_u64(&self.buf[0usize..8usize]).unwrap()
    }
    pub fn set_rcnt(&mut self, value: u64) {
        self.buf[0usize..8usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn rhit(&self) -> u64 {
        parse_u64(&self.buf[8usize..16usize]).unwrap()
    }
    pub fn set_rhit(&mut self, value: u64) {
        self.buf[8usize..16usize].copy_from_slice(&value.to_ne_bytes())
    }
}
impl std::fmt::Debug for PushTcBasicPcnt {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("TcBasicPcnt")
            .field("rcnt", &self.rcnt())
            .field("rhit", &self.rhit())
            .finish()
    }
}
#[doc = "Original name: \"tc-matchall-pcnt\""]
#[derive(Clone)]
pub struct PushTcMatchallPcnt {
    pub(crate) buf: [u8; 8usize],
}
impl PushTcMatchallPcnt {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        8usize
    }
    pub fn rhit(&self) -> u64 {
        parse_u64(&self.buf[0usize..8usize]).unwrap()
    }
    pub fn set_rhit(&mut self, value: u64) {
        self.buf[0usize..8usize].copy_from_slice(&value.to_ne_bytes())
    }
}
impl std::fmt::Debug for PushTcMatchallPcnt {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("TcMatchallPcnt")
            .field("rhit", &self.rhit())
            .finish()
    }
}
#[doc = "Original name: \"tc-mpls\""]
#[derive(Clone)]
pub struct PushTcMpls {
    pub(crate) buf: [u8; 24usize],
}
impl PushTcMpls {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        24usize
    }
    pub fn index(&self) -> u32 {
        parse_u32(&self.buf[0usize..4usize]).unwrap()
    }
    pub fn set_index(&mut self, value: u32) {
        self.buf[0usize..4usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn capab(&self) -> u32 {
        parse_u32(&self.buf[4usize..8usize]).unwrap()
    }
    pub fn set_capab(&mut self, value: u32) {
        self.buf[4usize..8usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn action(&self) -> i32 {
        parse_i32(&self.buf[8usize..12usize]).unwrap()
    }
    pub fn set_action(&mut self, value: i32) {
        self.buf[8usize..12usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn refcnt(&self) -> i32 {
        parse_i32(&self.buf[12usize..16usize]).unwrap()
    }
    pub fn set_refcnt(&mut self, value: i32) {
        self.buf[12usize..16usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn bindcnt(&self) -> i32 {
        parse_i32(&self.buf[16usize..20usize]).unwrap()
    }
    pub fn set_bindcnt(&mut self, value: i32) {
        self.buf[16usize..20usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn m_action(&self) -> i32 {
        parse_i32(&self.buf[20usize..24usize]).unwrap()
    }
    pub fn set_m_action(&mut self, value: i32) {
        self.buf[20usize..24usize].copy_from_slice(&value.to_ne_bytes())
    }
}
impl std::fmt::Debug for PushTcMpls {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("TcMpls")
            .field("index", &self.index())
            .field("capab", &self.capab())
            .field("action", &self.action())
            .field("refcnt", &self.refcnt())
            .field("bindcnt", &self.bindcnt())
            .field("m_action", &self.m_action())
            .finish()
    }
}
#[doc = "Original name: \"tc-police\""]
#[derive(Clone)]
pub struct PushTcPolice {
    pub(crate) buf: [u8; 32usize],
}
impl PushTcPolice {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        32usize
    }
    pub fn index(&self) -> u32 {
        parse_u32(&self.buf[0usize..4usize]).unwrap()
    }
    pub fn set_index(&mut self, value: u32) {
        self.buf[0usize..4usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn action(&self) -> i32 {
        parse_i32(&self.buf[4usize..8usize]).unwrap()
    }
    pub fn set_action(&mut self, value: i32) {
        self.buf[4usize..8usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn limit(&self) -> u32 {
        parse_u32(&self.buf[8usize..12usize]).unwrap()
    }
    pub fn set_limit(&mut self, value: u32) {
        self.buf[8usize..12usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn burst(&self) -> u32 {
        parse_u32(&self.buf[12usize..16usize]).unwrap()
    }
    pub fn set_burst(&mut self, value: u32) {
        self.buf[12usize..16usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn mtu(&self) -> u32 {
        parse_u32(&self.buf[16usize..20usize]).unwrap()
    }
    pub fn set_mtu(&mut self, value: u32) {
        self.buf[16usize..20usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn rate(&self) -> PushTcRatespec {
        PushTcRatespec::new_from_slice(&self.buf[20usize..32usize]).unwrap()
    }
    pub fn set_rate(&mut self, value: PushTcRatespec) {
        self.buf[20usize..32usize].copy_from_slice(&value.as_slice())
    }
    pub fn peakrate(&self) -> PushTcRatespec {
        PushTcRatespec::new_from_slice(&self.buf[20usize..32usize]).unwrap()
    }
    pub fn set_peakrate(&mut self, value: PushTcRatespec) {
        self.buf[20usize..32usize].copy_from_slice(&value.as_slice())
    }
    pub fn refcnt(&self) -> i32 {
        parse_i32(&self.buf[20usize..24usize]).unwrap()
    }
    pub fn set_refcnt(&mut self, value: i32) {
        self.buf[20usize..24usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn bindcnt(&self) -> i32 {
        parse_i32(&self.buf[24usize..28usize]).unwrap()
    }
    pub fn set_bindcnt(&mut self, value: i32) {
        self.buf[24usize..28usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn capab(&self) -> u32 {
        parse_u32(&self.buf[28usize..32usize]).unwrap()
    }
    pub fn set_capab(&mut self, value: u32) {
        self.buf[28usize..32usize].copy_from_slice(&value.to_ne_bytes())
    }
}
impl std::fmt::Debug for PushTcPolice {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("TcPolice")
            .field("index", &self.index())
            .field("action", &self.action())
            .field("limit", &self.limit())
            .field("burst", &self.burst())
            .field("mtu", &self.mtu())
            .field("rate", &self.rate())
            .field("peakrate", &self.peakrate())
            .field("refcnt", &self.refcnt())
            .field("bindcnt", &self.bindcnt())
            .field("capab", &self.capab())
            .finish()
    }
}
#[doc = "Original name: \"tc-pedit-sel\""]
#[derive(Clone)]
pub struct PushTcPeditSel {
    pub(crate) buf: [u8; 24usize],
}
impl PushTcPeditSel {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        24usize
    }
    pub fn index(&self) -> u32 {
        parse_u32(&self.buf[0usize..4usize]).unwrap()
    }
    pub fn set_index(&mut self, value: u32) {
        self.buf[0usize..4usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn capab(&self) -> u32 {
        parse_u32(&self.buf[4usize..8usize]).unwrap()
    }
    pub fn set_capab(&mut self, value: u32) {
        self.buf[4usize..8usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn action(&self) -> i32 {
        parse_i32(&self.buf[8usize..12usize]).unwrap()
    }
    pub fn set_action(&mut self, value: i32) {
        self.buf[8usize..12usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn refcnt(&self) -> i32 {
        parse_i32(&self.buf[12usize..16usize]).unwrap()
    }
    pub fn set_refcnt(&mut self, value: i32) {
        self.buf[12usize..16usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn bindcnt(&self) -> i32 {
        parse_i32(&self.buf[16usize..20usize]).unwrap()
    }
    pub fn set_bindcnt(&mut self, value: i32) {
        self.buf[16usize..20usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn nkeys(&self) -> u8 {
        parse_u8(&self.buf[20usize..21usize]).unwrap()
    }
    pub fn set_nkeys(&mut self, value: u8) {
        self.buf[20usize..21usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn flags(&self) -> u8 {
        parse_u8(&self.buf[21usize..22usize]).unwrap()
    }
    pub fn set_flags(&mut self, value: u8) {
        self.buf[21usize..22usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn keys(&self) -> PushTcPeditKey {
        PushTcPeditKey::new_from_slice(&self.buf[24usize..48usize]).unwrap()
    }
    pub fn set_keys(&mut self, value: PushTcPeditKey) {
        self.buf[24usize..48usize].copy_from_slice(&value.as_slice())
    }
}
impl std::fmt::Debug for PushTcPeditSel {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("TcPeditSel")
            .field("index", &self.index())
            .field("capab", &self.capab())
            .field("action", &self.action())
            .field("refcnt", &self.refcnt())
            .field("bindcnt", &self.bindcnt())
            .field("nkeys", &self.nkeys())
            .field("flags", &self.flags())
            .field("keys", &self.keys())
            .finish()
    }
}
#[doc = "Original name: \"tc-pedit-key\""]
#[derive(Clone)]
pub struct PushTcPeditKey {
    pub(crate) buf: [u8; 24usize],
}
impl PushTcPeditKey {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        24usize
    }
    pub fn mask(&self) -> u32 {
        parse_u32(&self.buf[0usize..4usize]).unwrap()
    }
    pub fn set_mask(&mut self, value: u32) {
        self.buf[0usize..4usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn val(&self) -> u32 {
        parse_u32(&self.buf[4usize..8usize]).unwrap()
    }
    pub fn set_val(&mut self, value: u32) {
        self.buf[4usize..8usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn off(&self) -> u32 {
        parse_u32(&self.buf[8usize..12usize]).unwrap()
    }
    pub fn set_off(&mut self, value: u32) {
        self.buf[8usize..12usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn at(&self) -> u32 {
        parse_u32(&self.buf[12usize..16usize]).unwrap()
    }
    pub fn set_at(&mut self, value: u32) {
        self.buf[12usize..16usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn offmask(&self) -> u32 {
        parse_u32(&self.buf[16usize..20usize]).unwrap()
    }
    pub fn set_offmask(&mut self, value: u32) {
        self.buf[16usize..20usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn shift(&self) -> u32 {
        parse_u32(&self.buf[20usize..24usize]).unwrap()
    }
    pub fn set_shift(&mut self, value: u32) {
        self.buf[20usize..24usize].copy_from_slice(&value.to_ne_bytes())
    }
}
impl std::fmt::Debug for PushTcPeditKey {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("TcPeditKey")
            .field("mask", &self.mask())
            .field("val", &self.val())
            .field("off", &self.off())
            .field("at", &self.at())
            .field("offmask", &self.offmask())
            .field("shift", &self.shift())
            .finish()
    }
}
#[doc = "Original name: \"tc-vlan\""]
#[derive(Clone)]
pub struct PushTcVlan {
    pub(crate) buf: [u8; 24usize],
}
impl PushTcVlan {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Self {
            buf: [0u8; Self::len()],
        }
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        24usize
    }
    pub fn index(&self) -> u32 {
        parse_u32(&self.buf[0usize..4usize]).unwrap()
    }
    pub fn set_index(&mut self, value: u32) {
        self.buf[0usize..4usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn capab(&self) -> u32 {
        parse_u32(&self.buf[4usize..8usize]).unwrap()
    }
    pub fn set_capab(&mut self, value: u32) {
        self.buf[4usize..8usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn action(&self) -> i32 {
        parse_i32(&self.buf[8usize..12usize]).unwrap()
    }
    pub fn set_action(&mut self, value: i32) {
        self.buf[8usize..12usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn refcnt(&self) -> i32 {
        parse_i32(&self.buf[12usize..16usize]).unwrap()
    }
    pub fn set_refcnt(&mut self, value: i32) {
        self.buf[12usize..16usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn bindcnt(&self) -> i32 {
        parse_i32(&self.buf[16usize..20usize]).unwrap()
    }
    pub fn set_bindcnt(&mut self, value: i32) {
        self.buf[16usize..20usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn v_action(&self) -> i32 {
        parse_i32(&self.buf[20usize..24usize]).unwrap()
    }
    pub fn set_v_action(&mut self, value: i32) {
        self.buf[20usize..24usize].copy_from_slice(&value.to_ne_bytes())
    }
}
impl std::fmt::Debug for PushTcVlan {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("TcVlan")
            .field("index", &self.index())
            .field("capab", &self.capab())
            .field("action", &self.action())
            .field("refcnt", &self.refcnt())
            .field("bindcnt", &self.bindcnt())
            .field("v_action", &self.v_action())
            .finish()
    }
}
#[doc = "Create new tc qdisc."]
pub struct PushOpNewqdiscDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpNewqdiscDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpNewqdiscDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushTcmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushTcmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_kind(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_kind_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_basic(mut self) -> PushBasicAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"basic");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushBasicAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_bpf(mut self) -> PushBpfAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"bpf");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushBpfAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_bfifo(mut self, fixed_header: &PushTcFifoQopt) -> Self {
        self = self.push_kind(c"bfifo");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_cake(mut self) -> PushCakeAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"cake");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushCakeAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_cbs(mut self) -> PushCbsAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"cbs");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushCbsAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_cgroup(mut self) -> PushCgroupAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"cgroup");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushCgroupAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_choke(mut self) -> PushChokeAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"choke");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushChokeAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_clsact(mut self) -> Self {
        self = self.push_kind(c"clsact");
        push_nested_header(self.as_rec_mut(), 2u16);
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_codel(mut self) -> PushCodelAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"codel");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushCodelAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_drr(mut self) -> PushDrrAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"drr");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushDrrAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_dualpi2(mut self) -> PushDualpi2Attrs<PushDummy<Prev>> {
        self = self.push_kind(c"dualpi2");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushDualpi2Attrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_etf(mut self) -> PushEtfAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"etf");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushEtfAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_ets(mut self) -> PushEtsAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"ets");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushEtsAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_flow(mut self) -> PushFlowAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"flow");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFlowAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_flower(mut self) -> PushFlowerAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"flower");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFlowerAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_fq(mut self) -> PushFqAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"fq");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFqAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_fq_codel(mut self) -> PushFqCodelAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"fq_codel");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFqCodelAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_fq_pie(mut self) -> PushFqPieAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"fq_pie");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFqPieAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_fw(mut self) -> PushFwAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"fw");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFwAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_gred(mut self) -> PushGredAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"gred");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushGredAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_hfsc(mut self, fixed_header: &PushTcHfscQopt) -> Self {
        self = self.push_kind(c"hfsc");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_hhf(mut self) -> PushHhfAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"hhf");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushHhfAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_htb(mut self) -> PushHtbAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"htb");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushHtbAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_ingress(mut self) -> Self {
        self = self.push_kind(c"ingress");
        push_nested_header(self.as_rec_mut(), 2u16);
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_matchall(mut self) -> PushMatchallAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"matchall");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushMatchallAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_mq(mut self) -> Self {
        self = self.push_kind(c"mq");
        push_nested_header(self.as_rec_mut(), 2u16);
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_mqprio(mut self, fixed_header: &PushTcMqprioQopt) -> Self {
        self = self.push_kind(c"mqprio");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_multiq(mut self, fixed_header: &PushTcMultiqQopt) -> Self {
        self = self.push_kind(c"multiq");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_netem(
        mut self,
        fixed_header: &PushTcNetemQopt,
    ) -> PushNetemAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"netem");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        let Self {
            prev,
            header_offset,
        } = self;
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushNetemAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_pfifo(mut self, fixed_header: &PushTcFifoQopt) -> Self {
        self = self.push_kind(c"pfifo");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_pfifo_fast(mut self, fixed_header: &PushTcPrioQopt) -> Self {
        self = self.push_kind(c"pfifo_fast");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_pfifo_head_drop(mut self, fixed_header: &PushTcFifoQopt) -> Self {
        self = self.push_kind(c"pfifo_head_drop");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_pie(mut self) -> PushPieAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"pie");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushPieAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_plug(mut self, fixed_header: &PushTcPlugQopt) -> Self {
        self = self.push_kind(c"plug");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_prio(mut self, fixed_header: &PushTcPrioQopt) -> Self {
        self = self.push_kind(c"prio");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_qfq(mut self) -> PushQfqAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"qfq");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushQfqAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_red(mut self) -> PushRedAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"red");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushRedAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_route(mut self) -> PushRouteAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"route");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushRouteAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_sfb(mut self, fixed_header: &PushTcSfbQopt) -> Self {
        self = self.push_kind(c"sfb");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_sfq(mut self, fixed_header: &PushTcSfqQoptV1) -> Self {
        self = self.push_kind(c"sfq");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_taprio(mut self) -> PushTaprioAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"taprio");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushTaprioAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_tbf(mut self) -> PushTbfAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"tbf");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushTbfAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_u32(mut self) -> PushU32Attrs<PushDummy<Prev>> {
        self = self.push_kind(c"u32");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushU32Attrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    pub fn push_rate(mut self, value: PushGnetEstimator) -> Self {
        push_header(self.as_rec_mut(), 5u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_chain(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 11u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_ingress_block(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 13u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_egress_block(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 14u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpNewqdiscDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Create new tc qdisc."]
#[doc = "Original name: \"op-newqdisc-do-request\""]
#[derive(Clone)]
pub enum OpNewqdiscDoRequest<'a> {
    Kind(&'a CStr),
    Options(OptionsMsg<'a>),
    Rate(PushGnetEstimator),
    Chain(u32),
    IngressBlock(u32),
    EgressBlock(u32),
}
impl<'a> Iterable<'a, OpNewqdiscDoRequest<'a>> {
    pub fn get_kind(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewqdiscDoRequest::Kind(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewqdiscDoRequest", "Kind"))
    }
    pub fn get_options(&self) -> Result<OptionsMsg<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewqdiscDoRequest::Options(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewqdiscDoRequest", "Options"))
    }
    pub fn get_rate(&self) -> Result<PushGnetEstimator, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewqdiscDoRequest::Rate(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewqdiscDoRequest", "Rate"))
    }
    pub fn get_chain(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewqdiscDoRequest::Chain(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewqdiscDoRequest", "Chain"))
    }
    pub fn get_ingress_block(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewqdiscDoRequest::IngressBlock(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewqdiscDoRequest", "IngressBlock"))
    }
    pub fn get_egress_block(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewqdiscDoRequest::EgressBlock(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewqdiscDoRequest", "EgressBlock"))
    }
}
impl<'a> OpNewqdiscDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushTcmsg, Iterable<'a, OpNewqdiscDoRequest<'a>>) {
        let mut header = PushTcmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushTcmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushTcmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Attrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpNewqdiscDoRequest<'a>> {
    type Item = Result<OpNewqdiscDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpNewqdiscDoRequest::Kind({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpNewqdiscDoRequest::Options({
                    let res = {
                        let Ok(selector) = self.get_kind() else { break };
                        OptionsMsg::select_with_loc(selector, next, self.orig_loc)
                    };
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpNewqdiscDoRequest::Rate({
                    let res = PushGnetEstimator::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => OpNewqdiscDoRequest::Chain({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                13u16 => OpNewqdiscDoRequest::IngressBlock({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                14u16 => OpNewqdiscDoRequest::EgressBlock({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpNewqdiscDoRequest",
            r#type.and_then(|t| OpNewqdiscDoRequest::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpNewqdiscDoRequest<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpNewqdiscDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpNewqdiscDoRequest::Kind(val) => fmt.field("Kind", &val),
                OpNewqdiscDoRequest::Options(val) => fmt.field("Options", &val),
                OpNewqdiscDoRequest::Rate(val) => fmt.field("Rate", &val),
                OpNewqdiscDoRequest::Chain(val) => fmt.field("Chain", &val),
                OpNewqdiscDoRequest::IngressBlock(val) => fmt.field("IngressBlock", &val),
                OpNewqdiscDoRequest::EgressBlock(val) => fmt.field("EgressBlock", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpNewqdiscDoRequest<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushTcmsg::len() {
            stack.push(("OpNewqdiscDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpNewqdiscDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpNewqdiscDoRequest::Kind(val) => {
                    if last_off == offset {
                        stack.push(("Kind", last_off));
                        break;
                    }
                }
                OpNewqdiscDoRequest::Options(val) => {
                    if last_off == offset {
                        stack.push(("Options", last_off));
                        break;
                    }
                }
                OpNewqdiscDoRequest::Rate(val) => {
                    if last_off == offset {
                        stack.push(("Rate", last_off));
                        break;
                    }
                }
                OpNewqdiscDoRequest::Chain(val) => {
                    if last_off == offset {
                        stack.push(("Chain", last_off));
                        break;
                    }
                }
                OpNewqdiscDoRequest::IngressBlock(val) => {
                    if last_off == offset {
                        stack.push(("IngressBlock", last_off));
                        break;
                    }
                }
                OpNewqdiscDoRequest::EgressBlock(val) => {
                    if last_off == offset {
                        stack.push(("EgressBlock", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpNewqdiscDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Create new tc qdisc."]
pub struct PushOpNewqdiscDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpNewqdiscDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpNewqdiscDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushTcmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushTcmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpNewqdiscDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Create new tc qdisc."]
#[doc = "Original name: \"op-newqdisc-do-reply\""]
#[derive(Clone)]
pub enum OpNewqdiscDoReply {}
impl<'a> Iterable<'a, OpNewqdiscDoReply> {}
impl OpNewqdiscDoReply {
    pub fn new(buf: &'_ [u8]) -> (PushTcmsg, Iterable<'_, OpNewqdiscDoReply>) {
        let mut header = PushTcmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushTcmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushTcmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Attrs::attr_from_type(r#type)
    }
}
impl Iterator for Iterable<'_, OpNewqdiscDoReply> {
    type Item = Result<OpNewqdiscDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpNewqdiscDoReply",
            r#type.and_then(|t| OpNewqdiscDoReply::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl std::fmt::Debug for Iterable<'_, OpNewqdiscDoReply> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpNewqdiscDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl Iterable<'_, OpNewqdiscDoReply> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushTcmsg::len() {
            stack.push(("OpNewqdiscDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpNewqdiscDoReply::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpNewqdiscDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpNewqdiscDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushTcmsg) -> Self {
        PushOpNewqdiscDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpNewqdiscDoRequest<&mut Vec<u8>> {
        PushOpNewqdiscDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpNewqdiscDoRequest<RequestBuf<'r>> {
        PushOpNewqdiscDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpNewqdiscDoRequest<'_> {
    type ReplyType<'buf> = (PushTcmsg, Iterable<'buf, OpNewqdiscDoReply>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 0u16,
            request_type: 36u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpNewqdiscDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpNewqdiscDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Delete existing tc qdisc."]
pub struct PushOpDelqdiscDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDelqdiscDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDelqdiscDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushTcmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushTcmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_kind(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_kind_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_basic(mut self) -> PushBasicAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"basic");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushBasicAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_bpf(mut self) -> PushBpfAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"bpf");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushBpfAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_bfifo(mut self, fixed_header: &PushTcFifoQopt) -> Self {
        self = self.push_kind(c"bfifo");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_cake(mut self) -> PushCakeAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"cake");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushCakeAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_cbs(mut self) -> PushCbsAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"cbs");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushCbsAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_cgroup(mut self) -> PushCgroupAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"cgroup");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushCgroupAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_choke(mut self) -> PushChokeAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"choke");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushChokeAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_clsact(mut self) -> Self {
        self = self.push_kind(c"clsact");
        push_nested_header(self.as_rec_mut(), 2u16);
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_codel(mut self) -> PushCodelAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"codel");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushCodelAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_drr(mut self) -> PushDrrAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"drr");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushDrrAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_dualpi2(mut self) -> PushDualpi2Attrs<PushDummy<Prev>> {
        self = self.push_kind(c"dualpi2");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushDualpi2Attrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_etf(mut self) -> PushEtfAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"etf");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushEtfAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_ets(mut self) -> PushEtsAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"ets");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushEtsAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_flow(mut self) -> PushFlowAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"flow");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFlowAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_flower(mut self) -> PushFlowerAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"flower");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFlowerAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_fq(mut self) -> PushFqAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"fq");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFqAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_fq_codel(mut self) -> PushFqCodelAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"fq_codel");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFqCodelAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_fq_pie(mut self) -> PushFqPieAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"fq_pie");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFqPieAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_fw(mut self) -> PushFwAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"fw");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFwAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_gred(mut self) -> PushGredAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"gred");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushGredAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_hfsc(mut self, fixed_header: &PushTcHfscQopt) -> Self {
        self = self.push_kind(c"hfsc");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_hhf(mut self) -> PushHhfAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"hhf");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushHhfAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_htb(mut self) -> PushHtbAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"htb");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushHtbAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_ingress(mut self) -> Self {
        self = self.push_kind(c"ingress");
        push_nested_header(self.as_rec_mut(), 2u16);
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_matchall(mut self) -> PushMatchallAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"matchall");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushMatchallAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_mq(mut self) -> Self {
        self = self.push_kind(c"mq");
        push_nested_header(self.as_rec_mut(), 2u16);
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_mqprio(mut self, fixed_header: &PushTcMqprioQopt) -> Self {
        self = self.push_kind(c"mqprio");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_multiq(mut self, fixed_header: &PushTcMultiqQopt) -> Self {
        self = self.push_kind(c"multiq");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_netem(
        mut self,
        fixed_header: &PushTcNetemQopt,
    ) -> PushNetemAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"netem");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        let Self {
            prev,
            header_offset,
        } = self;
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushNetemAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_pfifo(mut self, fixed_header: &PushTcFifoQopt) -> Self {
        self = self.push_kind(c"pfifo");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_pfifo_fast(mut self, fixed_header: &PushTcPrioQopt) -> Self {
        self = self.push_kind(c"pfifo_fast");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_pfifo_head_drop(mut self, fixed_header: &PushTcFifoQopt) -> Self {
        self = self.push_kind(c"pfifo_head_drop");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_pie(mut self) -> PushPieAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"pie");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushPieAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_plug(mut self, fixed_header: &PushTcPlugQopt) -> Self {
        self = self.push_kind(c"plug");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_prio(mut self, fixed_header: &PushTcPrioQopt) -> Self {
        self = self.push_kind(c"prio");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_qfq(mut self) -> PushQfqAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"qfq");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushQfqAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_red(mut self) -> PushRedAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"red");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushRedAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_route(mut self) -> PushRouteAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"route");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushRouteAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_sfb(mut self, fixed_header: &PushTcSfbQopt) -> Self {
        self = self.push_kind(c"sfb");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_sfq(mut self, fixed_header: &PushTcSfqQoptV1) -> Self {
        self = self.push_kind(c"sfq");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_taprio(mut self) -> PushTaprioAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"taprio");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushTaprioAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_tbf(mut self) -> PushTbfAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"tbf");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushTbfAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_u32(mut self) -> PushU32Attrs<PushDummy<Prev>> {
        self = self.push_kind(c"u32");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushU32Attrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    pub fn push_rate(mut self, value: PushGnetEstimator) -> Self {
        push_header(self.as_rec_mut(), 5u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_chain(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 11u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_ingress_block(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 13u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_egress_block(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 14u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpDelqdiscDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete existing tc qdisc."]
#[doc = "Original name: \"op-delqdisc-do-request\""]
#[derive(Clone)]
pub enum OpDelqdiscDoRequest<'a> {
    Kind(&'a CStr),
    Options(OptionsMsg<'a>),
    Rate(PushGnetEstimator),
    Chain(u32),
    IngressBlock(u32),
    EgressBlock(u32),
}
impl<'a> Iterable<'a, OpDelqdiscDoRequest<'a>> {
    pub fn get_kind(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelqdiscDoRequest::Kind(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelqdiscDoRequest", "Kind"))
    }
    pub fn get_options(&self) -> Result<OptionsMsg<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelqdiscDoRequest::Options(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelqdiscDoRequest", "Options"))
    }
    pub fn get_rate(&self) -> Result<PushGnetEstimator, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelqdiscDoRequest::Rate(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelqdiscDoRequest", "Rate"))
    }
    pub fn get_chain(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelqdiscDoRequest::Chain(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelqdiscDoRequest", "Chain"))
    }
    pub fn get_ingress_block(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelqdiscDoRequest::IngressBlock(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelqdiscDoRequest", "IngressBlock"))
    }
    pub fn get_egress_block(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelqdiscDoRequest::EgressBlock(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelqdiscDoRequest", "EgressBlock"))
    }
}
impl<'a> OpDelqdiscDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushTcmsg, Iterable<'a, OpDelqdiscDoRequest<'a>>) {
        let mut header = PushTcmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushTcmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushTcmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Attrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpDelqdiscDoRequest<'a>> {
    type Item = Result<OpDelqdiscDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpDelqdiscDoRequest::Kind({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpDelqdiscDoRequest::Options({
                    let res = {
                        let Ok(selector) = self.get_kind() else { break };
                        OptionsMsg::select_with_loc(selector, next, self.orig_loc)
                    };
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpDelqdiscDoRequest::Rate({
                    let res = PushGnetEstimator::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => OpDelqdiscDoRequest::Chain({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                13u16 => OpDelqdiscDoRequest::IngressBlock({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                14u16 => OpDelqdiscDoRequest::EgressBlock({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpDelqdiscDoRequest",
            r#type.and_then(|t| OpDelqdiscDoRequest::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpDelqdiscDoRequest<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDelqdiscDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpDelqdiscDoRequest::Kind(val) => fmt.field("Kind", &val),
                OpDelqdiscDoRequest::Options(val) => fmt.field("Options", &val),
                OpDelqdiscDoRequest::Rate(val) => fmt.field("Rate", &val),
                OpDelqdiscDoRequest::Chain(val) => fmt.field("Chain", &val),
                OpDelqdiscDoRequest::IngressBlock(val) => fmt.field("IngressBlock", &val),
                OpDelqdiscDoRequest::EgressBlock(val) => fmt.field("EgressBlock", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpDelqdiscDoRequest<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushTcmsg::len() {
            stack.push(("OpDelqdiscDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDelqdiscDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpDelqdiscDoRequest::Kind(val) => {
                    if last_off == offset {
                        stack.push(("Kind", last_off));
                        break;
                    }
                }
                OpDelqdiscDoRequest::Options(val) => {
                    if last_off == offset {
                        stack.push(("Options", last_off));
                        break;
                    }
                }
                OpDelqdiscDoRequest::Rate(val) => {
                    if last_off == offset {
                        stack.push(("Rate", last_off));
                        break;
                    }
                }
                OpDelqdiscDoRequest::Chain(val) => {
                    if last_off == offset {
                        stack.push(("Chain", last_off));
                        break;
                    }
                }
                OpDelqdiscDoRequest::IngressBlock(val) => {
                    if last_off == offset {
                        stack.push(("IngressBlock", last_off));
                        break;
                    }
                }
                OpDelqdiscDoRequest::EgressBlock(val) => {
                    if last_off == offset {
                        stack.push(("EgressBlock", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpDelqdiscDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Delete existing tc qdisc."]
pub struct PushOpDelqdiscDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDelqdiscDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDelqdiscDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushTcmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushTcmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpDelqdiscDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete existing tc qdisc."]
#[doc = "Original name: \"op-delqdisc-do-reply\""]
#[derive(Clone)]
pub enum OpDelqdiscDoReply {}
impl<'a> Iterable<'a, OpDelqdiscDoReply> {}
impl OpDelqdiscDoReply {
    pub fn new(buf: &'_ [u8]) -> (PushTcmsg, Iterable<'_, OpDelqdiscDoReply>) {
        let mut header = PushTcmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushTcmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushTcmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Attrs::attr_from_type(r#type)
    }
}
impl Iterator for Iterable<'_, OpDelqdiscDoReply> {
    type Item = Result<OpDelqdiscDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpDelqdiscDoReply",
            r#type.and_then(|t| OpDelqdiscDoReply::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl std::fmt::Debug for Iterable<'_, OpDelqdiscDoReply> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDelqdiscDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl Iterable<'_, OpDelqdiscDoReply> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushTcmsg::len() {
            stack.push(("OpDelqdiscDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDelqdiscDoReply::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpDelqdiscDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpDelqdiscDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushTcmsg) -> Self {
        PushOpDelqdiscDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpDelqdiscDoRequest<&mut Vec<u8>> {
        PushOpDelqdiscDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpDelqdiscDoRequest<RequestBuf<'r>> {
        PushOpDelqdiscDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpDelqdiscDoRequest<'_> {
    type ReplyType<'buf> = (PushTcmsg, Iterable<'buf, OpDelqdiscDoReply>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 0u16,
            request_type: 37u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpDelqdiscDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpDelqdiscDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Get / dump tc qdisc information."]
pub struct PushOpGetqdiscDumpRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetqdiscDumpRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetqdiscDumpRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushTcmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushTcmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_dump_invisible(mut self, value: ()) -> Self {
        push_header(self.as_rec_mut(), 10u16, 0 as u16);
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetqdiscDumpRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump tc qdisc information."]
#[doc = "Original name: \"op-getqdisc-dump-request\""]
#[derive(Clone)]
pub enum OpGetqdiscDumpRequest {
    DumpInvisible(()),
}
impl<'a> Iterable<'a, OpGetqdiscDumpRequest> {
    pub fn get_dump_invisible(&self) -> Result<(), ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetqdiscDumpRequest::DumpInvisible(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetqdiscDumpRequest", "DumpInvisible"))
    }
}
impl OpGetqdiscDumpRequest {
    pub fn new(buf: &'_ [u8]) -> (PushTcmsg, Iterable<'_, OpGetqdiscDumpRequest>) {
        let mut header = PushTcmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushTcmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushTcmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Attrs::attr_from_type(r#type)
    }
}
impl Iterator for Iterable<'_, OpGetqdiscDumpRequest> {
    type Item = Result<OpGetqdiscDumpRequest, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                10u16 => OpGetqdiscDumpRequest::DumpInvisible(()),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpGetqdiscDumpRequest",
            r#type.and_then(|t| OpGetqdiscDumpRequest::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl std::fmt::Debug for Iterable<'_, OpGetqdiscDumpRequest> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetqdiscDumpRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetqdiscDumpRequest::DumpInvisible(val) => fmt.field("DumpInvisible", &val),
            };
        }
        fmt.finish()
    }
}
impl Iterable<'_, OpGetqdiscDumpRequest> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushTcmsg::len() {
            stack.push(("OpGetqdiscDumpRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetqdiscDumpRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetqdiscDumpRequest::DumpInvisible(val) => {
                    if last_off == offset {
                        stack.push(("DumpInvisible", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetqdiscDumpRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get / dump tc qdisc information."]
pub struct PushOpGetqdiscDumpReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetqdiscDumpReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetqdiscDumpReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushTcmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushTcmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_kind(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_kind_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_basic(mut self) -> PushBasicAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"basic");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushBasicAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_bpf(mut self) -> PushBpfAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"bpf");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushBpfAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_bfifo(mut self, fixed_header: &PushTcFifoQopt) -> Self {
        self = self.push_kind(c"bfifo");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_cake(mut self) -> PushCakeAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"cake");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushCakeAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_cbs(mut self) -> PushCbsAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"cbs");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushCbsAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_cgroup(mut self) -> PushCgroupAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"cgroup");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushCgroupAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_choke(mut self) -> PushChokeAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"choke");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushChokeAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_clsact(mut self) -> Self {
        self = self.push_kind(c"clsact");
        push_nested_header(self.as_rec_mut(), 2u16);
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_codel(mut self) -> PushCodelAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"codel");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushCodelAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_drr(mut self) -> PushDrrAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"drr");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushDrrAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_dualpi2(mut self) -> PushDualpi2Attrs<PushDummy<Prev>> {
        self = self.push_kind(c"dualpi2");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushDualpi2Attrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_etf(mut self) -> PushEtfAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"etf");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushEtfAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_ets(mut self) -> PushEtsAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"ets");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushEtsAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_flow(mut self) -> PushFlowAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"flow");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFlowAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_flower(mut self) -> PushFlowerAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"flower");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFlowerAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_fq(mut self) -> PushFqAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"fq");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFqAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_fq_codel(mut self) -> PushFqCodelAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"fq_codel");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFqCodelAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_fq_pie(mut self) -> PushFqPieAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"fq_pie");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFqPieAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_fw(mut self) -> PushFwAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"fw");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFwAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_gred(mut self) -> PushGredAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"gred");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushGredAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_hfsc(mut self, fixed_header: &PushTcHfscQopt) -> Self {
        self = self.push_kind(c"hfsc");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_hhf(mut self) -> PushHhfAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"hhf");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushHhfAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_htb(mut self) -> PushHtbAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"htb");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushHtbAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_ingress(mut self) -> Self {
        self = self.push_kind(c"ingress");
        push_nested_header(self.as_rec_mut(), 2u16);
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_matchall(mut self) -> PushMatchallAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"matchall");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushMatchallAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_mq(mut self) -> Self {
        self = self.push_kind(c"mq");
        push_nested_header(self.as_rec_mut(), 2u16);
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_mqprio(mut self, fixed_header: &PushTcMqprioQopt) -> Self {
        self = self.push_kind(c"mqprio");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_multiq(mut self, fixed_header: &PushTcMultiqQopt) -> Self {
        self = self.push_kind(c"multiq");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_netem(
        mut self,
        fixed_header: &PushTcNetemQopt,
    ) -> PushNetemAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"netem");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        let Self {
            prev,
            header_offset,
        } = self;
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushNetemAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_pfifo(mut self, fixed_header: &PushTcFifoQopt) -> Self {
        self = self.push_kind(c"pfifo");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_pfifo_fast(mut self, fixed_header: &PushTcPrioQopt) -> Self {
        self = self.push_kind(c"pfifo_fast");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_pfifo_head_drop(mut self, fixed_header: &PushTcFifoQopt) -> Self {
        self = self.push_kind(c"pfifo_head_drop");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_pie(mut self) -> PushPieAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"pie");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushPieAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_plug(mut self, fixed_header: &PushTcPlugQopt) -> Self {
        self = self.push_kind(c"plug");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_prio(mut self, fixed_header: &PushTcPrioQopt) -> Self {
        self = self.push_kind(c"prio");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_qfq(mut self) -> PushQfqAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"qfq");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushQfqAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_red(mut self) -> PushRedAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"red");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushRedAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_route(mut self) -> PushRouteAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"route");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushRouteAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_sfb(mut self, fixed_header: &PushTcSfbQopt) -> Self {
        self = self.push_kind(c"sfb");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_sfq(mut self, fixed_header: &PushTcSfqQoptV1) -> Self {
        self = self.push_kind(c"sfq");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_taprio(mut self) -> PushTaprioAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"taprio");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushTaprioAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_tbf(mut self) -> PushTbfAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"tbf");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushTbfAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_u32(mut self) -> PushU32Attrs<PushDummy<Prev>> {
        self = self.push_kind(c"u32");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushU32Attrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    pub fn push_stats(mut self, value: PushTcStats) -> Self {
        push_header(self.as_rec_mut(), 3u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_cake(mut self) -> PushCakeStatsAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"cake");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushCakeStatsAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_choke(mut self, fixed_header: &PushTcChokeXstats) -> Self {
        self = self.push_kind(c"choke");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_codel(mut self, fixed_header: &PushTcCodelXstats) -> Self {
        self = self.push_kind(c"codel");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_dualpi2(mut self, fixed_header: &PushTcDualpi2Xstats) -> Self {
        self = self.push_kind(c"dualpi2");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_fq(mut self, fixed_header: &PushTcFqQdStats) -> Self {
        self = self.push_kind(c"fq");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_fq_codel(mut self, fixed_header: &PushTcFqCodelXstats) -> Self {
        self = self.push_kind(c"fq_codel");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_fq_pie(mut self, fixed_header: &PushTcFqPieXstats) -> Self {
        self = self.push_kind(c"fq_pie");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_hhf(mut self, fixed_header: &PushTcHhfXstats) -> Self {
        self = self.push_kind(c"hhf");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_pie(mut self, fixed_header: &PushTcPieXstats) -> Self {
        self = self.push_kind(c"pie");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_red(mut self, fixed_header: &PushTcRedXstats) -> Self {
        self = self.push_kind(c"red");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_sfb(mut self, fixed_header: &PushTcSfbXstats) -> Self {
        self = self.push_kind(c"sfb");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_sfq(mut self, fixed_header: &PushTcSfqXstats) -> Self {
        self = self.push_kind(c"sfq");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    pub fn push_rate(mut self, value: PushGnetEstimator) -> Self {
        push_header(self.as_rec_mut(), 5u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_fcnt(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn nested_stats2(mut self) -> PushTcaStatsAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 7u16);
        PushTcaStatsAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn nested_stab(mut self) -> PushTcaStabAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 8u16);
        PushTcaStabAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_chain(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 11u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_ingress_block(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 13u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_egress_block(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 14u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetqdiscDumpReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump tc qdisc information."]
#[doc = "Original name: \"op-getqdisc-dump-reply\""]
#[derive(Clone)]
pub enum OpGetqdiscDumpReply<'a> {
    Kind(&'a CStr),
    Options(OptionsMsg<'a>),
    Stats(PushTcStats),
    Xstats(TcaStatsAppMsg<'a>),
    Rate(PushGnetEstimator),
    Fcnt(u32),
    Stats2(Iterable<'a, TcaStatsAttrs<'a>>),
    Stab(Iterable<'a, TcaStabAttrs<'a>>),
    Chain(u32),
    IngressBlock(u32),
    EgressBlock(u32),
}
impl<'a> Iterable<'a, OpGetqdiscDumpReply<'a>> {
    pub fn get_kind(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetqdiscDumpReply::Kind(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetqdiscDumpReply", "Kind"))
    }
    pub fn get_options(&self) -> Result<OptionsMsg<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetqdiscDumpReply::Options(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetqdiscDumpReply", "Options"))
    }
    pub fn get_stats(&self) -> Result<PushTcStats, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetqdiscDumpReply::Stats(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetqdiscDumpReply", "Stats"))
    }
    pub fn get_xstats(&self) -> Result<TcaStatsAppMsg<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetqdiscDumpReply::Xstats(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetqdiscDumpReply", "Xstats"))
    }
    pub fn get_rate(&self) -> Result<PushGnetEstimator, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetqdiscDumpReply::Rate(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetqdiscDumpReply", "Rate"))
    }
    pub fn get_fcnt(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetqdiscDumpReply::Fcnt(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetqdiscDumpReply", "Fcnt"))
    }
    pub fn get_stats2(&self) -> Result<Iterable<'a, TcaStatsAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetqdiscDumpReply::Stats2(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetqdiscDumpReply", "Stats2"))
    }
    pub fn get_stab(&self) -> Result<Iterable<'a, TcaStabAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetqdiscDumpReply::Stab(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetqdiscDumpReply", "Stab"))
    }
    pub fn get_chain(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetqdiscDumpReply::Chain(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetqdiscDumpReply", "Chain"))
    }
    pub fn get_ingress_block(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetqdiscDumpReply::IngressBlock(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetqdiscDumpReply", "IngressBlock"))
    }
    pub fn get_egress_block(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetqdiscDumpReply::EgressBlock(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetqdiscDumpReply", "EgressBlock"))
    }
}
impl<'a> OpGetqdiscDumpReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushTcmsg, Iterable<'a, OpGetqdiscDumpReply<'a>>) {
        let mut header = PushTcmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushTcmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushTcmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Attrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpGetqdiscDumpReply<'a>> {
    type Item = Result<OpGetqdiscDumpReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetqdiscDumpReply::Kind({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetqdiscDumpReply::Options({
                    let res = {
                        let Ok(selector) = self.get_kind() else { break };
                        OptionsMsg::select_with_loc(selector, next, self.orig_loc)
                    };
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetqdiscDumpReply::Stats({
                    let res = PushTcStats::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpGetqdiscDumpReply::Xstats({
                    let res = {
                        let Ok(selector) = self.get_kind() else { break };
                        TcaStatsAppMsg::select_with_loc(selector, next, self.orig_loc)
                    };
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpGetqdiscDumpReply::Rate({
                    let res = PushGnetEstimator::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpGetqdiscDumpReply::Fcnt({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpGetqdiscDumpReply::Stats2({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpGetqdiscDumpReply::Stab({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => OpGetqdiscDumpReply::Chain({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                13u16 => OpGetqdiscDumpReply::IngressBlock({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                14u16 => OpGetqdiscDumpReply::EgressBlock({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpGetqdiscDumpReply",
            r#type.and_then(|t| OpGetqdiscDumpReply::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpGetqdiscDumpReply<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetqdiscDumpReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetqdiscDumpReply::Kind(val) => fmt.field("Kind", &val),
                OpGetqdiscDumpReply::Options(val) => fmt.field("Options", &val),
                OpGetqdiscDumpReply::Stats(val) => fmt.field("Stats", &val),
                OpGetqdiscDumpReply::Xstats(val) => fmt.field("Xstats", &val),
                OpGetqdiscDumpReply::Rate(val) => fmt.field("Rate", &val),
                OpGetqdiscDumpReply::Fcnt(val) => fmt.field("Fcnt", &val),
                OpGetqdiscDumpReply::Stats2(val) => fmt.field("Stats2", &val),
                OpGetqdiscDumpReply::Stab(val) => fmt.field("Stab", &val),
                OpGetqdiscDumpReply::Chain(val) => fmt.field("Chain", &val),
                OpGetqdiscDumpReply::IngressBlock(val) => fmt.field("IngressBlock", &val),
                OpGetqdiscDumpReply::EgressBlock(val) => fmt.field("EgressBlock", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpGetqdiscDumpReply<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushTcmsg::len() {
            stack.push(("OpGetqdiscDumpReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetqdiscDumpReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetqdiscDumpReply::Kind(val) => {
                    if last_off == offset {
                        stack.push(("Kind", last_off));
                        break;
                    }
                }
                OpGetqdiscDumpReply::Options(val) => {
                    if last_off == offset {
                        stack.push(("Options", last_off));
                        break;
                    }
                }
                OpGetqdiscDumpReply::Stats(val) => {
                    if last_off == offset {
                        stack.push(("Stats", last_off));
                        break;
                    }
                }
                OpGetqdiscDumpReply::Xstats(val) => {
                    if last_off == offset {
                        stack.push(("Xstats", last_off));
                        break;
                    }
                }
                OpGetqdiscDumpReply::Rate(val) => {
                    if last_off == offset {
                        stack.push(("Rate", last_off));
                        break;
                    }
                }
                OpGetqdiscDumpReply::Fcnt(val) => {
                    if last_off == offset {
                        stack.push(("Fcnt", last_off));
                        break;
                    }
                }
                OpGetqdiscDumpReply::Stats2(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetqdiscDumpReply::Stab(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetqdiscDumpReply::Chain(val) => {
                    if last_off == offset {
                        stack.push(("Chain", last_off));
                        break;
                    }
                }
                OpGetqdiscDumpReply::IngressBlock(val) => {
                    if last_off == offset {
                        stack.push(("IngressBlock", last_off));
                        break;
                    }
                }
                OpGetqdiscDumpReply::EgressBlock(val) => {
                    if last_off == offset {
                        stack.push(("EgressBlock", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetqdiscDumpReply", cur));
        }
        (stack, missing)
    }
}
#[derive(Debug)]
pub struct RequestOpGetqdiscDumpRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpGetqdiscDumpRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushTcmsg) -> Self {
        PushOpGetqdiscDumpRequest::write_header(&mut request.buf_mut(), header);
        Self {
            request: request.set_dump(),
        }
    }
    pub fn encode(&mut self) -> PushOpGetqdiscDumpRequest<&mut Vec<u8>> {
        PushOpGetqdiscDumpRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpGetqdiscDumpRequest<RequestBuf<'r>> {
        PushOpGetqdiscDumpRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpGetqdiscDumpRequest<'_> {
    type ReplyType<'buf> = (PushTcmsg, Iterable<'buf, OpGetqdiscDumpReply<'buf>>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 0u16,
            request_type: 38u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpGetqdiscDumpReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpGetqdiscDumpRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Get / dump tc qdisc information."]
pub struct PushOpGetqdiscDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetqdiscDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetqdiscDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushTcmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushTcmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_dump_invisible(mut self, value: ()) -> Self {
        push_header(self.as_rec_mut(), 10u16, 0 as u16);
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetqdiscDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump tc qdisc information."]
#[doc = "Original name: \"op-getqdisc-do-request\""]
#[derive(Clone)]
pub enum OpGetqdiscDoRequest {
    DumpInvisible(()),
}
impl<'a> Iterable<'a, OpGetqdiscDoRequest> {
    pub fn get_dump_invisible(&self) -> Result<(), ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetqdiscDoRequest::DumpInvisible(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetqdiscDoRequest", "DumpInvisible"))
    }
}
impl OpGetqdiscDoRequest {
    pub fn new(buf: &'_ [u8]) -> (PushTcmsg, Iterable<'_, OpGetqdiscDoRequest>) {
        let mut header = PushTcmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushTcmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushTcmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Attrs::attr_from_type(r#type)
    }
}
impl Iterator for Iterable<'_, OpGetqdiscDoRequest> {
    type Item = Result<OpGetqdiscDoRequest, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                10u16 => OpGetqdiscDoRequest::DumpInvisible(()),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpGetqdiscDoRequest",
            r#type.and_then(|t| OpGetqdiscDoRequest::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl std::fmt::Debug for Iterable<'_, OpGetqdiscDoRequest> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetqdiscDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetqdiscDoRequest::DumpInvisible(val) => fmt.field("DumpInvisible", &val),
            };
        }
        fmt.finish()
    }
}
impl Iterable<'_, OpGetqdiscDoRequest> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushTcmsg::len() {
            stack.push(("OpGetqdiscDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetqdiscDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetqdiscDoRequest::DumpInvisible(val) => {
                    if last_off == offset {
                        stack.push(("DumpInvisible", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetqdiscDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get / dump tc qdisc information."]
pub struct PushOpGetqdiscDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetqdiscDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetqdiscDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushTcmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushTcmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_kind(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_kind_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_basic(mut self) -> PushBasicAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"basic");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushBasicAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_bpf(mut self) -> PushBpfAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"bpf");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushBpfAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_bfifo(mut self, fixed_header: &PushTcFifoQopt) -> Self {
        self = self.push_kind(c"bfifo");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_cake(mut self) -> PushCakeAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"cake");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushCakeAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_cbs(mut self) -> PushCbsAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"cbs");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushCbsAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_cgroup(mut self) -> PushCgroupAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"cgroup");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushCgroupAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_choke(mut self) -> PushChokeAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"choke");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushChokeAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_clsact(mut self) -> Self {
        self = self.push_kind(c"clsact");
        push_nested_header(self.as_rec_mut(), 2u16);
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_codel(mut self) -> PushCodelAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"codel");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushCodelAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_drr(mut self) -> PushDrrAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"drr");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushDrrAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_dualpi2(mut self) -> PushDualpi2Attrs<PushDummy<Prev>> {
        self = self.push_kind(c"dualpi2");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushDualpi2Attrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_etf(mut self) -> PushEtfAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"etf");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushEtfAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_ets(mut self) -> PushEtsAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"ets");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushEtsAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_flow(mut self) -> PushFlowAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"flow");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFlowAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_flower(mut self) -> PushFlowerAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"flower");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFlowerAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_fq(mut self) -> PushFqAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"fq");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFqAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_fq_codel(mut self) -> PushFqCodelAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"fq_codel");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFqCodelAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_fq_pie(mut self) -> PushFqPieAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"fq_pie");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFqPieAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_fw(mut self) -> PushFwAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"fw");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFwAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_gred(mut self) -> PushGredAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"gred");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushGredAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_hfsc(mut self, fixed_header: &PushTcHfscQopt) -> Self {
        self = self.push_kind(c"hfsc");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_hhf(mut self) -> PushHhfAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"hhf");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushHhfAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_htb(mut self) -> PushHtbAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"htb");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushHtbAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_ingress(mut self) -> Self {
        self = self.push_kind(c"ingress");
        push_nested_header(self.as_rec_mut(), 2u16);
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_matchall(mut self) -> PushMatchallAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"matchall");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushMatchallAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_mq(mut self) -> Self {
        self = self.push_kind(c"mq");
        push_nested_header(self.as_rec_mut(), 2u16);
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_mqprio(mut self, fixed_header: &PushTcMqprioQopt) -> Self {
        self = self.push_kind(c"mqprio");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_multiq(mut self, fixed_header: &PushTcMultiqQopt) -> Self {
        self = self.push_kind(c"multiq");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_netem(
        mut self,
        fixed_header: &PushTcNetemQopt,
    ) -> PushNetemAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"netem");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        let Self {
            prev,
            header_offset,
        } = self;
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushNetemAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_pfifo(mut self, fixed_header: &PushTcFifoQopt) -> Self {
        self = self.push_kind(c"pfifo");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_pfifo_fast(mut self, fixed_header: &PushTcPrioQopt) -> Self {
        self = self.push_kind(c"pfifo_fast");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_pfifo_head_drop(mut self, fixed_header: &PushTcFifoQopt) -> Self {
        self = self.push_kind(c"pfifo_head_drop");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_pie(mut self) -> PushPieAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"pie");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushPieAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_plug(mut self, fixed_header: &PushTcPlugQopt) -> Self {
        self = self.push_kind(c"plug");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_prio(mut self, fixed_header: &PushTcPrioQopt) -> Self {
        self = self.push_kind(c"prio");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_qfq(mut self) -> PushQfqAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"qfq");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushQfqAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_red(mut self) -> PushRedAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"red");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushRedAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_route(mut self) -> PushRouteAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"route");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushRouteAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_sfb(mut self, fixed_header: &PushTcSfbQopt) -> Self {
        self = self.push_kind(c"sfb");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_sfq(mut self, fixed_header: &PushTcSfqQoptV1) -> Self {
        self = self.push_kind(c"sfq");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_taprio(mut self) -> PushTaprioAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"taprio");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushTaprioAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_tbf(mut self) -> PushTbfAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"tbf");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushTbfAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_u32(mut self) -> PushU32Attrs<PushDummy<Prev>> {
        self = self.push_kind(c"u32");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushU32Attrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    pub fn push_stats(mut self, value: PushTcStats) -> Self {
        push_header(self.as_rec_mut(), 3u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_cake(mut self) -> PushCakeStatsAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"cake");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushCakeStatsAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_choke(mut self, fixed_header: &PushTcChokeXstats) -> Self {
        self = self.push_kind(c"choke");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_codel(mut self, fixed_header: &PushTcCodelXstats) -> Self {
        self = self.push_kind(c"codel");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_dualpi2(mut self, fixed_header: &PushTcDualpi2Xstats) -> Self {
        self = self.push_kind(c"dualpi2");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_fq(mut self, fixed_header: &PushTcFqQdStats) -> Self {
        self = self.push_kind(c"fq");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_fq_codel(mut self, fixed_header: &PushTcFqCodelXstats) -> Self {
        self = self.push_kind(c"fq_codel");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_fq_pie(mut self, fixed_header: &PushTcFqPieXstats) -> Self {
        self = self.push_kind(c"fq_pie");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_hhf(mut self, fixed_header: &PushTcHhfXstats) -> Self {
        self = self.push_kind(c"hhf");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_pie(mut self, fixed_header: &PushTcPieXstats) -> Self {
        self = self.push_kind(c"pie");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_red(mut self, fixed_header: &PushTcRedXstats) -> Self {
        self = self.push_kind(c"red");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_sfb(mut self, fixed_header: &PushTcSfbXstats) -> Self {
        self = self.push_kind(c"sfb");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_sfq(mut self, fixed_header: &PushTcSfqXstats) -> Self {
        self = self.push_kind(c"sfq");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    pub fn push_rate(mut self, value: PushGnetEstimator) -> Self {
        push_header(self.as_rec_mut(), 5u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_fcnt(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn nested_stats2(mut self) -> PushTcaStatsAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 7u16);
        PushTcaStatsAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn nested_stab(mut self) -> PushTcaStabAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 8u16);
        PushTcaStabAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_chain(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 11u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_ingress_block(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 13u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_egress_block(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 14u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetqdiscDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump tc qdisc information."]
#[doc = "Original name: \"op-getqdisc-do-reply\""]
#[derive(Clone)]
pub enum OpGetqdiscDoReply<'a> {
    Kind(&'a CStr),
    Options(OptionsMsg<'a>),
    Stats(PushTcStats),
    Xstats(TcaStatsAppMsg<'a>),
    Rate(PushGnetEstimator),
    Fcnt(u32),
    Stats2(Iterable<'a, TcaStatsAttrs<'a>>),
    Stab(Iterable<'a, TcaStabAttrs<'a>>),
    Chain(u32),
    IngressBlock(u32),
    EgressBlock(u32),
}
impl<'a> Iterable<'a, OpGetqdiscDoReply<'a>> {
    pub fn get_kind(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetqdiscDoReply::Kind(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetqdiscDoReply", "Kind"))
    }
    pub fn get_options(&self) -> Result<OptionsMsg<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetqdiscDoReply::Options(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetqdiscDoReply", "Options"))
    }
    pub fn get_stats(&self) -> Result<PushTcStats, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetqdiscDoReply::Stats(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetqdiscDoReply", "Stats"))
    }
    pub fn get_xstats(&self) -> Result<TcaStatsAppMsg<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetqdiscDoReply::Xstats(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetqdiscDoReply", "Xstats"))
    }
    pub fn get_rate(&self) -> Result<PushGnetEstimator, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetqdiscDoReply::Rate(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetqdiscDoReply", "Rate"))
    }
    pub fn get_fcnt(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetqdiscDoReply::Fcnt(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetqdiscDoReply", "Fcnt"))
    }
    pub fn get_stats2(&self) -> Result<Iterable<'a, TcaStatsAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetqdiscDoReply::Stats2(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetqdiscDoReply", "Stats2"))
    }
    pub fn get_stab(&self) -> Result<Iterable<'a, TcaStabAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetqdiscDoReply::Stab(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetqdiscDoReply", "Stab"))
    }
    pub fn get_chain(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetqdiscDoReply::Chain(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetqdiscDoReply", "Chain"))
    }
    pub fn get_ingress_block(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetqdiscDoReply::IngressBlock(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetqdiscDoReply", "IngressBlock"))
    }
    pub fn get_egress_block(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetqdiscDoReply::EgressBlock(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetqdiscDoReply", "EgressBlock"))
    }
}
impl<'a> OpGetqdiscDoReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushTcmsg, Iterable<'a, OpGetqdiscDoReply<'a>>) {
        let mut header = PushTcmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushTcmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushTcmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Attrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpGetqdiscDoReply<'a>> {
    type Item = Result<OpGetqdiscDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetqdiscDoReply::Kind({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetqdiscDoReply::Options({
                    let res = {
                        let Ok(selector) = self.get_kind() else { break };
                        OptionsMsg::select_with_loc(selector, next, self.orig_loc)
                    };
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetqdiscDoReply::Stats({
                    let res = PushTcStats::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpGetqdiscDoReply::Xstats({
                    let res = {
                        let Ok(selector) = self.get_kind() else { break };
                        TcaStatsAppMsg::select_with_loc(selector, next, self.orig_loc)
                    };
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpGetqdiscDoReply::Rate({
                    let res = PushGnetEstimator::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpGetqdiscDoReply::Fcnt({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpGetqdiscDoReply::Stats2({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpGetqdiscDoReply::Stab({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => OpGetqdiscDoReply::Chain({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                13u16 => OpGetqdiscDoReply::IngressBlock({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                14u16 => OpGetqdiscDoReply::EgressBlock({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpGetqdiscDoReply",
            r#type.and_then(|t| OpGetqdiscDoReply::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpGetqdiscDoReply<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetqdiscDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetqdiscDoReply::Kind(val) => fmt.field("Kind", &val),
                OpGetqdiscDoReply::Options(val) => fmt.field("Options", &val),
                OpGetqdiscDoReply::Stats(val) => fmt.field("Stats", &val),
                OpGetqdiscDoReply::Xstats(val) => fmt.field("Xstats", &val),
                OpGetqdiscDoReply::Rate(val) => fmt.field("Rate", &val),
                OpGetqdiscDoReply::Fcnt(val) => fmt.field("Fcnt", &val),
                OpGetqdiscDoReply::Stats2(val) => fmt.field("Stats2", &val),
                OpGetqdiscDoReply::Stab(val) => fmt.field("Stab", &val),
                OpGetqdiscDoReply::Chain(val) => fmt.field("Chain", &val),
                OpGetqdiscDoReply::IngressBlock(val) => fmt.field("IngressBlock", &val),
                OpGetqdiscDoReply::EgressBlock(val) => fmt.field("EgressBlock", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpGetqdiscDoReply<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushTcmsg::len() {
            stack.push(("OpGetqdiscDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetqdiscDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetqdiscDoReply::Kind(val) => {
                    if last_off == offset {
                        stack.push(("Kind", last_off));
                        break;
                    }
                }
                OpGetqdiscDoReply::Options(val) => {
                    if last_off == offset {
                        stack.push(("Options", last_off));
                        break;
                    }
                }
                OpGetqdiscDoReply::Stats(val) => {
                    if last_off == offset {
                        stack.push(("Stats", last_off));
                        break;
                    }
                }
                OpGetqdiscDoReply::Xstats(val) => {
                    if last_off == offset {
                        stack.push(("Xstats", last_off));
                        break;
                    }
                }
                OpGetqdiscDoReply::Rate(val) => {
                    if last_off == offset {
                        stack.push(("Rate", last_off));
                        break;
                    }
                }
                OpGetqdiscDoReply::Fcnt(val) => {
                    if last_off == offset {
                        stack.push(("Fcnt", last_off));
                        break;
                    }
                }
                OpGetqdiscDoReply::Stats2(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetqdiscDoReply::Stab(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetqdiscDoReply::Chain(val) => {
                    if last_off == offset {
                        stack.push(("Chain", last_off));
                        break;
                    }
                }
                OpGetqdiscDoReply::IngressBlock(val) => {
                    if last_off == offset {
                        stack.push(("IngressBlock", last_off));
                        break;
                    }
                }
                OpGetqdiscDoReply::EgressBlock(val) => {
                    if last_off == offset {
                        stack.push(("EgressBlock", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetqdiscDoReply", cur));
        }
        (stack, missing)
    }
}
#[derive(Debug)]
pub struct RequestOpGetqdiscDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpGetqdiscDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushTcmsg) -> Self {
        PushOpGetqdiscDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpGetqdiscDoRequest<&mut Vec<u8>> {
        PushOpGetqdiscDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpGetqdiscDoRequest<RequestBuf<'r>> {
        PushOpGetqdiscDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpGetqdiscDoRequest<'_> {
    type ReplyType<'buf> = (PushTcmsg, Iterable<'buf, OpGetqdiscDoReply<'buf>>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 0u16,
            request_type: 38u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpGetqdiscDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpGetqdiscDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Get / dump tc traffic class information."]
pub struct PushOpNewtclassDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpNewtclassDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpNewtclassDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushTcmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushTcmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_kind(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_kind_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_basic(mut self) -> PushBasicAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"basic");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushBasicAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_bpf(mut self) -> PushBpfAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"bpf");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushBpfAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_bfifo(mut self, fixed_header: &PushTcFifoQopt) -> Self {
        self = self.push_kind(c"bfifo");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_cake(mut self) -> PushCakeAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"cake");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushCakeAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_cbs(mut self) -> PushCbsAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"cbs");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushCbsAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_cgroup(mut self) -> PushCgroupAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"cgroup");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushCgroupAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_choke(mut self) -> PushChokeAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"choke");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushChokeAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_clsact(mut self) -> Self {
        self = self.push_kind(c"clsact");
        push_nested_header(self.as_rec_mut(), 2u16);
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_codel(mut self) -> PushCodelAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"codel");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushCodelAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_drr(mut self) -> PushDrrAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"drr");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushDrrAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_dualpi2(mut self) -> PushDualpi2Attrs<PushDummy<Prev>> {
        self = self.push_kind(c"dualpi2");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushDualpi2Attrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_etf(mut self) -> PushEtfAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"etf");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushEtfAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_ets(mut self) -> PushEtsAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"ets");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushEtsAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_flow(mut self) -> PushFlowAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"flow");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFlowAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_flower(mut self) -> PushFlowerAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"flower");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFlowerAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_fq(mut self) -> PushFqAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"fq");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFqAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_fq_codel(mut self) -> PushFqCodelAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"fq_codel");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFqCodelAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_fq_pie(mut self) -> PushFqPieAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"fq_pie");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFqPieAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_fw(mut self) -> PushFwAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"fw");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFwAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_gred(mut self) -> PushGredAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"gred");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushGredAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_hfsc(mut self, fixed_header: &PushTcHfscQopt) -> Self {
        self = self.push_kind(c"hfsc");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_hhf(mut self) -> PushHhfAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"hhf");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushHhfAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_htb(mut self) -> PushHtbAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"htb");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushHtbAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_ingress(mut self) -> Self {
        self = self.push_kind(c"ingress");
        push_nested_header(self.as_rec_mut(), 2u16);
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_matchall(mut self) -> PushMatchallAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"matchall");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushMatchallAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_mq(mut self) -> Self {
        self = self.push_kind(c"mq");
        push_nested_header(self.as_rec_mut(), 2u16);
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_mqprio(mut self, fixed_header: &PushTcMqprioQopt) -> Self {
        self = self.push_kind(c"mqprio");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_multiq(mut self, fixed_header: &PushTcMultiqQopt) -> Self {
        self = self.push_kind(c"multiq");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_netem(
        mut self,
        fixed_header: &PushTcNetemQopt,
    ) -> PushNetemAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"netem");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        let Self {
            prev,
            header_offset,
        } = self;
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushNetemAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_pfifo(mut self, fixed_header: &PushTcFifoQopt) -> Self {
        self = self.push_kind(c"pfifo");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_pfifo_fast(mut self, fixed_header: &PushTcPrioQopt) -> Self {
        self = self.push_kind(c"pfifo_fast");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_pfifo_head_drop(mut self, fixed_header: &PushTcFifoQopt) -> Self {
        self = self.push_kind(c"pfifo_head_drop");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_pie(mut self) -> PushPieAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"pie");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushPieAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_plug(mut self, fixed_header: &PushTcPlugQopt) -> Self {
        self = self.push_kind(c"plug");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_prio(mut self, fixed_header: &PushTcPrioQopt) -> Self {
        self = self.push_kind(c"prio");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_qfq(mut self) -> PushQfqAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"qfq");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushQfqAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_red(mut self) -> PushRedAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"red");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushRedAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_route(mut self) -> PushRouteAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"route");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushRouteAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_sfb(mut self, fixed_header: &PushTcSfbQopt) -> Self {
        self = self.push_kind(c"sfb");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_sfq(mut self, fixed_header: &PushTcSfqQoptV1) -> Self {
        self = self.push_kind(c"sfq");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_taprio(mut self) -> PushTaprioAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"taprio");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushTaprioAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_tbf(mut self) -> PushTbfAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"tbf");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushTbfAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_u32(mut self) -> PushU32Attrs<PushDummy<Prev>> {
        self = self.push_kind(c"u32");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushU32Attrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    pub fn push_rate(mut self, value: PushGnetEstimator) -> Self {
        push_header(self.as_rec_mut(), 5u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_chain(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 11u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_ingress_block(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 13u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_egress_block(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 14u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpNewtclassDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump tc traffic class information."]
#[doc = "Original name: \"op-newtclass-do-request\""]
#[derive(Clone)]
pub enum OpNewtclassDoRequest<'a> {
    Kind(&'a CStr),
    Options(OptionsMsg<'a>),
    Rate(PushGnetEstimator),
    Chain(u32),
    IngressBlock(u32),
    EgressBlock(u32),
}
impl<'a> Iterable<'a, OpNewtclassDoRequest<'a>> {
    pub fn get_kind(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewtclassDoRequest::Kind(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewtclassDoRequest", "Kind"))
    }
    pub fn get_options(&self) -> Result<OptionsMsg<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewtclassDoRequest::Options(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewtclassDoRequest", "Options"))
    }
    pub fn get_rate(&self) -> Result<PushGnetEstimator, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewtclassDoRequest::Rate(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewtclassDoRequest", "Rate"))
    }
    pub fn get_chain(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewtclassDoRequest::Chain(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewtclassDoRequest", "Chain"))
    }
    pub fn get_ingress_block(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewtclassDoRequest::IngressBlock(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewtclassDoRequest", "IngressBlock"))
    }
    pub fn get_egress_block(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewtclassDoRequest::EgressBlock(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewtclassDoRequest", "EgressBlock"))
    }
}
impl<'a> OpNewtclassDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushTcmsg, Iterable<'a, OpNewtclassDoRequest<'a>>) {
        let mut header = PushTcmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushTcmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushTcmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Attrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpNewtclassDoRequest<'a>> {
    type Item = Result<OpNewtclassDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpNewtclassDoRequest::Kind({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpNewtclassDoRequest::Options({
                    let res = {
                        let Ok(selector) = self.get_kind() else { break };
                        OptionsMsg::select_with_loc(selector, next, self.orig_loc)
                    };
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpNewtclassDoRequest::Rate({
                    let res = PushGnetEstimator::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => OpNewtclassDoRequest::Chain({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                13u16 => OpNewtclassDoRequest::IngressBlock({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                14u16 => OpNewtclassDoRequest::EgressBlock({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpNewtclassDoRequest",
            r#type.and_then(|t| OpNewtclassDoRequest::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpNewtclassDoRequest<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpNewtclassDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpNewtclassDoRequest::Kind(val) => fmt.field("Kind", &val),
                OpNewtclassDoRequest::Options(val) => fmt.field("Options", &val),
                OpNewtclassDoRequest::Rate(val) => fmt.field("Rate", &val),
                OpNewtclassDoRequest::Chain(val) => fmt.field("Chain", &val),
                OpNewtclassDoRequest::IngressBlock(val) => fmt.field("IngressBlock", &val),
                OpNewtclassDoRequest::EgressBlock(val) => fmt.field("EgressBlock", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpNewtclassDoRequest<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushTcmsg::len() {
            stack.push(("OpNewtclassDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpNewtclassDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpNewtclassDoRequest::Kind(val) => {
                    if last_off == offset {
                        stack.push(("Kind", last_off));
                        break;
                    }
                }
                OpNewtclassDoRequest::Options(val) => {
                    if last_off == offset {
                        stack.push(("Options", last_off));
                        break;
                    }
                }
                OpNewtclassDoRequest::Rate(val) => {
                    if last_off == offset {
                        stack.push(("Rate", last_off));
                        break;
                    }
                }
                OpNewtclassDoRequest::Chain(val) => {
                    if last_off == offset {
                        stack.push(("Chain", last_off));
                        break;
                    }
                }
                OpNewtclassDoRequest::IngressBlock(val) => {
                    if last_off == offset {
                        stack.push(("IngressBlock", last_off));
                        break;
                    }
                }
                OpNewtclassDoRequest::EgressBlock(val) => {
                    if last_off == offset {
                        stack.push(("EgressBlock", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpNewtclassDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get / dump tc traffic class information."]
pub struct PushOpNewtclassDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpNewtclassDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpNewtclassDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushTcmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushTcmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpNewtclassDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump tc traffic class information."]
#[doc = "Original name: \"op-newtclass-do-reply\""]
#[derive(Clone)]
pub enum OpNewtclassDoReply {}
impl<'a> Iterable<'a, OpNewtclassDoReply> {}
impl OpNewtclassDoReply {
    pub fn new(buf: &'_ [u8]) -> (PushTcmsg, Iterable<'_, OpNewtclassDoReply>) {
        let mut header = PushTcmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushTcmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushTcmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Attrs::attr_from_type(r#type)
    }
}
impl Iterator for Iterable<'_, OpNewtclassDoReply> {
    type Item = Result<OpNewtclassDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpNewtclassDoReply",
            r#type.and_then(|t| OpNewtclassDoReply::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl std::fmt::Debug for Iterable<'_, OpNewtclassDoReply> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpNewtclassDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl Iterable<'_, OpNewtclassDoReply> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushTcmsg::len() {
            stack.push(("OpNewtclassDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpNewtclassDoReply::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpNewtclassDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpNewtclassDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushTcmsg) -> Self {
        PushOpNewtclassDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpNewtclassDoRequest<&mut Vec<u8>> {
        PushOpNewtclassDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpNewtclassDoRequest<RequestBuf<'r>> {
        PushOpNewtclassDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpNewtclassDoRequest<'_> {
    type ReplyType<'buf> = (PushTcmsg, Iterable<'buf, OpNewtclassDoReply>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 0u16,
            request_type: 40u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpNewtclassDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpNewtclassDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Get / dump tc traffic class information."]
pub struct PushOpDeltclassDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDeltclassDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDeltclassDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushTcmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushTcmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpDeltclassDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump tc traffic class information."]
#[doc = "Original name: \"op-deltclass-do-request\""]
#[derive(Clone)]
pub enum OpDeltclassDoRequest {}
impl<'a> Iterable<'a, OpDeltclassDoRequest> {}
impl OpDeltclassDoRequest {
    pub fn new(buf: &'_ [u8]) -> (PushTcmsg, Iterable<'_, OpDeltclassDoRequest>) {
        let mut header = PushTcmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushTcmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushTcmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Attrs::attr_from_type(r#type)
    }
}
impl Iterator for Iterable<'_, OpDeltclassDoRequest> {
    type Item = Result<OpDeltclassDoRequest, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpDeltclassDoRequest",
            r#type.and_then(|t| OpDeltclassDoRequest::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl std::fmt::Debug for Iterable<'_, OpDeltclassDoRequest> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDeltclassDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl Iterable<'_, OpDeltclassDoRequest> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushTcmsg::len() {
            stack.push(("OpDeltclassDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDeltclassDoRequest::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[doc = "Get / dump tc traffic class information."]
pub struct PushOpDeltclassDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDeltclassDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDeltclassDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushTcmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushTcmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpDeltclassDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump tc traffic class information."]
#[doc = "Original name: \"op-deltclass-do-reply\""]
#[derive(Clone)]
pub enum OpDeltclassDoReply {}
impl<'a> Iterable<'a, OpDeltclassDoReply> {}
impl OpDeltclassDoReply {
    pub fn new(buf: &'_ [u8]) -> (PushTcmsg, Iterable<'_, OpDeltclassDoReply>) {
        let mut header = PushTcmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushTcmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushTcmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Attrs::attr_from_type(r#type)
    }
}
impl Iterator for Iterable<'_, OpDeltclassDoReply> {
    type Item = Result<OpDeltclassDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpDeltclassDoReply",
            r#type.and_then(|t| OpDeltclassDoReply::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl std::fmt::Debug for Iterable<'_, OpDeltclassDoReply> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDeltclassDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl Iterable<'_, OpDeltclassDoReply> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushTcmsg::len() {
            stack.push(("OpDeltclassDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDeltclassDoReply::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpDeltclassDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpDeltclassDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushTcmsg) -> Self {
        PushOpDeltclassDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpDeltclassDoRequest<&mut Vec<u8>> {
        PushOpDeltclassDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpDeltclassDoRequest<RequestBuf<'r>> {
        PushOpDeltclassDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpDeltclassDoRequest<'_> {
    type ReplyType<'buf> = (PushTcmsg, Iterable<'buf, OpDeltclassDoReply>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 0u16,
            request_type: 41u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpDeltclassDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpDeltclassDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Get / dump tc traffic class information."]
pub struct PushOpGettclassDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGettclassDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGettclassDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushTcmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushTcmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpGettclassDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump tc traffic class information."]
#[doc = "Original name: \"op-gettclass-do-request\""]
#[derive(Clone)]
pub enum OpGettclassDoRequest {}
impl<'a> Iterable<'a, OpGettclassDoRequest> {}
impl OpGettclassDoRequest {
    pub fn new(buf: &'_ [u8]) -> (PushTcmsg, Iterable<'_, OpGettclassDoRequest>) {
        let mut header = PushTcmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushTcmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushTcmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Attrs::attr_from_type(r#type)
    }
}
impl Iterator for Iterable<'_, OpGettclassDoRequest> {
    type Item = Result<OpGettclassDoRequest, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpGettclassDoRequest",
            r#type.and_then(|t| OpGettclassDoRequest::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl std::fmt::Debug for Iterable<'_, OpGettclassDoRequest> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGettclassDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl Iterable<'_, OpGettclassDoRequest> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushTcmsg::len() {
            stack.push(("OpGettclassDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGettclassDoRequest::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[doc = "Get / dump tc traffic class information."]
pub struct PushOpGettclassDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGettclassDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGettclassDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushTcmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushTcmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_kind(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_kind_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_basic(mut self) -> PushBasicAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"basic");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushBasicAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_bpf(mut self) -> PushBpfAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"bpf");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushBpfAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_bfifo(mut self, fixed_header: &PushTcFifoQopt) -> Self {
        self = self.push_kind(c"bfifo");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_cake(mut self) -> PushCakeAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"cake");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushCakeAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_cbs(mut self) -> PushCbsAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"cbs");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushCbsAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_cgroup(mut self) -> PushCgroupAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"cgroup");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushCgroupAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_choke(mut self) -> PushChokeAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"choke");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushChokeAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_clsact(mut self) -> Self {
        self = self.push_kind(c"clsact");
        push_nested_header(self.as_rec_mut(), 2u16);
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_codel(mut self) -> PushCodelAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"codel");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushCodelAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_drr(mut self) -> PushDrrAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"drr");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushDrrAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_dualpi2(mut self) -> PushDualpi2Attrs<PushDummy<Prev>> {
        self = self.push_kind(c"dualpi2");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushDualpi2Attrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_etf(mut self) -> PushEtfAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"etf");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushEtfAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_ets(mut self) -> PushEtsAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"ets");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushEtsAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_flow(mut self) -> PushFlowAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"flow");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFlowAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_flower(mut self) -> PushFlowerAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"flower");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFlowerAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_fq(mut self) -> PushFqAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"fq");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFqAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_fq_codel(mut self) -> PushFqCodelAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"fq_codel");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFqCodelAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_fq_pie(mut self) -> PushFqPieAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"fq_pie");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFqPieAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_fw(mut self) -> PushFwAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"fw");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFwAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_gred(mut self) -> PushGredAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"gred");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushGredAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_hfsc(mut self, fixed_header: &PushTcHfscQopt) -> Self {
        self = self.push_kind(c"hfsc");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_hhf(mut self) -> PushHhfAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"hhf");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushHhfAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_htb(mut self) -> PushHtbAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"htb");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushHtbAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_ingress(mut self) -> Self {
        self = self.push_kind(c"ingress");
        push_nested_header(self.as_rec_mut(), 2u16);
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_matchall(mut self) -> PushMatchallAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"matchall");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushMatchallAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_mq(mut self) -> Self {
        self = self.push_kind(c"mq");
        push_nested_header(self.as_rec_mut(), 2u16);
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_mqprio(mut self, fixed_header: &PushTcMqprioQopt) -> Self {
        self = self.push_kind(c"mqprio");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_multiq(mut self, fixed_header: &PushTcMultiqQopt) -> Self {
        self = self.push_kind(c"multiq");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_netem(
        mut self,
        fixed_header: &PushTcNetemQopt,
    ) -> PushNetemAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"netem");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        let Self {
            prev,
            header_offset,
        } = self;
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushNetemAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_pfifo(mut self, fixed_header: &PushTcFifoQopt) -> Self {
        self = self.push_kind(c"pfifo");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_pfifo_fast(mut self, fixed_header: &PushTcPrioQopt) -> Self {
        self = self.push_kind(c"pfifo_fast");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_pfifo_head_drop(mut self, fixed_header: &PushTcFifoQopt) -> Self {
        self = self.push_kind(c"pfifo_head_drop");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_pie(mut self) -> PushPieAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"pie");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushPieAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_plug(mut self, fixed_header: &PushTcPlugQopt) -> Self {
        self = self.push_kind(c"plug");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_prio(mut self, fixed_header: &PushTcPrioQopt) -> Self {
        self = self.push_kind(c"prio");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_qfq(mut self) -> PushQfqAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"qfq");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushQfqAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_red(mut self) -> PushRedAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"red");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushRedAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_route(mut self) -> PushRouteAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"route");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushRouteAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_sfb(mut self, fixed_header: &PushTcSfbQopt) -> Self {
        self = self.push_kind(c"sfb");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_sfq(mut self, fixed_header: &PushTcSfqQoptV1) -> Self {
        self = self.push_kind(c"sfq");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_taprio(mut self) -> PushTaprioAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"taprio");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushTaprioAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_tbf(mut self) -> PushTbfAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"tbf");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushTbfAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_u32(mut self) -> PushU32Attrs<PushDummy<Prev>> {
        self = self.push_kind(c"u32");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushU32Attrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    pub fn push_stats(mut self, value: PushTcStats) -> Self {
        push_header(self.as_rec_mut(), 3u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_cake(mut self) -> PushCakeStatsAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"cake");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushCakeStatsAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_choke(mut self, fixed_header: &PushTcChokeXstats) -> Self {
        self = self.push_kind(c"choke");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_codel(mut self, fixed_header: &PushTcCodelXstats) -> Self {
        self = self.push_kind(c"codel");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_dualpi2(mut self, fixed_header: &PushTcDualpi2Xstats) -> Self {
        self = self.push_kind(c"dualpi2");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_fq(mut self, fixed_header: &PushTcFqQdStats) -> Self {
        self = self.push_kind(c"fq");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_fq_codel(mut self, fixed_header: &PushTcFqCodelXstats) -> Self {
        self = self.push_kind(c"fq_codel");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_fq_pie(mut self, fixed_header: &PushTcFqPieXstats) -> Self {
        self = self.push_kind(c"fq_pie");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_hhf(mut self, fixed_header: &PushTcHhfXstats) -> Self {
        self = self.push_kind(c"hhf");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_pie(mut self, fixed_header: &PushTcPieXstats) -> Self {
        self = self.push_kind(c"pie");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_red(mut self, fixed_header: &PushTcRedXstats) -> Self {
        self = self.push_kind(c"red");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_sfb(mut self, fixed_header: &PushTcSfbXstats) -> Self {
        self = self.push_kind(c"sfb");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_sfq(mut self, fixed_header: &PushTcSfqXstats) -> Self {
        self = self.push_kind(c"sfq");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    pub fn push_rate(mut self, value: PushGnetEstimator) -> Self {
        push_header(self.as_rec_mut(), 5u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_fcnt(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn nested_stats2(mut self) -> PushTcaStatsAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 7u16);
        PushTcaStatsAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn nested_stab(mut self) -> PushTcaStabAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 8u16);
        PushTcaStabAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_chain(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 11u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_ingress_block(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 13u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_egress_block(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 14u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpGettclassDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump tc traffic class information."]
#[doc = "Original name: \"op-gettclass-do-reply\""]
#[derive(Clone)]
pub enum OpGettclassDoReply<'a> {
    Kind(&'a CStr),
    Options(OptionsMsg<'a>),
    Stats(PushTcStats),
    Xstats(TcaStatsAppMsg<'a>),
    Rate(PushGnetEstimator),
    Fcnt(u32),
    Stats2(Iterable<'a, TcaStatsAttrs<'a>>),
    Stab(Iterable<'a, TcaStabAttrs<'a>>),
    Chain(u32),
    IngressBlock(u32),
    EgressBlock(u32),
}
impl<'a> Iterable<'a, OpGettclassDoReply<'a>> {
    pub fn get_kind(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettclassDoReply::Kind(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGettclassDoReply", "Kind"))
    }
    pub fn get_options(&self) -> Result<OptionsMsg<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettclassDoReply::Options(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGettclassDoReply", "Options"))
    }
    pub fn get_stats(&self) -> Result<PushTcStats, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettclassDoReply::Stats(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGettclassDoReply", "Stats"))
    }
    pub fn get_xstats(&self) -> Result<TcaStatsAppMsg<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettclassDoReply::Xstats(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGettclassDoReply", "Xstats"))
    }
    pub fn get_rate(&self) -> Result<PushGnetEstimator, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettclassDoReply::Rate(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGettclassDoReply", "Rate"))
    }
    pub fn get_fcnt(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettclassDoReply::Fcnt(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGettclassDoReply", "Fcnt"))
    }
    pub fn get_stats2(&self) -> Result<Iterable<'a, TcaStatsAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettclassDoReply::Stats2(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGettclassDoReply", "Stats2"))
    }
    pub fn get_stab(&self) -> Result<Iterable<'a, TcaStabAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettclassDoReply::Stab(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGettclassDoReply", "Stab"))
    }
    pub fn get_chain(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettclassDoReply::Chain(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGettclassDoReply", "Chain"))
    }
    pub fn get_ingress_block(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettclassDoReply::IngressBlock(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGettclassDoReply", "IngressBlock"))
    }
    pub fn get_egress_block(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettclassDoReply::EgressBlock(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGettclassDoReply", "EgressBlock"))
    }
}
impl<'a> OpGettclassDoReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushTcmsg, Iterable<'a, OpGettclassDoReply<'a>>) {
        let mut header = PushTcmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushTcmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushTcmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Attrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpGettclassDoReply<'a>> {
    type Item = Result<OpGettclassDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGettclassDoReply::Kind({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGettclassDoReply::Options({
                    let res = {
                        let Ok(selector) = self.get_kind() else { break };
                        OptionsMsg::select_with_loc(selector, next, self.orig_loc)
                    };
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGettclassDoReply::Stats({
                    let res = PushTcStats::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpGettclassDoReply::Xstats({
                    let res = {
                        let Ok(selector) = self.get_kind() else { break };
                        TcaStatsAppMsg::select_with_loc(selector, next, self.orig_loc)
                    };
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpGettclassDoReply::Rate({
                    let res = PushGnetEstimator::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpGettclassDoReply::Fcnt({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpGettclassDoReply::Stats2({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpGettclassDoReply::Stab({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => OpGettclassDoReply::Chain({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                13u16 => OpGettclassDoReply::IngressBlock({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                14u16 => OpGettclassDoReply::EgressBlock({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpGettclassDoReply",
            r#type.and_then(|t| OpGettclassDoReply::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpGettclassDoReply<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGettclassDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGettclassDoReply::Kind(val) => fmt.field("Kind", &val),
                OpGettclassDoReply::Options(val) => fmt.field("Options", &val),
                OpGettclassDoReply::Stats(val) => fmt.field("Stats", &val),
                OpGettclassDoReply::Xstats(val) => fmt.field("Xstats", &val),
                OpGettclassDoReply::Rate(val) => fmt.field("Rate", &val),
                OpGettclassDoReply::Fcnt(val) => fmt.field("Fcnt", &val),
                OpGettclassDoReply::Stats2(val) => fmt.field("Stats2", &val),
                OpGettclassDoReply::Stab(val) => fmt.field("Stab", &val),
                OpGettclassDoReply::Chain(val) => fmt.field("Chain", &val),
                OpGettclassDoReply::IngressBlock(val) => fmt.field("IngressBlock", &val),
                OpGettclassDoReply::EgressBlock(val) => fmt.field("EgressBlock", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpGettclassDoReply<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushTcmsg::len() {
            stack.push(("OpGettclassDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGettclassDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGettclassDoReply::Kind(val) => {
                    if last_off == offset {
                        stack.push(("Kind", last_off));
                        break;
                    }
                }
                OpGettclassDoReply::Options(val) => {
                    if last_off == offset {
                        stack.push(("Options", last_off));
                        break;
                    }
                }
                OpGettclassDoReply::Stats(val) => {
                    if last_off == offset {
                        stack.push(("Stats", last_off));
                        break;
                    }
                }
                OpGettclassDoReply::Xstats(val) => {
                    if last_off == offset {
                        stack.push(("Xstats", last_off));
                        break;
                    }
                }
                OpGettclassDoReply::Rate(val) => {
                    if last_off == offset {
                        stack.push(("Rate", last_off));
                        break;
                    }
                }
                OpGettclassDoReply::Fcnt(val) => {
                    if last_off == offset {
                        stack.push(("Fcnt", last_off));
                        break;
                    }
                }
                OpGettclassDoReply::Stats2(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGettclassDoReply::Stab(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGettclassDoReply::Chain(val) => {
                    if last_off == offset {
                        stack.push(("Chain", last_off));
                        break;
                    }
                }
                OpGettclassDoReply::IngressBlock(val) => {
                    if last_off == offset {
                        stack.push(("IngressBlock", last_off));
                        break;
                    }
                }
                OpGettclassDoReply::EgressBlock(val) => {
                    if last_off == offset {
                        stack.push(("EgressBlock", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGettclassDoReply", cur));
        }
        (stack, missing)
    }
}
#[derive(Debug)]
pub struct RequestOpGettclassDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpGettclassDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushTcmsg) -> Self {
        PushOpGettclassDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpGettclassDoRequest<&mut Vec<u8>> {
        PushOpGettclassDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpGettclassDoRequest<RequestBuf<'r>> {
        PushOpGettclassDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpGettclassDoRequest<'_> {
    type ReplyType<'buf> = (PushTcmsg, Iterable<'buf, OpGettclassDoReply<'buf>>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 0u16,
            request_type: 42u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpGettclassDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpGettclassDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Get / dump tc filter information."]
pub struct PushOpNewtfilterDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpNewtfilterDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpNewtfilterDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushTcmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushTcmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_kind(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_kind_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_basic(mut self) -> PushBasicAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"basic");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushBasicAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_bpf(mut self) -> PushBpfAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"bpf");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushBpfAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_bfifo(mut self, fixed_header: &PushTcFifoQopt) -> Self {
        self = self.push_kind(c"bfifo");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_cake(mut self) -> PushCakeAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"cake");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushCakeAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_cbs(mut self) -> PushCbsAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"cbs");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushCbsAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_cgroup(mut self) -> PushCgroupAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"cgroup");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushCgroupAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_choke(mut self) -> PushChokeAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"choke");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushChokeAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_clsact(mut self) -> Self {
        self = self.push_kind(c"clsact");
        push_nested_header(self.as_rec_mut(), 2u16);
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_codel(mut self) -> PushCodelAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"codel");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushCodelAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_drr(mut self) -> PushDrrAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"drr");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushDrrAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_dualpi2(mut self) -> PushDualpi2Attrs<PushDummy<Prev>> {
        self = self.push_kind(c"dualpi2");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushDualpi2Attrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_etf(mut self) -> PushEtfAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"etf");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushEtfAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_ets(mut self) -> PushEtsAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"ets");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushEtsAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_flow(mut self) -> PushFlowAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"flow");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFlowAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_flower(mut self) -> PushFlowerAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"flower");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFlowerAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_fq(mut self) -> PushFqAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"fq");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFqAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_fq_codel(mut self) -> PushFqCodelAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"fq_codel");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFqCodelAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_fq_pie(mut self) -> PushFqPieAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"fq_pie");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFqPieAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_fw(mut self) -> PushFwAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"fw");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFwAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_gred(mut self) -> PushGredAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"gred");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushGredAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_hfsc(mut self, fixed_header: &PushTcHfscQopt) -> Self {
        self = self.push_kind(c"hfsc");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_hhf(mut self) -> PushHhfAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"hhf");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushHhfAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_htb(mut self) -> PushHtbAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"htb");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushHtbAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_ingress(mut self) -> Self {
        self = self.push_kind(c"ingress");
        push_nested_header(self.as_rec_mut(), 2u16);
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_matchall(mut self) -> PushMatchallAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"matchall");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushMatchallAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_mq(mut self) -> Self {
        self = self.push_kind(c"mq");
        push_nested_header(self.as_rec_mut(), 2u16);
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_mqprio(mut self, fixed_header: &PushTcMqprioQopt) -> Self {
        self = self.push_kind(c"mqprio");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_multiq(mut self, fixed_header: &PushTcMultiqQopt) -> Self {
        self = self.push_kind(c"multiq");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_netem(
        mut self,
        fixed_header: &PushTcNetemQopt,
    ) -> PushNetemAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"netem");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        let Self {
            prev,
            header_offset,
        } = self;
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushNetemAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_pfifo(mut self, fixed_header: &PushTcFifoQopt) -> Self {
        self = self.push_kind(c"pfifo");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_pfifo_fast(mut self, fixed_header: &PushTcPrioQopt) -> Self {
        self = self.push_kind(c"pfifo_fast");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_pfifo_head_drop(mut self, fixed_header: &PushTcFifoQopt) -> Self {
        self = self.push_kind(c"pfifo_head_drop");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_pie(mut self) -> PushPieAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"pie");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushPieAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_plug(mut self, fixed_header: &PushTcPlugQopt) -> Self {
        self = self.push_kind(c"plug");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_prio(mut self, fixed_header: &PushTcPrioQopt) -> Self {
        self = self.push_kind(c"prio");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_qfq(mut self) -> PushQfqAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"qfq");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushQfqAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_red(mut self) -> PushRedAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"red");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushRedAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_route(mut self) -> PushRouteAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"route");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushRouteAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_sfb(mut self, fixed_header: &PushTcSfbQopt) -> Self {
        self = self.push_kind(c"sfb");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_sfq(mut self, fixed_header: &PushTcSfqQoptV1) -> Self {
        self = self.push_kind(c"sfq");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_taprio(mut self) -> PushTaprioAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"taprio");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushTaprioAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_tbf(mut self) -> PushTbfAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"tbf");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushTbfAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_u32(mut self) -> PushU32Attrs<PushDummy<Prev>> {
        self = self.push_kind(c"u32");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushU32Attrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    pub fn push_rate(mut self, value: PushGnetEstimator) -> Self {
        push_header(self.as_rec_mut(), 5u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_chain(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 11u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_ingress_block(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 13u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_egress_block(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 14u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpNewtfilterDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump tc filter information."]
#[doc = "Original name: \"op-newtfilter-do-request\""]
#[derive(Clone)]
pub enum OpNewtfilterDoRequest<'a> {
    Kind(&'a CStr),
    Options(OptionsMsg<'a>),
    Rate(PushGnetEstimator),
    Chain(u32),
    IngressBlock(u32),
    EgressBlock(u32),
}
impl<'a> Iterable<'a, OpNewtfilterDoRequest<'a>> {
    pub fn get_kind(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewtfilterDoRequest::Kind(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewtfilterDoRequest", "Kind"))
    }
    pub fn get_options(&self) -> Result<OptionsMsg<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewtfilterDoRequest::Options(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewtfilterDoRequest", "Options"))
    }
    pub fn get_rate(&self) -> Result<PushGnetEstimator, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewtfilterDoRequest::Rate(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewtfilterDoRequest", "Rate"))
    }
    pub fn get_chain(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewtfilterDoRequest::Chain(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewtfilterDoRequest", "Chain"))
    }
    pub fn get_ingress_block(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewtfilterDoRequest::IngressBlock(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewtfilterDoRequest", "IngressBlock"))
    }
    pub fn get_egress_block(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewtfilterDoRequest::EgressBlock(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewtfilterDoRequest", "EgressBlock"))
    }
}
impl<'a> OpNewtfilterDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushTcmsg, Iterable<'a, OpNewtfilterDoRequest<'a>>) {
        let mut header = PushTcmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushTcmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushTcmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Attrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpNewtfilterDoRequest<'a>> {
    type Item = Result<OpNewtfilterDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpNewtfilterDoRequest::Kind({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpNewtfilterDoRequest::Options({
                    let res = {
                        let Ok(selector) = self.get_kind() else { break };
                        OptionsMsg::select_with_loc(selector, next, self.orig_loc)
                    };
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpNewtfilterDoRequest::Rate({
                    let res = PushGnetEstimator::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => OpNewtfilterDoRequest::Chain({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                13u16 => OpNewtfilterDoRequest::IngressBlock({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                14u16 => OpNewtfilterDoRequest::EgressBlock({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpNewtfilterDoRequest",
            r#type.and_then(|t| OpNewtfilterDoRequest::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpNewtfilterDoRequest<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpNewtfilterDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpNewtfilterDoRequest::Kind(val) => fmt.field("Kind", &val),
                OpNewtfilterDoRequest::Options(val) => fmt.field("Options", &val),
                OpNewtfilterDoRequest::Rate(val) => fmt.field("Rate", &val),
                OpNewtfilterDoRequest::Chain(val) => fmt.field("Chain", &val),
                OpNewtfilterDoRequest::IngressBlock(val) => fmt.field("IngressBlock", &val),
                OpNewtfilterDoRequest::EgressBlock(val) => fmt.field("EgressBlock", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpNewtfilterDoRequest<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushTcmsg::len() {
            stack.push(("OpNewtfilterDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpNewtfilterDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpNewtfilterDoRequest::Kind(val) => {
                    if last_off == offset {
                        stack.push(("Kind", last_off));
                        break;
                    }
                }
                OpNewtfilterDoRequest::Options(val) => {
                    if last_off == offset {
                        stack.push(("Options", last_off));
                        break;
                    }
                }
                OpNewtfilterDoRequest::Rate(val) => {
                    if last_off == offset {
                        stack.push(("Rate", last_off));
                        break;
                    }
                }
                OpNewtfilterDoRequest::Chain(val) => {
                    if last_off == offset {
                        stack.push(("Chain", last_off));
                        break;
                    }
                }
                OpNewtfilterDoRequest::IngressBlock(val) => {
                    if last_off == offset {
                        stack.push(("IngressBlock", last_off));
                        break;
                    }
                }
                OpNewtfilterDoRequest::EgressBlock(val) => {
                    if last_off == offset {
                        stack.push(("EgressBlock", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpNewtfilterDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get / dump tc filter information."]
pub struct PushOpNewtfilterDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpNewtfilterDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpNewtfilterDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushTcmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushTcmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpNewtfilterDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump tc filter information."]
#[doc = "Original name: \"op-newtfilter-do-reply\""]
#[derive(Clone)]
pub enum OpNewtfilterDoReply {}
impl<'a> Iterable<'a, OpNewtfilterDoReply> {}
impl OpNewtfilterDoReply {
    pub fn new(buf: &'_ [u8]) -> (PushTcmsg, Iterable<'_, OpNewtfilterDoReply>) {
        let mut header = PushTcmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushTcmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushTcmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Attrs::attr_from_type(r#type)
    }
}
impl Iterator for Iterable<'_, OpNewtfilterDoReply> {
    type Item = Result<OpNewtfilterDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpNewtfilterDoReply",
            r#type.and_then(|t| OpNewtfilterDoReply::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl std::fmt::Debug for Iterable<'_, OpNewtfilterDoReply> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpNewtfilterDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl Iterable<'_, OpNewtfilterDoReply> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushTcmsg::len() {
            stack.push(("OpNewtfilterDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpNewtfilterDoReply::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpNewtfilterDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpNewtfilterDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushTcmsg) -> Self {
        PushOpNewtfilterDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpNewtfilterDoRequest<&mut Vec<u8>> {
        PushOpNewtfilterDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpNewtfilterDoRequest<RequestBuf<'r>> {
        PushOpNewtfilterDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpNewtfilterDoRequest<'_> {
    type ReplyType<'buf> = (PushTcmsg, Iterable<'buf, OpNewtfilterDoReply>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 0u16,
            request_type: 44u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpNewtfilterDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpNewtfilterDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Get / dump tc filter information."]
pub struct PushOpDeltfilterDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDeltfilterDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDeltfilterDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushTcmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushTcmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_kind(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_kind_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_chain(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 11u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpDeltfilterDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump tc filter information."]
#[doc = "Original name: \"op-deltfilter-do-request\""]
#[derive(Clone)]
pub enum OpDeltfilterDoRequest<'a> {
    Kind(&'a CStr),
    Chain(u32),
}
impl<'a> Iterable<'a, OpDeltfilterDoRequest<'a>> {
    pub fn get_kind(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDeltfilterDoRequest::Kind(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDeltfilterDoRequest", "Kind"))
    }
    pub fn get_chain(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDeltfilterDoRequest::Chain(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDeltfilterDoRequest", "Chain"))
    }
}
impl<'a> OpDeltfilterDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushTcmsg, Iterable<'a, OpDeltfilterDoRequest<'a>>) {
        let mut header = PushTcmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushTcmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushTcmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Attrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpDeltfilterDoRequest<'a>> {
    type Item = Result<OpDeltfilterDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpDeltfilterDoRequest::Kind({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => OpDeltfilterDoRequest::Chain({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpDeltfilterDoRequest",
            r#type.and_then(|t| OpDeltfilterDoRequest::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpDeltfilterDoRequest<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDeltfilterDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpDeltfilterDoRequest::Kind(val) => fmt.field("Kind", &val),
                OpDeltfilterDoRequest::Chain(val) => fmt.field("Chain", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpDeltfilterDoRequest<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushTcmsg::len() {
            stack.push(("OpDeltfilterDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDeltfilterDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpDeltfilterDoRequest::Kind(val) => {
                    if last_off == offset {
                        stack.push(("Kind", last_off));
                        break;
                    }
                }
                OpDeltfilterDoRequest::Chain(val) => {
                    if last_off == offset {
                        stack.push(("Chain", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpDeltfilterDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get / dump tc filter information."]
pub struct PushOpDeltfilterDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDeltfilterDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDeltfilterDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushTcmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushTcmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpDeltfilterDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump tc filter information."]
#[doc = "Original name: \"op-deltfilter-do-reply\""]
#[derive(Clone)]
pub enum OpDeltfilterDoReply {}
impl<'a> Iterable<'a, OpDeltfilterDoReply> {}
impl OpDeltfilterDoReply {
    pub fn new(buf: &'_ [u8]) -> (PushTcmsg, Iterable<'_, OpDeltfilterDoReply>) {
        let mut header = PushTcmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushTcmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushTcmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Attrs::attr_from_type(r#type)
    }
}
impl Iterator for Iterable<'_, OpDeltfilterDoReply> {
    type Item = Result<OpDeltfilterDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpDeltfilterDoReply",
            r#type.and_then(|t| OpDeltfilterDoReply::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl std::fmt::Debug for Iterable<'_, OpDeltfilterDoReply> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDeltfilterDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl Iterable<'_, OpDeltfilterDoReply> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushTcmsg::len() {
            stack.push(("OpDeltfilterDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDeltfilterDoReply::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpDeltfilterDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpDeltfilterDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushTcmsg) -> Self {
        PushOpDeltfilterDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpDeltfilterDoRequest<&mut Vec<u8>> {
        PushOpDeltfilterDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpDeltfilterDoRequest<RequestBuf<'r>> {
        PushOpDeltfilterDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpDeltfilterDoRequest<'_> {
    type ReplyType<'buf> = (PushTcmsg, Iterable<'buf, OpDeltfilterDoReply>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 0u16,
            request_type: 45u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpDeltfilterDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpDeltfilterDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Get / dump tc filter information."]
pub struct PushOpGettfilterDumpRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGettfilterDumpRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGettfilterDumpRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushTcmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushTcmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_chain(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 11u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_dump_flags(mut self, value: PushBuiltinBitfield32) -> Self {
        push_header(self.as_rec_mut(), 15u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
}
impl<Prev: Rec> Drop for PushOpGettfilterDumpRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump tc filter information."]
#[doc = "Original name: \"op-gettfilter-dump-request\""]
#[derive(Clone)]
pub enum OpGettfilterDumpRequest {
    Chain(u32),
    DumpFlags(PushBuiltinBitfield32),
}
impl<'a> Iterable<'a, OpGettfilterDumpRequest> {
    pub fn get_chain(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettfilterDumpRequest::Chain(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGettfilterDumpRequest", "Chain"))
    }
    pub fn get_dump_flags(&self) -> Result<PushBuiltinBitfield32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettfilterDumpRequest::DumpFlags(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGettfilterDumpRequest", "DumpFlags"))
    }
}
impl OpGettfilterDumpRequest {
    pub fn new(buf: &'_ [u8]) -> (PushTcmsg, Iterable<'_, OpGettfilterDumpRequest>) {
        let mut header = PushTcmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushTcmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushTcmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Attrs::attr_from_type(r#type)
    }
}
impl Iterator for Iterable<'_, OpGettfilterDumpRequest> {
    type Item = Result<OpGettfilterDumpRequest, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                11u16 => OpGettfilterDumpRequest::Chain({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                15u16 => OpGettfilterDumpRequest::DumpFlags({
                    let res = PushBuiltinBitfield32::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpGettfilterDumpRequest",
            r#type.and_then(|t| OpGettfilterDumpRequest::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl std::fmt::Debug for Iterable<'_, OpGettfilterDumpRequest> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGettfilterDumpRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGettfilterDumpRequest::Chain(val) => fmt.field("Chain", &val),
                OpGettfilterDumpRequest::DumpFlags(val) => fmt.field("DumpFlags", &val),
            };
        }
        fmt.finish()
    }
}
impl Iterable<'_, OpGettfilterDumpRequest> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushTcmsg::len() {
            stack.push(("OpGettfilterDumpRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGettfilterDumpRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGettfilterDumpRequest::Chain(val) => {
                    if last_off == offset {
                        stack.push(("Chain", last_off));
                        break;
                    }
                }
                OpGettfilterDumpRequest::DumpFlags(val) => {
                    if last_off == offset {
                        stack.push(("DumpFlags", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGettfilterDumpRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get / dump tc filter information."]
pub struct PushOpGettfilterDumpReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGettfilterDumpReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGettfilterDumpReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushTcmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushTcmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_kind(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_kind_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_basic(mut self) -> PushBasicAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"basic");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushBasicAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_bpf(mut self) -> PushBpfAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"bpf");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushBpfAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_bfifo(mut self, fixed_header: &PushTcFifoQopt) -> Self {
        self = self.push_kind(c"bfifo");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_cake(mut self) -> PushCakeAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"cake");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushCakeAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_cbs(mut self) -> PushCbsAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"cbs");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushCbsAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_cgroup(mut self) -> PushCgroupAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"cgroup");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushCgroupAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_choke(mut self) -> PushChokeAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"choke");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushChokeAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_clsact(mut self) -> Self {
        self = self.push_kind(c"clsact");
        push_nested_header(self.as_rec_mut(), 2u16);
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_codel(mut self) -> PushCodelAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"codel");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushCodelAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_drr(mut self) -> PushDrrAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"drr");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushDrrAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_dualpi2(mut self) -> PushDualpi2Attrs<PushDummy<Prev>> {
        self = self.push_kind(c"dualpi2");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushDualpi2Attrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_etf(mut self) -> PushEtfAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"etf");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushEtfAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_ets(mut self) -> PushEtsAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"ets");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushEtsAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_flow(mut self) -> PushFlowAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"flow");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFlowAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_flower(mut self) -> PushFlowerAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"flower");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFlowerAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_fq(mut self) -> PushFqAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"fq");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFqAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_fq_codel(mut self) -> PushFqCodelAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"fq_codel");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFqCodelAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_fq_pie(mut self) -> PushFqPieAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"fq_pie");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFqPieAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_fw(mut self) -> PushFwAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"fw");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFwAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_gred(mut self) -> PushGredAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"gred");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushGredAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_hfsc(mut self, fixed_header: &PushTcHfscQopt) -> Self {
        self = self.push_kind(c"hfsc");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_hhf(mut self) -> PushHhfAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"hhf");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushHhfAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_htb(mut self) -> PushHtbAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"htb");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushHtbAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_ingress(mut self) -> Self {
        self = self.push_kind(c"ingress");
        push_nested_header(self.as_rec_mut(), 2u16);
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_matchall(mut self) -> PushMatchallAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"matchall");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushMatchallAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_mq(mut self) -> Self {
        self = self.push_kind(c"mq");
        push_nested_header(self.as_rec_mut(), 2u16);
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_mqprio(mut self, fixed_header: &PushTcMqprioQopt) -> Self {
        self = self.push_kind(c"mqprio");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_multiq(mut self, fixed_header: &PushTcMultiqQopt) -> Self {
        self = self.push_kind(c"multiq");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_netem(
        mut self,
        fixed_header: &PushTcNetemQopt,
    ) -> PushNetemAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"netem");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        let Self {
            prev,
            header_offset,
        } = self;
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushNetemAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_pfifo(mut self, fixed_header: &PushTcFifoQopt) -> Self {
        self = self.push_kind(c"pfifo");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_pfifo_fast(mut self, fixed_header: &PushTcPrioQopt) -> Self {
        self = self.push_kind(c"pfifo_fast");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_pfifo_head_drop(mut self, fixed_header: &PushTcFifoQopt) -> Self {
        self = self.push_kind(c"pfifo_head_drop");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_pie(mut self) -> PushPieAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"pie");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushPieAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_plug(mut self, fixed_header: &PushTcPlugQopt) -> Self {
        self = self.push_kind(c"plug");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_prio(mut self, fixed_header: &PushTcPrioQopt) -> Self {
        self = self.push_kind(c"prio");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_qfq(mut self) -> PushQfqAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"qfq");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushQfqAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_red(mut self) -> PushRedAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"red");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushRedAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_route(mut self) -> PushRouteAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"route");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushRouteAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_sfb(mut self, fixed_header: &PushTcSfbQopt) -> Self {
        self = self.push_kind(c"sfb");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_sfq(mut self, fixed_header: &PushTcSfqQoptV1) -> Self {
        self = self.push_kind(c"sfq");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_taprio(mut self) -> PushTaprioAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"taprio");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushTaprioAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_tbf(mut self) -> PushTbfAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"tbf");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushTbfAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_u32(mut self) -> PushU32Attrs<PushDummy<Prev>> {
        self = self.push_kind(c"u32");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushU32Attrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    pub fn push_stats(mut self, value: PushTcStats) -> Self {
        push_header(self.as_rec_mut(), 3u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_cake(mut self) -> PushCakeStatsAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"cake");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushCakeStatsAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_choke(mut self, fixed_header: &PushTcChokeXstats) -> Self {
        self = self.push_kind(c"choke");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_codel(mut self, fixed_header: &PushTcCodelXstats) -> Self {
        self = self.push_kind(c"codel");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_dualpi2(mut self, fixed_header: &PushTcDualpi2Xstats) -> Self {
        self = self.push_kind(c"dualpi2");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_fq(mut self, fixed_header: &PushTcFqQdStats) -> Self {
        self = self.push_kind(c"fq");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_fq_codel(mut self, fixed_header: &PushTcFqCodelXstats) -> Self {
        self = self.push_kind(c"fq_codel");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_fq_pie(mut self, fixed_header: &PushTcFqPieXstats) -> Self {
        self = self.push_kind(c"fq_pie");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_hhf(mut self, fixed_header: &PushTcHhfXstats) -> Self {
        self = self.push_kind(c"hhf");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_pie(mut self, fixed_header: &PushTcPieXstats) -> Self {
        self = self.push_kind(c"pie");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_red(mut self, fixed_header: &PushTcRedXstats) -> Self {
        self = self.push_kind(c"red");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_sfb(mut self, fixed_header: &PushTcSfbXstats) -> Self {
        self = self.push_kind(c"sfb");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_sfq(mut self, fixed_header: &PushTcSfqXstats) -> Self {
        self = self.push_kind(c"sfq");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    pub fn push_rate(mut self, value: PushGnetEstimator) -> Self {
        push_header(self.as_rec_mut(), 5u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_fcnt(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn nested_stats2(mut self) -> PushTcaStatsAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 7u16);
        PushTcaStatsAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn nested_stab(mut self) -> PushTcaStabAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 8u16);
        PushTcaStabAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_chain(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 11u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_ingress_block(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 13u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_egress_block(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 14u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpGettfilterDumpReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump tc filter information."]
#[doc = "Original name: \"op-gettfilter-dump-reply\""]
#[derive(Clone)]
pub enum OpGettfilterDumpReply<'a> {
    Kind(&'a CStr),
    Options(OptionsMsg<'a>),
    Stats(PushTcStats),
    Xstats(TcaStatsAppMsg<'a>),
    Rate(PushGnetEstimator),
    Fcnt(u32),
    Stats2(Iterable<'a, TcaStatsAttrs<'a>>),
    Stab(Iterable<'a, TcaStabAttrs<'a>>),
    Chain(u32),
    IngressBlock(u32),
    EgressBlock(u32),
}
impl<'a> Iterable<'a, OpGettfilterDumpReply<'a>> {
    pub fn get_kind(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettfilterDumpReply::Kind(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGettfilterDumpReply", "Kind"))
    }
    pub fn get_options(&self) -> Result<OptionsMsg<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettfilterDumpReply::Options(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGettfilterDumpReply", "Options"))
    }
    pub fn get_stats(&self) -> Result<PushTcStats, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettfilterDumpReply::Stats(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGettfilterDumpReply", "Stats"))
    }
    pub fn get_xstats(&self) -> Result<TcaStatsAppMsg<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettfilterDumpReply::Xstats(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGettfilterDumpReply", "Xstats"))
    }
    pub fn get_rate(&self) -> Result<PushGnetEstimator, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettfilterDumpReply::Rate(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGettfilterDumpReply", "Rate"))
    }
    pub fn get_fcnt(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettfilterDumpReply::Fcnt(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGettfilterDumpReply", "Fcnt"))
    }
    pub fn get_stats2(&self) -> Result<Iterable<'a, TcaStatsAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettfilterDumpReply::Stats2(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGettfilterDumpReply", "Stats2"))
    }
    pub fn get_stab(&self) -> Result<Iterable<'a, TcaStabAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettfilterDumpReply::Stab(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGettfilterDumpReply", "Stab"))
    }
    pub fn get_chain(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettfilterDumpReply::Chain(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGettfilterDumpReply", "Chain"))
    }
    pub fn get_ingress_block(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettfilterDumpReply::IngressBlock(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGettfilterDumpReply", "IngressBlock"))
    }
    pub fn get_egress_block(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettfilterDumpReply::EgressBlock(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGettfilterDumpReply", "EgressBlock"))
    }
}
impl<'a> OpGettfilterDumpReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushTcmsg, Iterable<'a, OpGettfilterDumpReply<'a>>) {
        let mut header = PushTcmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushTcmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushTcmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Attrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpGettfilterDumpReply<'a>> {
    type Item = Result<OpGettfilterDumpReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGettfilterDumpReply::Kind({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGettfilterDumpReply::Options({
                    let res = {
                        let Ok(selector) = self.get_kind() else { break };
                        OptionsMsg::select_with_loc(selector, next, self.orig_loc)
                    };
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGettfilterDumpReply::Stats({
                    let res = PushTcStats::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpGettfilterDumpReply::Xstats({
                    let res = {
                        let Ok(selector) = self.get_kind() else { break };
                        TcaStatsAppMsg::select_with_loc(selector, next, self.orig_loc)
                    };
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpGettfilterDumpReply::Rate({
                    let res = PushGnetEstimator::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpGettfilterDumpReply::Fcnt({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpGettfilterDumpReply::Stats2({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpGettfilterDumpReply::Stab({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => OpGettfilterDumpReply::Chain({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                13u16 => OpGettfilterDumpReply::IngressBlock({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                14u16 => OpGettfilterDumpReply::EgressBlock({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpGettfilterDumpReply",
            r#type.and_then(|t| OpGettfilterDumpReply::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpGettfilterDumpReply<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGettfilterDumpReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGettfilterDumpReply::Kind(val) => fmt.field("Kind", &val),
                OpGettfilterDumpReply::Options(val) => fmt.field("Options", &val),
                OpGettfilterDumpReply::Stats(val) => fmt.field("Stats", &val),
                OpGettfilterDumpReply::Xstats(val) => fmt.field("Xstats", &val),
                OpGettfilterDumpReply::Rate(val) => fmt.field("Rate", &val),
                OpGettfilterDumpReply::Fcnt(val) => fmt.field("Fcnt", &val),
                OpGettfilterDumpReply::Stats2(val) => fmt.field("Stats2", &val),
                OpGettfilterDumpReply::Stab(val) => fmt.field("Stab", &val),
                OpGettfilterDumpReply::Chain(val) => fmt.field("Chain", &val),
                OpGettfilterDumpReply::IngressBlock(val) => fmt.field("IngressBlock", &val),
                OpGettfilterDumpReply::EgressBlock(val) => fmt.field("EgressBlock", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpGettfilterDumpReply<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushTcmsg::len() {
            stack.push(("OpGettfilterDumpReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGettfilterDumpReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGettfilterDumpReply::Kind(val) => {
                    if last_off == offset {
                        stack.push(("Kind", last_off));
                        break;
                    }
                }
                OpGettfilterDumpReply::Options(val) => {
                    if last_off == offset {
                        stack.push(("Options", last_off));
                        break;
                    }
                }
                OpGettfilterDumpReply::Stats(val) => {
                    if last_off == offset {
                        stack.push(("Stats", last_off));
                        break;
                    }
                }
                OpGettfilterDumpReply::Xstats(val) => {
                    if last_off == offset {
                        stack.push(("Xstats", last_off));
                        break;
                    }
                }
                OpGettfilterDumpReply::Rate(val) => {
                    if last_off == offset {
                        stack.push(("Rate", last_off));
                        break;
                    }
                }
                OpGettfilterDumpReply::Fcnt(val) => {
                    if last_off == offset {
                        stack.push(("Fcnt", last_off));
                        break;
                    }
                }
                OpGettfilterDumpReply::Stats2(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGettfilterDumpReply::Stab(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGettfilterDumpReply::Chain(val) => {
                    if last_off == offset {
                        stack.push(("Chain", last_off));
                        break;
                    }
                }
                OpGettfilterDumpReply::IngressBlock(val) => {
                    if last_off == offset {
                        stack.push(("IngressBlock", last_off));
                        break;
                    }
                }
                OpGettfilterDumpReply::EgressBlock(val) => {
                    if last_off == offset {
                        stack.push(("EgressBlock", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGettfilterDumpReply", cur));
        }
        (stack, missing)
    }
}
#[derive(Debug)]
pub struct RequestOpGettfilterDumpRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpGettfilterDumpRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushTcmsg) -> Self {
        PushOpGettfilterDumpRequest::write_header(&mut request.buf_mut(), header);
        Self {
            request: request.set_dump(),
        }
    }
    pub fn encode(&mut self) -> PushOpGettfilterDumpRequest<&mut Vec<u8>> {
        PushOpGettfilterDumpRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpGettfilterDumpRequest<RequestBuf<'r>> {
        PushOpGettfilterDumpRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpGettfilterDumpRequest<'_> {
    type ReplyType<'buf> = (PushTcmsg, Iterable<'buf, OpGettfilterDumpReply<'buf>>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 0u16,
            request_type: 46u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpGettfilterDumpReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpGettfilterDumpRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Get / dump tc filter information."]
pub struct PushOpGettfilterDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGettfilterDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGettfilterDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushTcmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushTcmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_kind(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_kind_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_chain(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 11u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpGettfilterDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump tc filter information."]
#[doc = "Original name: \"op-gettfilter-do-request\""]
#[derive(Clone)]
pub enum OpGettfilterDoRequest<'a> {
    Kind(&'a CStr),
    Chain(u32),
}
impl<'a> Iterable<'a, OpGettfilterDoRequest<'a>> {
    pub fn get_kind(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettfilterDoRequest::Kind(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGettfilterDoRequest", "Kind"))
    }
    pub fn get_chain(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettfilterDoRequest::Chain(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGettfilterDoRequest", "Chain"))
    }
}
impl<'a> OpGettfilterDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushTcmsg, Iterable<'a, OpGettfilterDoRequest<'a>>) {
        let mut header = PushTcmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushTcmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushTcmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Attrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpGettfilterDoRequest<'a>> {
    type Item = Result<OpGettfilterDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGettfilterDoRequest::Kind({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => OpGettfilterDoRequest::Chain({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpGettfilterDoRequest",
            r#type.and_then(|t| OpGettfilterDoRequest::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpGettfilterDoRequest<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGettfilterDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGettfilterDoRequest::Kind(val) => fmt.field("Kind", &val),
                OpGettfilterDoRequest::Chain(val) => fmt.field("Chain", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpGettfilterDoRequest<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushTcmsg::len() {
            stack.push(("OpGettfilterDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGettfilterDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGettfilterDoRequest::Kind(val) => {
                    if last_off == offset {
                        stack.push(("Kind", last_off));
                        break;
                    }
                }
                OpGettfilterDoRequest::Chain(val) => {
                    if last_off == offset {
                        stack.push(("Chain", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGettfilterDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get / dump tc filter information."]
pub struct PushOpGettfilterDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGettfilterDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGettfilterDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushTcmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushTcmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_kind(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_kind_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_basic(mut self) -> PushBasicAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"basic");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushBasicAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_bpf(mut self) -> PushBpfAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"bpf");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushBpfAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_bfifo(mut self, fixed_header: &PushTcFifoQopt) -> Self {
        self = self.push_kind(c"bfifo");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_cake(mut self) -> PushCakeAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"cake");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushCakeAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_cbs(mut self) -> PushCbsAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"cbs");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushCbsAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_cgroup(mut self) -> PushCgroupAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"cgroup");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushCgroupAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_choke(mut self) -> PushChokeAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"choke");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushChokeAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_clsact(mut self) -> Self {
        self = self.push_kind(c"clsact");
        push_nested_header(self.as_rec_mut(), 2u16);
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_codel(mut self) -> PushCodelAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"codel");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushCodelAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_drr(mut self) -> PushDrrAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"drr");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushDrrAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_dualpi2(mut self) -> PushDualpi2Attrs<PushDummy<Prev>> {
        self = self.push_kind(c"dualpi2");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushDualpi2Attrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_etf(mut self) -> PushEtfAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"etf");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushEtfAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_ets(mut self) -> PushEtsAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"ets");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushEtsAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_flow(mut self) -> PushFlowAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"flow");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFlowAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_flower(mut self) -> PushFlowerAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"flower");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFlowerAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_fq(mut self) -> PushFqAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"fq");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFqAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_fq_codel(mut self) -> PushFqCodelAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"fq_codel");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFqCodelAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_fq_pie(mut self) -> PushFqPieAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"fq_pie");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFqPieAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_fw(mut self) -> PushFwAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"fw");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFwAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_gred(mut self) -> PushGredAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"gred");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushGredAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_hfsc(mut self, fixed_header: &PushTcHfscQopt) -> Self {
        self = self.push_kind(c"hfsc");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_hhf(mut self) -> PushHhfAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"hhf");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushHhfAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_htb(mut self) -> PushHtbAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"htb");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushHtbAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_ingress(mut self) -> Self {
        self = self.push_kind(c"ingress");
        push_nested_header(self.as_rec_mut(), 2u16);
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_matchall(mut self) -> PushMatchallAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"matchall");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushMatchallAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_mq(mut self) -> Self {
        self = self.push_kind(c"mq");
        push_nested_header(self.as_rec_mut(), 2u16);
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_mqprio(mut self, fixed_header: &PushTcMqprioQopt) -> Self {
        self = self.push_kind(c"mqprio");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_multiq(mut self, fixed_header: &PushTcMultiqQopt) -> Self {
        self = self.push_kind(c"multiq");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_netem(
        mut self,
        fixed_header: &PushTcNetemQopt,
    ) -> PushNetemAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"netem");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        let Self {
            prev,
            header_offset,
        } = self;
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushNetemAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_pfifo(mut self, fixed_header: &PushTcFifoQopt) -> Self {
        self = self.push_kind(c"pfifo");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_pfifo_fast(mut self, fixed_header: &PushTcPrioQopt) -> Self {
        self = self.push_kind(c"pfifo_fast");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_pfifo_head_drop(mut self, fixed_header: &PushTcFifoQopt) -> Self {
        self = self.push_kind(c"pfifo_head_drop");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_pie(mut self) -> PushPieAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"pie");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushPieAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_plug(mut self, fixed_header: &PushTcPlugQopt) -> Self {
        self = self.push_kind(c"plug");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_prio(mut self, fixed_header: &PushTcPrioQopt) -> Self {
        self = self.push_kind(c"prio");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_qfq(mut self) -> PushQfqAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"qfq");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushQfqAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_red(mut self) -> PushRedAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"red");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushRedAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_route(mut self) -> PushRouteAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"route");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushRouteAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_sfb(mut self, fixed_header: &PushTcSfbQopt) -> Self {
        self = self.push_kind(c"sfb");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_sfq(mut self, fixed_header: &PushTcSfqQoptV1) -> Self {
        self = self.push_kind(c"sfq");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_taprio(mut self) -> PushTaprioAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"taprio");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushTaprioAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_tbf(mut self) -> PushTbfAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"tbf");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushTbfAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_u32(mut self) -> PushU32Attrs<PushDummy<Prev>> {
        self = self.push_kind(c"u32");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushU32Attrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    pub fn push_stats(mut self, value: PushTcStats) -> Self {
        push_header(self.as_rec_mut(), 3u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_cake(mut self) -> PushCakeStatsAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"cake");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushCakeStatsAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_choke(mut self, fixed_header: &PushTcChokeXstats) -> Self {
        self = self.push_kind(c"choke");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_codel(mut self, fixed_header: &PushTcCodelXstats) -> Self {
        self = self.push_kind(c"codel");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_dualpi2(mut self, fixed_header: &PushTcDualpi2Xstats) -> Self {
        self = self.push_kind(c"dualpi2");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_fq(mut self, fixed_header: &PushTcFqQdStats) -> Self {
        self = self.push_kind(c"fq");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_fq_codel(mut self, fixed_header: &PushTcFqCodelXstats) -> Self {
        self = self.push_kind(c"fq_codel");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_fq_pie(mut self, fixed_header: &PushTcFqPieXstats) -> Self {
        self = self.push_kind(c"fq_pie");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_hhf(mut self, fixed_header: &PushTcHhfXstats) -> Self {
        self = self.push_kind(c"hhf");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_pie(mut self, fixed_header: &PushTcPieXstats) -> Self {
        self = self.push_kind(c"pie");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_red(mut self, fixed_header: &PushTcRedXstats) -> Self {
        self = self.push_kind(c"red");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_sfb(mut self, fixed_header: &PushTcSfbXstats) -> Self {
        self = self.push_kind(c"sfb");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_sfq(mut self, fixed_header: &PushTcSfqXstats) -> Self {
        self = self.push_kind(c"sfq");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    pub fn push_rate(mut self, value: PushGnetEstimator) -> Self {
        push_header(self.as_rec_mut(), 5u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_fcnt(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn nested_stats2(mut self) -> PushTcaStatsAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 7u16);
        PushTcaStatsAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn nested_stab(mut self) -> PushTcaStabAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 8u16);
        PushTcaStabAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_chain(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 11u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_ingress_block(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 13u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_egress_block(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 14u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpGettfilterDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump tc filter information."]
#[doc = "Original name: \"op-gettfilter-do-reply\""]
#[derive(Clone)]
pub enum OpGettfilterDoReply<'a> {
    Kind(&'a CStr),
    Options(OptionsMsg<'a>),
    Stats(PushTcStats),
    Xstats(TcaStatsAppMsg<'a>),
    Rate(PushGnetEstimator),
    Fcnt(u32),
    Stats2(Iterable<'a, TcaStatsAttrs<'a>>),
    Stab(Iterable<'a, TcaStabAttrs<'a>>),
    Chain(u32),
    IngressBlock(u32),
    EgressBlock(u32),
}
impl<'a> Iterable<'a, OpGettfilterDoReply<'a>> {
    pub fn get_kind(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettfilterDoReply::Kind(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGettfilterDoReply", "Kind"))
    }
    pub fn get_options(&self) -> Result<OptionsMsg<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettfilterDoReply::Options(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGettfilterDoReply", "Options"))
    }
    pub fn get_stats(&self) -> Result<PushTcStats, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettfilterDoReply::Stats(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGettfilterDoReply", "Stats"))
    }
    pub fn get_xstats(&self) -> Result<TcaStatsAppMsg<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettfilterDoReply::Xstats(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGettfilterDoReply", "Xstats"))
    }
    pub fn get_rate(&self) -> Result<PushGnetEstimator, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettfilterDoReply::Rate(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGettfilterDoReply", "Rate"))
    }
    pub fn get_fcnt(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettfilterDoReply::Fcnt(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGettfilterDoReply", "Fcnt"))
    }
    pub fn get_stats2(&self) -> Result<Iterable<'a, TcaStatsAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettfilterDoReply::Stats2(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGettfilterDoReply", "Stats2"))
    }
    pub fn get_stab(&self) -> Result<Iterable<'a, TcaStabAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettfilterDoReply::Stab(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGettfilterDoReply", "Stab"))
    }
    pub fn get_chain(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettfilterDoReply::Chain(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGettfilterDoReply", "Chain"))
    }
    pub fn get_ingress_block(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettfilterDoReply::IngressBlock(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGettfilterDoReply", "IngressBlock"))
    }
    pub fn get_egress_block(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettfilterDoReply::EgressBlock(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGettfilterDoReply", "EgressBlock"))
    }
}
impl<'a> OpGettfilterDoReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushTcmsg, Iterable<'a, OpGettfilterDoReply<'a>>) {
        let mut header = PushTcmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushTcmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushTcmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Attrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpGettfilterDoReply<'a>> {
    type Item = Result<OpGettfilterDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGettfilterDoReply::Kind({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGettfilterDoReply::Options({
                    let res = {
                        let Ok(selector) = self.get_kind() else { break };
                        OptionsMsg::select_with_loc(selector, next, self.orig_loc)
                    };
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGettfilterDoReply::Stats({
                    let res = PushTcStats::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpGettfilterDoReply::Xstats({
                    let res = {
                        let Ok(selector) = self.get_kind() else { break };
                        TcaStatsAppMsg::select_with_loc(selector, next, self.orig_loc)
                    };
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpGettfilterDoReply::Rate({
                    let res = PushGnetEstimator::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpGettfilterDoReply::Fcnt({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpGettfilterDoReply::Stats2({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpGettfilterDoReply::Stab({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => OpGettfilterDoReply::Chain({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                13u16 => OpGettfilterDoReply::IngressBlock({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                14u16 => OpGettfilterDoReply::EgressBlock({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpGettfilterDoReply",
            r#type.and_then(|t| OpGettfilterDoReply::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpGettfilterDoReply<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGettfilterDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGettfilterDoReply::Kind(val) => fmt.field("Kind", &val),
                OpGettfilterDoReply::Options(val) => fmt.field("Options", &val),
                OpGettfilterDoReply::Stats(val) => fmt.field("Stats", &val),
                OpGettfilterDoReply::Xstats(val) => fmt.field("Xstats", &val),
                OpGettfilterDoReply::Rate(val) => fmt.field("Rate", &val),
                OpGettfilterDoReply::Fcnt(val) => fmt.field("Fcnt", &val),
                OpGettfilterDoReply::Stats2(val) => fmt.field("Stats2", &val),
                OpGettfilterDoReply::Stab(val) => fmt.field("Stab", &val),
                OpGettfilterDoReply::Chain(val) => fmt.field("Chain", &val),
                OpGettfilterDoReply::IngressBlock(val) => fmt.field("IngressBlock", &val),
                OpGettfilterDoReply::EgressBlock(val) => fmt.field("EgressBlock", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpGettfilterDoReply<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushTcmsg::len() {
            stack.push(("OpGettfilterDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGettfilterDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGettfilterDoReply::Kind(val) => {
                    if last_off == offset {
                        stack.push(("Kind", last_off));
                        break;
                    }
                }
                OpGettfilterDoReply::Options(val) => {
                    if last_off == offset {
                        stack.push(("Options", last_off));
                        break;
                    }
                }
                OpGettfilterDoReply::Stats(val) => {
                    if last_off == offset {
                        stack.push(("Stats", last_off));
                        break;
                    }
                }
                OpGettfilterDoReply::Xstats(val) => {
                    if last_off == offset {
                        stack.push(("Xstats", last_off));
                        break;
                    }
                }
                OpGettfilterDoReply::Rate(val) => {
                    if last_off == offset {
                        stack.push(("Rate", last_off));
                        break;
                    }
                }
                OpGettfilterDoReply::Fcnt(val) => {
                    if last_off == offset {
                        stack.push(("Fcnt", last_off));
                        break;
                    }
                }
                OpGettfilterDoReply::Stats2(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGettfilterDoReply::Stab(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGettfilterDoReply::Chain(val) => {
                    if last_off == offset {
                        stack.push(("Chain", last_off));
                        break;
                    }
                }
                OpGettfilterDoReply::IngressBlock(val) => {
                    if last_off == offset {
                        stack.push(("IngressBlock", last_off));
                        break;
                    }
                }
                OpGettfilterDoReply::EgressBlock(val) => {
                    if last_off == offset {
                        stack.push(("EgressBlock", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGettfilterDoReply", cur));
        }
        (stack, missing)
    }
}
#[derive(Debug)]
pub struct RequestOpGettfilterDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpGettfilterDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushTcmsg) -> Self {
        PushOpGettfilterDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpGettfilterDoRequest<&mut Vec<u8>> {
        PushOpGettfilterDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpGettfilterDoRequest<RequestBuf<'r>> {
        PushOpGettfilterDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpGettfilterDoRequest<'_> {
    type ReplyType<'buf> = (PushTcmsg, Iterable<'buf, OpGettfilterDoReply<'buf>>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 0u16,
            request_type: 46u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpGettfilterDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpGettfilterDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Get / dump tc chain information."]
pub struct PushOpNewchainDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpNewchainDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpNewchainDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushTcmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushTcmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_kind(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_kind_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_basic(mut self) -> PushBasicAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"basic");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushBasicAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_bpf(mut self) -> PushBpfAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"bpf");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushBpfAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_bfifo(mut self, fixed_header: &PushTcFifoQopt) -> Self {
        self = self.push_kind(c"bfifo");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_cake(mut self) -> PushCakeAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"cake");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushCakeAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_cbs(mut self) -> PushCbsAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"cbs");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushCbsAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_cgroup(mut self) -> PushCgroupAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"cgroup");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushCgroupAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_choke(mut self) -> PushChokeAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"choke");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushChokeAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_clsact(mut self) -> Self {
        self = self.push_kind(c"clsact");
        push_nested_header(self.as_rec_mut(), 2u16);
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_codel(mut self) -> PushCodelAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"codel");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushCodelAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_drr(mut self) -> PushDrrAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"drr");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushDrrAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_dualpi2(mut self) -> PushDualpi2Attrs<PushDummy<Prev>> {
        self = self.push_kind(c"dualpi2");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushDualpi2Attrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_etf(mut self) -> PushEtfAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"etf");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushEtfAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_ets(mut self) -> PushEtsAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"ets");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushEtsAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_flow(mut self) -> PushFlowAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"flow");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFlowAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_flower(mut self) -> PushFlowerAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"flower");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFlowerAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_fq(mut self) -> PushFqAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"fq");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFqAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_fq_codel(mut self) -> PushFqCodelAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"fq_codel");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFqCodelAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_fq_pie(mut self) -> PushFqPieAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"fq_pie");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFqPieAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_fw(mut self) -> PushFwAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"fw");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFwAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_gred(mut self) -> PushGredAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"gred");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushGredAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_hfsc(mut self, fixed_header: &PushTcHfscQopt) -> Self {
        self = self.push_kind(c"hfsc");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_hhf(mut self) -> PushHhfAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"hhf");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushHhfAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_htb(mut self) -> PushHtbAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"htb");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushHtbAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_ingress(mut self) -> Self {
        self = self.push_kind(c"ingress");
        push_nested_header(self.as_rec_mut(), 2u16);
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_matchall(mut self) -> PushMatchallAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"matchall");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushMatchallAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_mq(mut self) -> Self {
        self = self.push_kind(c"mq");
        push_nested_header(self.as_rec_mut(), 2u16);
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_mqprio(mut self, fixed_header: &PushTcMqprioQopt) -> Self {
        self = self.push_kind(c"mqprio");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_multiq(mut self, fixed_header: &PushTcMultiqQopt) -> Self {
        self = self.push_kind(c"multiq");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_netem(
        mut self,
        fixed_header: &PushTcNetemQopt,
    ) -> PushNetemAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"netem");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        let Self {
            prev,
            header_offset,
        } = self;
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushNetemAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_pfifo(mut self, fixed_header: &PushTcFifoQopt) -> Self {
        self = self.push_kind(c"pfifo");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_pfifo_fast(mut self, fixed_header: &PushTcPrioQopt) -> Self {
        self = self.push_kind(c"pfifo_fast");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_pfifo_head_drop(mut self, fixed_header: &PushTcFifoQopt) -> Self {
        self = self.push_kind(c"pfifo_head_drop");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_pie(mut self) -> PushPieAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"pie");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushPieAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_plug(mut self, fixed_header: &PushTcPlugQopt) -> Self {
        self = self.push_kind(c"plug");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_prio(mut self, fixed_header: &PushTcPrioQopt) -> Self {
        self = self.push_kind(c"prio");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_qfq(mut self) -> PushQfqAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"qfq");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushQfqAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_red(mut self) -> PushRedAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"red");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushRedAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_route(mut self) -> PushRouteAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"route");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushRouteAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_sfb(mut self, fixed_header: &PushTcSfbQopt) -> Self {
        self = self.push_kind(c"sfb");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_sfq(mut self, fixed_header: &PushTcSfqQoptV1) -> Self {
        self = self.push_kind(c"sfq");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_taprio(mut self) -> PushTaprioAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"taprio");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushTaprioAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_tbf(mut self) -> PushTbfAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"tbf");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushTbfAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_u32(mut self) -> PushU32Attrs<PushDummy<Prev>> {
        self = self.push_kind(c"u32");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushU32Attrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    pub fn push_rate(mut self, value: PushGnetEstimator) -> Self {
        push_header(self.as_rec_mut(), 5u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_chain(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 11u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_ingress_block(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 13u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_egress_block(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 14u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpNewchainDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump tc chain information."]
#[doc = "Original name: \"op-newchain-do-request\""]
#[derive(Clone)]
pub enum OpNewchainDoRequest<'a> {
    Kind(&'a CStr),
    Options(OptionsMsg<'a>),
    Rate(PushGnetEstimator),
    Chain(u32),
    IngressBlock(u32),
    EgressBlock(u32),
}
impl<'a> Iterable<'a, OpNewchainDoRequest<'a>> {
    pub fn get_kind(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewchainDoRequest::Kind(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewchainDoRequest", "Kind"))
    }
    pub fn get_options(&self) -> Result<OptionsMsg<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewchainDoRequest::Options(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewchainDoRequest", "Options"))
    }
    pub fn get_rate(&self) -> Result<PushGnetEstimator, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewchainDoRequest::Rate(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewchainDoRequest", "Rate"))
    }
    pub fn get_chain(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewchainDoRequest::Chain(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewchainDoRequest", "Chain"))
    }
    pub fn get_ingress_block(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewchainDoRequest::IngressBlock(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewchainDoRequest", "IngressBlock"))
    }
    pub fn get_egress_block(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewchainDoRequest::EgressBlock(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpNewchainDoRequest", "EgressBlock"))
    }
}
impl<'a> OpNewchainDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushTcmsg, Iterable<'a, OpNewchainDoRequest<'a>>) {
        let mut header = PushTcmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushTcmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushTcmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Attrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpNewchainDoRequest<'a>> {
    type Item = Result<OpNewchainDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpNewchainDoRequest::Kind({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpNewchainDoRequest::Options({
                    let res = {
                        let Ok(selector) = self.get_kind() else { break };
                        OptionsMsg::select_with_loc(selector, next, self.orig_loc)
                    };
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpNewchainDoRequest::Rate({
                    let res = PushGnetEstimator::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => OpNewchainDoRequest::Chain({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                13u16 => OpNewchainDoRequest::IngressBlock({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                14u16 => OpNewchainDoRequest::EgressBlock({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpNewchainDoRequest",
            r#type.and_then(|t| OpNewchainDoRequest::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpNewchainDoRequest<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpNewchainDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpNewchainDoRequest::Kind(val) => fmt.field("Kind", &val),
                OpNewchainDoRequest::Options(val) => fmt.field("Options", &val),
                OpNewchainDoRequest::Rate(val) => fmt.field("Rate", &val),
                OpNewchainDoRequest::Chain(val) => fmt.field("Chain", &val),
                OpNewchainDoRequest::IngressBlock(val) => fmt.field("IngressBlock", &val),
                OpNewchainDoRequest::EgressBlock(val) => fmt.field("EgressBlock", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpNewchainDoRequest<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushTcmsg::len() {
            stack.push(("OpNewchainDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpNewchainDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpNewchainDoRequest::Kind(val) => {
                    if last_off == offset {
                        stack.push(("Kind", last_off));
                        break;
                    }
                }
                OpNewchainDoRequest::Options(val) => {
                    if last_off == offset {
                        stack.push(("Options", last_off));
                        break;
                    }
                }
                OpNewchainDoRequest::Rate(val) => {
                    if last_off == offset {
                        stack.push(("Rate", last_off));
                        break;
                    }
                }
                OpNewchainDoRequest::Chain(val) => {
                    if last_off == offset {
                        stack.push(("Chain", last_off));
                        break;
                    }
                }
                OpNewchainDoRequest::IngressBlock(val) => {
                    if last_off == offset {
                        stack.push(("IngressBlock", last_off));
                        break;
                    }
                }
                OpNewchainDoRequest::EgressBlock(val) => {
                    if last_off == offset {
                        stack.push(("EgressBlock", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpNewchainDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get / dump tc chain information."]
pub struct PushOpNewchainDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpNewchainDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpNewchainDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushTcmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushTcmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpNewchainDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump tc chain information."]
#[doc = "Original name: \"op-newchain-do-reply\""]
#[derive(Clone)]
pub enum OpNewchainDoReply {}
impl<'a> Iterable<'a, OpNewchainDoReply> {}
impl OpNewchainDoReply {
    pub fn new(buf: &'_ [u8]) -> (PushTcmsg, Iterable<'_, OpNewchainDoReply>) {
        let mut header = PushTcmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushTcmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushTcmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Attrs::attr_from_type(r#type)
    }
}
impl Iterator for Iterable<'_, OpNewchainDoReply> {
    type Item = Result<OpNewchainDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpNewchainDoReply",
            r#type.and_then(|t| OpNewchainDoReply::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl std::fmt::Debug for Iterable<'_, OpNewchainDoReply> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpNewchainDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl Iterable<'_, OpNewchainDoReply> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushTcmsg::len() {
            stack.push(("OpNewchainDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpNewchainDoReply::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpNewchainDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpNewchainDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushTcmsg) -> Self {
        PushOpNewchainDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpNewchainDoRequest<&mut Vec<u8>> {
        PushOpNewchainDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpNewchainDoRequest<RequestBuf<'r>> {
        PushOpNewchainDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpNewchainDoRequest<'_> {
    type ReplyType<'buf> = (PushTcmsg, Iterable<'buf, OpNewchainDoReply>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 0u16,
            request_type: 100u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpNewchainDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpNewchainDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Get / dump tc chain information."]
pub struct PushOpDelchainDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDelchainDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDelchainDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushTcmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushTcmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_chain(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 11u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpDelchainDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump tc chain information."]
#[doc = "Original name: \"op-delchain-do-request\""]
#[derive(Clone)]
pub enum OpDelchainDoRequest {
    Chain(u32),
}
impl<'a> Iterable<'a, OpDelchainDoRequest> {
    pub fn get_chain(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelchainDoRequest::Chain(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpDelchainDoRequest", "Chain"))
    }
}
impl OpDelchainDoRequest {
    pub fn new(buf: &'_ [u8]) -> (PushTcmsg, Iterable<'_, OpDelchainDoRequest>) {
        let mut header = PushTcmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushTcmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushTcmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Attrs::attr_from_type(r#type)
    }
}
impl Iterator for Iterable<'_, OpDelchainDoRequest> {
    type Item = Result<OpDelchainDoRequest, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                11u16 => OpDelchainDoRequest::Chain({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpDelchainDoRequest",
            r#type.and_then(|t| OpDelchainDoRequest::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl std::fmt::Debug for Iterable<'_, OpDelchainDoRequest> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDelchainDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpDelchainDoRequest::Chain(val) => fmt.field("Chain", &val),
            };
        }
        fmt.finish()
    }
}
impl Iterable<'_, OpDelchainDoRequest> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushTcmsg::len() {
            stack.push(("OpDelchainDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDelchainDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpDelchainDoRequest::Chain(val) => {
                    if last_off == offset {
                        stack.push(("Chain", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpDelchainDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get / dump tc chain information."]
pub struct PushOpDelchainDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDelchainDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDelchainDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushTcmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushTcmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpDelchainDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump tc chain information."]
#[doc = "Original name: \"op-delchain-do-reply\""]
#[derive(Clone)]
pub enum OpDelchainDoReply {}
impl<'a> Iterable<'a, OpDelchainDoReply> {}
impl OpDelchainDoReply {
    pub fn new(buf: &'_ [u8]) -> (PushTcmsg, Iterable<'_, OpDelchainDoReply>) {
        let mut header = PushTcmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushTcmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushTcmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Attrs::attr_from_type(r#type)
    }
}
impl Iterator for Iterable<'_, OpDelchainDoReply> {
    type Item = Result<OpDelchainDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpDelchainDoReply",
            r#type.and_then(|t| OpDelchainDoReply::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl std::fmt::Debug for Iterable<'_, OpDelchainDoReply> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDelchainDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl Iterable<'_, OpDelchainDoReply> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushTcmsg::len() {
            stack.push(("OpDelchainDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDelchainDoReply::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpDelchainDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpDelchainDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushTcmsg) -> Self {
        PushOpDelchainDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpDelchainDoRequest<&mut Vec<u8>> {
        PushOpDelchainDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpDelchainDoRequest<RequestBuf<'r>> {
        PushOpDelchainDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpDelchainDoRequest<'_> {
    type ReplyType<'buf> = (PushTcmsg, Iterable<'buf, OpDelchainDoReply>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 0u16,
            request_type: 101u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpDelchainDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpDelchainDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Get / dump tc chain information."]
pub struct PushOpGetchainDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetchainDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetchainDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushTcmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushTcmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_chain(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 11u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetchainDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump tc chain information."]
#[doc = "Original name: \"op-getchain-do-request\""]
#[derive(Clone)]
pub enum OpGetchainDoRequest {
    Chain(u32),
}
impl<'a> Iterable<'a, OpGetchainDoRequest> {
    pub fn get_chain(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDoRequest::Chain(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetchainDoRequest", "Chain"))
    }
}
impl OpGetchainDoRequest {
    pub fn new(buf: &'_ [u8]) -> (PushTcmsg, Iterable<'_, OpGetchainDoRequest>) {
        let mut header = PushTcmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushTcmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushTcmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Attrs::attr_from_type(r#type)
    }
}
impl Iterator for Iterable<'_, OpGetchainDoRequest> {
    type Item = Result<OpGetchainDoRequest, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                11u16 => OpGetchainDoRequest::Chain({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpGetchainDoRequest",
            r#type.and_then(|t| OpGetchainDoRequest::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl std::fmt::Debug for Iterable<'_, OpGetchainDoRequest> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetchainDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetchainDoRequest::Chain(val) => fmt.field("Chain", &val),
            };
        }
        fmt.finish()
    }
}
impl Iterable<'_, OpGetchainDoRequest> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushTcmsg::len() {
            stack.push(("OpGetchainDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetchainDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetchainDoRequest::Chain(val) => {
                    if last_off == offset {
                        stack.push(("Chain", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetchainDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get / dump tc chain information."]
pub struct PushOpGetchainDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetchainDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetchainDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushTcmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushTcmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_kind(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_kind_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_basic(mut self) -> PushBasicAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"basic");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushBasicAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_bpf(mut self) -> PushBpfAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"bpf");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushBpfAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_bfifo(mut self, fixed_header: &PushTcFifoQopt) -> Self {
        self = self.push_kind(c"bfifo");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_cake(mut self) -> PushCakeAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"cake");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushCakeAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_cbs(mut self) -> PushCbsAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"cbs");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushCbsAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_cgroup(mut self) -> PushCgroupAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"cgroup");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushCgroupAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_choke(mut self) -> PushChokeAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"choke");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushChokeAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_clsact(mut self) -> Self {
        self = self.push_kind(c"clsact");
        push_nested_header(self.as_rec_mut(), 2u16);
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_codel(mut self) -> PushCodelAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"codel");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushCodelAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_drr(mut self) -> PushDrrAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"drr");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushDrrAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_dualpi2(mut self) -> PushDualpi2Attrs<PushDummy<Prev>> {
        self = self.push_kind(c"dualpi2");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushDualpi2Attrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_etf(mut self) -> PushEtfAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"etf");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushEtfAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_ets(mut self) -> PushEtsAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"ets");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushEtsAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_flow(mut self) -> PushFlowAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"flow");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFlowAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_flower(mut self) -> PushFlowerAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"flower");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFlowerAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_fq(mut self) -> PushFqAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"fq");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFqAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_fq_codel(mut self) -> PushFqCodelAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"fq_codel");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFqCodelAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_fq_pie(mut self) -> PushFqPieAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"fq_pie");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFqPieAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_fw(mut self) -> PushFwAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"fw");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushFwAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_gred(mut self) -> PushGredAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"gred");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushGredAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_hfsc(mut self, fixed_header: &PushTcHfscQopt) -> Self {
        self = self.push_kind(c"hfsc");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_hhf(mut self) -> PushHhfAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"hhf");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushHhfAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_htb(mut self) -> PushHtbAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"htb");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushHtbAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_ingress(mut self) -> Self {
        self = self.push_kind(c"ingress");
        push_nested_header(self.as_rec_mut(), 2u16);
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_matchall(mut self) -> PushMatchallAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"matchall");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushMatchallAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_mq(mut self) -> Self {
        self = self.push_kind(c"mq");
        push_nested_header(self.as_rec_mut(), 2u16);
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_mqprio(mut self, fixed_header: &PushTcMqprioQopt) -> Self {
        self = self.push_kind(c"mqprio");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_multiq(mut self, fixed_header: &PushTcMultiqQopt) -> Self {
        self = self.push_kind(c"multiq");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_netem(
        mut self,
        fixed_header: &PushTcNetemQopt,
    ) -> PushNetemAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"netem");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        let Self {
            prev,
            header_offset,
        } = self;
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushNetemAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_pfifo(mut self, fixed_header: &PushTcFifoQopt) -> Self {
        self = self.push_kind(c"pfifo");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_pfifo_fast(mut self, fixed_header: &PushTcPrioQopt) -> Self {
        self = self.push_kind(c"pfifo_fast");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_pfifo_head_drop(mut self, fixed_header: &PushTcFifoQopt) -> Self {
        self = self.push_kind(c"pfifo_head_drop");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_pie(mut self) -> PushPieAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"pie");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushPieAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_plug(mut self, fixed_header: &PushTcPlugQopt) -> Self {
        self = self.push_kind(c"plug");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_prio(mut self, fixed_header: &PushTcPrioQopt) -> Self {
        self = self.push_kind(c"prio");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_qfq(mut self) -> PushQfqAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"qfq");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushQfqAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_red(mut self) -> PushRedAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"red");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushRedAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_route(mut self) -> PushRouteAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"route");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushRouteAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_sfb(mut self, fixed_header: &PushTcSfbQopt) -> Self {
        self = self.push_kind(c"sfb");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_sfq(mut self, fixed_header: &PushTcSfqQoptV1) -> Self {
        self = self.push_kind(c"sfq");
        push_nested_header(self.as_rec_mut(), 2u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_taprio(mut self) -> PushTaprioAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"taprio");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushTaprioAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_tbf(mut self) -> PushTbfAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"tbf");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushTbfAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_options_u32(mut self) -> PushU32Attrs<PushDummy<Prev>> {
        self = self.push_kind(c"u32");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushU32Attrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    pub fn push_stats(mut self, value: PushTcStats) -> Self {
        push_header(self.as_rec_mut(), 3u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_cake(mut self) -> PushCakeStatsAttrs<PushDummy<Prev>> {
        self = self.push_kind(c"cake");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushCakeStatsAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_choke(mut self, fixed_header: &PushTcChokeXstats) -> Self {
        self = self.push_kind(c"choke");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_codel(mut self, fixed_header: &PushTcCodelXstats) -> Self {
        self = self.push_kind(c"codel");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_dualpi2(mut self, fixed_header: &PushTcDualpi2Xstats) -> Self {
        self = self.push_kind(c"dualpi2");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_fq(mut self, fixed_header: &PushTcFqQdStats) -> Self {
        self = self.push_kind(c"fq");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_fq_codel(mut self, fixed_header: &PushTcFqCodelXstats) -> Self {
        self = self.push_kind(c"fq_codel");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_fq_pie(mut self, fixed_header: &PushTcFqPieXstats) -> Self {
        self = self.push_kind(c"fq_pie");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_hhf(mut self, fixed_header: &PushTcHhfXstats) -> Self {
        self = self.push_kind(c"hhf");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_pie(mut self, fixed_header: &PushTcPieXstats) -> Self {
        self = self.push_kind(c"pie");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_red(mut self, fixed_header: &PushTcRedXstats) -> Self {
        self = self.push_kind(c"red");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_sfb(mut self, fixed_header: &PushTcSfbXstats) -> Self {
        self = self.push_kind(c"sfb");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_xstats_sfq(mut self, fixed_header: &PushTcSfqXstats) -> Self {
        self = self.push_kind(c"sfq");
        push_nested_header(self.as_rec_mut(), 4u16);
        self.as_rec_mut().extend(fixed_header.as_slice());
        self
    }
    pub fn push_rate(mut self, value: PushGnetEstimator) -> Self {
        push_header(self.as_rec_mut(), 5u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn push_fcnt(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn nested_stats2(mut self) -> PushTcaStatsAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 7u16);
        PushTcaStatsAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn nested_stab(mut self) -> PushTcaStabAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 8u16);
        PushTcaStabAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_chain(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 11u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_ingress_block(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 13u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_egress_block(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 14u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetchainDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump tc chain information."]
#[doc = "Original name: \"op-getchain-do-reply\""]
#[derive(Clone)]
pub enum OpGetchainDoReply<'a> {
    Kind(&'a CStr),
    Options(OptionsMsg<'a>),
    Stats(PushTcStats),
    Xstats(TcaStatsAppMsg<'a>),
    Rate(PushGnetEstimator),
    Fcnt(u32),
    Stats2(Iterable<'a, TcaStatsAttrs<'a>>),
    Stab(Iterable<'a, TcaStabAttrs<'a>>),
    Chain(u32),
    IngressBlock(u32),
    EgressBlock(u32),
}
impl<'a> Iterable<'a, OpGetchainDoReply<'a>> {
    pub fn get_kind(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDoReply::Kind(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetchainDoReply", "Kind"))
    }
    pub fn get_options(&self) -> Result<OptionsMsg<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDoReply::Options(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetchainDoReply", "Options"))
    }
    pub fn get_stats(&self) -> Result<PushTcStats, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDoReply::Stats(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetchainDoReply", "Stats"))
    }
    pub fn get_xstats(&self) -> Result<TcaStatsAppMsg<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDoReply::Xstats(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetchainDoReply", "Xstats"))
    }
    pub fn get_rate(&self) -> Result<PushGnetEstimator, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDoReply::Rate(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetchainDoReply", "Rate"))
    }
    pub fn get_fcnt(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDoReply::Fcnt(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetchainDoReply", "Fcnt"))
    }
    pub fn get_stats2(&self) -> Result<Iterable<'a, TcaStatsAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDoReply::Stats2(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetchainDoReply", "Stats2"))
    }
    pub fn get_stab(&self) -> Result<Iterable<'a, TcaStabAttrs<'a>>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDoReply::Stab(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetchainDoReply", "Stab"))
    }
    pub fn get_chain(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDoReply::Chain(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetchainDoReply", "Chain"))
    }
    pub fn get_ingress_block(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDoReply::IngressBlock(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetchainDoReply", "IngressBlock"))
    }
    pub fn get_egress_block(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDoReply::EgressBlock(val) = attr? {
                return Ok(val);
            }
        }
        Err(self.error_missing("OpGetchainDoReply", "EgressBlock"))
    }
}
impl<'a> OpGetchainDoReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushTcmsg, Iterable<'a, OpGetchainDoReply<'a>>) {
        let mut header = PushTcmsg::new();
        header
            .as_mut_slice()
            .clone_from_slice(&buf[..PushTcmsg::len()]);
        (
            header,
            Iterable::with_loc(&buf[PushTcmsg::len()..], buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Attrs::attr_from_type(r#type)
    }
}
impl<'a> Iterator for Iterable<'a, OpGetchainDoReply<'a>> {
    type Item = Result<OpGetchainDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetchainDoReply::Kind({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetchainDoReply::Options({
                    let res = {
                        let Ok(selector) = self.get_kind() else { break };
                        OptionsMsg::select_with_loc(selector, next, self.orig_loc)
                    };
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetchainDoReply::Stats({
                    let res = PushTcStats::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpGetchainDoReply::Xstats({
                    let res = {
                        let Ok(selector) = self.get_kind() else { break };
                        TcaStatsAppMsg::select_with_loc(selector, next, self.orig_loc)
                    };
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpGetchainDoReply::Rate({
                    let res = PushGnetEstimator::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpGetchainDoReply::Fcnt({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpGetchainDoReply::Stats2({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpGetchainDoReply::Stab({
                    let res = Some(Iterable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => OpGetchainDoReply::Chain({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                13u16 => OpGetchainDoReply::IngressBlock({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                14u16 => OpGetchainDoReply::EgressBlock({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(self.error_context(
            "OpGetchainDoReply",
            r#type.and_then(|t| OpGetchainDoReply::attr_from_type(t)),
            self.buf.as_ptr().wrapping_add(pos),
        )))
    }
}
impl<'a> std::fmt::Debug for Iterable<'a, OpGetchainDoReply<'a>> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetchainDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetchainDoReply::Kind(val) => fmt.field("Kind", &val),
                OpGetchainDoReply::Options(val) => fmt.field("Options", &val),
                OpGetchainDoReply::Stats(val) => fmt.field("Stats", &val),
                OpGetchainDoReply::Xstats(val) => fmt.field("Xstats", &val),
                OpGetchainDoReply::Rate(val) => fmt.field("Rate", &val),
                OpGetchainDoReply::Fcnt(val) => fmt.field("Fcnt", &val),
                OpGetchainDoReply::Stats2(val) => fmt.field("Stats2", &val),
                OpGetchainDoReply::Stab(val) => fmt.field("Stab", &val),
                OpGetchainDoReply::Chain(val) => fmt.field("Chain", &val),
                OpGetchainDoReply::IngressBlock(val) => fmt.field("IngressBlock", &val),
                OpGetchainDoReply::EgressBlock(val) => fmt.field("EgressBlock", &val),
            };
        }
        fmt.finish()
    }
}
impl<'a> Iterable<'a, OpGetchainDoReply<'a>> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = self.calc_offset(self.buf.as_ptr() as usize);
        if cur == offset + PushTcmsg::len() {
            stack.push(("OpGetchainDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetchainDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetchainDoReply::Kind(val) => {
                    if last_off == offset {
                        stack.push(("Kind", last_off));
                        break;
                    }
                }
                OpGetchainDoReply::Options(val) => {
                    if last_off == offset {
                        stack.push(("Options", last_off));
                        break;
                    }
                }
                OpGetchainDoReply::Stats(val) => {
                    if last_off == offset {
                        stack.push(("Stats", last_off));
                        break;
                    }
                }
                OpGetchainDoReply::Xstats(val) => {
                    if last_off == offset {
                        stack.push(("Xstats", last_off));
                        break;
                    }
                }
                OpGetchainDoReply::Rate(val) => {
                    if last_off == offset {
                        stack.push(("Rate", last_off));
                        break;
                    }
                }
                OpGetchainDoReply::Fcnt(val) => {
                    if last_off == offset {
                        stack.push(("Fcnt", last_off));
                        break;
                    }
                }
                OpGetchainDoReply::Stats2(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetchainDoReply::Stab(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetchainDoReply::Chain(val) => {
                    if last_off == offset {
                        stack.push(("Chain", last_off));
                        break;
                    }
                }
                OpGetchainDoReply::IngressBlock(val) => {
                    if last_off == offset {
                        stack.push(("IngressBlock", last_off));
                        break;
                    }
                }
                OpGetchainDoReply::EgressBlock(val) => {
                    if last_off == offset {
                        stack.push(("EgressBlock", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetchainDoReply", cur));
        }
        (stack, missing)
    }
}
#[derive(Debug)]
pub struct RequestOpGetchainDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpGetchainDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushTcmsg) -> Self {
        PushOpGetchainDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpGetchainDoRequest<&mut Vec<u8>> {
        PushOpGetchainDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpGetchainDoRequest<RequestBuf<'r>> {
        PushOpGetchainDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpGetchainDoRequest<'_> {
    type ReplyType<'buf> = (PushTcmsg, Iterable<'buf, OpGetchainDoReply<'buf>>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 0u16,
            request_type: 102u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpGetchainDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpGetchainDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[derive(Debug)]
pub struct ChainedFinal<'a> {
    inner: Chained<'a>,
}
#[derive(Debug)]
pub struct Chained<'a> {
    buf: RequestBuf<'a>,
    first_seq: u32,
    lookups: Vec<(&'static str, LookupFn)>,
    last_header_offset: usize,
    last_kind: Option<RequestInfo>,
}
impl<'a> ChainedFinal<'a> {
    pub fn into_chained(self) -> Chained<'a> {
        self.inner
    }
    pub fn buf(&self) -> &Vec<u8> {
        self.inner.buf()
    }
    pub fn buf_mut(&mut self) -> &mut Vec<u8> {
        self.inner.buf_mut()
    }
    fn get_index(&self, seq: u32) -> Option<u32> {
        let min = self.inner.first_seq;
        let max = min.wrapping_add(self.inner.lookups.len() as u32);
        return if min <= max {
            (min..max).contains(&seq).then(|| seq - min)
        } else if min <= seq {
            Some(seq - min)
        } else if seq < max {
            Some(u32::MAX - min + seq)
        } else {
            None
        };
    }
}
impl crate::traits::NetlinkChained for ChainedFinal<'_> {
    fn protonum(&self) -> u16 {
        PROTONUM
    }
    fn payload(&self) -> &[u8] {
        self.buf()
    }
    fn chain_len(&self) -> usize {
        self.inner.lookups.len()
    }
    fn get_index(&self, seq: u32) -> Option<usize> {
        self.get_index(seq).map(|n| n as usize)
    }
    fn name(&self, index: usize) -> &'static str {
        self.inner.lookups[index].0
    }
    fn lookup(&self, index: usize) -> LookupFn {
        self.inner.lookups[index].1
    }
}
impl Chained<'static> {
    pub fn new(first_seq: u32) -> Self {
        Self::new_from_buf(Vec::new(), first_seq)
    }
    pub fn new_from_buf(buf: Vec<u8>, first_seq: u32) -> Self {
        Self {
            buf: RequestBuf::Own(buf),
            first_seq,
            lookups: Vec::new(),
            last_header_offset: 0,
            last_kind: None,
        }
    }
    pub fn into_buf(self) -> Vec<u8> {
        match self.buf {
            RequestBuf::Own(buf) => buf,
            _ => unreachable!(),
        }
    }
}
impl<'a> Chained<'a> {
    pub fn new_with_buf(buf: &'a mut Vec<u8>, first_seq: u32) -> Self {
        Self {
            buf: RequestBuf::Ref(buf),
            first_seq,
            lookups: Vec::new(),
            last_header_offset: 0,
            last_kind: None,
        }
    }
    pub fn finalize(mut self) -> ChainedFinal<'a> {
        self.update_header();
        ChainedFinal { inner: self }
    }
    pub fn request(&mut self) -> Request<'_> {
        self.update_header();
        self.last_header_offset = self.buf().len();
        self.buf_mut()
            .extend_from_slice(PushNlmsghdr::new().as_slice());
        let mut request = Request::new_extend(self.buf.buf_mut());
        self.last_kind = None;
        request.writeback = Some(&mut self.last_kind);
        request
    }
    pub fn buf(&self) -> &Vec<u8> {
        self.buf.buf()
    }
    pub fn buf_mut(&mut self) -> &mut Vec<u8> {
        self.buf.buf_mut()
    }
    fn update_header(&mut self) {
        let Some(RequestInfo {
            protocol,
            flags,
            name,
            lookup,
        }) = self.last_kind
        else {
            if !self.buf().is_empty() {
                assert_eq!(
                    self.last_header_offset + PushNlmsghdr::len(),
                    self.buf().len()
                );
                self.buf.buf_mut().truncate(self.last_header_offset);
            }
            return;
        };
        let header_offset = self.last_header_offset;
        let request_type = match protocol {
            Protocol::Raw { request_type, .. } => request_type,
            Protocol::Generic(_) => unreachable!(),
        };
        let index = self.lookups.len();
        let seq = self.first_seq.wrapping_add(index as u32);
        self.lookups.push((name, lookup));
        let buf = self.buf_mut();
        align(buf);
        let mut header = PushNlmsghdr::new();
        header.set_len((buf.len() - header_offset) as u32);
        header.set_type(request_type);
        header.set_flags(flags | consts::NLM_F_REQUEST as u16 | consts::NLM_F_ACK as u16);
        header.set_seq(seq);
        buf[header_offset..(header_offset + 16)].clone_from_slice(header.as_slice());
    }
}
use crate::traits::LookupFn;
use crate::utils::RequestBuf;
#[derive(Debug)]
pub struct Request<'buf> {
    buf: RequestBuf<'buf>,
    flags: u16,
    writeback: Option<&'buf mut Option<RequestInfo>>,
}
#[allow(unused)]
#[derive(Debug, Clone)]
pub struct RequestInfo {
    protocol: Protocol,
    flags: u16,
    name: &'static str,
    lookup: LookupFn,
}
impl Request<'static> {
    pub fn new() -> Self {
        Self::new_from_buf(Vec::new())
    }
    pub fn new_from_buf(buf: Vec<u8>) -> Self {
        Self {
            flags: 0,
            buf: RequestBuf::Own(buf),
            writeback: None,
        }
    }
    pub fn into_buf(self) -> Vec<u8> {
        match self.buf {
            RequestBuf::Own(buf) => buf,
            _ => unreachable!(),
        }
    }
}
impl<'buf> Request<'buf> {
    pub fn new_with_buf(buf: &'buf mut Vec<u8>) -> Self {
        buf.clear();
        Self::new_extend(buf)
    }
    pub fn new_extend(buf: &'buf mut Vec<u8>) -> Self {
        Self {
            flags: 0,
            buf: RequestBuf::Ref(buf),
            writeback: None,
        }
    }
    fn do_writeback(&mut self, protocol: Protocol, name: &'static str, lookup: LookupFn) {
        let Some(writeback) = &mut self.writeback else {
            return;
        };
        **writeback = Some(RequestInfo {
            protocol,
            flags: self.flags,
            name,
            lookup,
        })
    }
    pub fn buf(&self) -> &Vec<u8> {
        self.buf.buf()
    }
    pub fn buf_mut(&mut self) -> &mut Vec<u8> {
        self.buf.buf_mut()
    }
    #[doc = "Set [`libc::NLM_F_CREATE`] flag"]
    pub fn set_create(mut self) -> Self {
        self.flags |= consts::NLM_F_CREATE as u16;
        self
    }
    #[doc = "Set [`libc::NLM_F_EXCL`] flag"]
    pub fn set_excl(mut self) -> Self {
        self.flags |= consts::NLM_F_EXCL as u16;
        self
    }
    #[doc = "Set [`libc::NLM_F_REPLACE`] flag"]
    pub fn set_replace(mut self) -> Self {
        self.flags |= consts::NLM_F_REPLACE as u16;
        self
    }
    #[doc = "Set [`libc::NLM_F_CREATE`] and [`libc::NLM_F_REPLACE`] flag"]
    pub fn set_change(self) -> Self {
        self.set_create().set_replace()
    }
    #[doc = "Set [`libc::NLM_F_APPEND`] flag"]
    pub fn set_append(mut self) -> Self {
        self.flags |= consts::NLM_F_APPEND as u16;
        self
    }
    #[doc = "Set [`libc::NLM_F_DUMP`] flag"]
    fn set_dump(mut self) -> Self {
        self.flags |= consts::NLM_F_DUMP as u16;
        self
    }
    pub fn op_newqdisc_do_request(self, header: &PushTcmsg) -> RequestOpNewqdiscDoRequest<'buf> {
        let mut res = RequestOpNewqdiscDoRequest::new(self, header);
        res.request.do_writeback(
            res.protocol(),
            "op-newqdisc-do-request",
            RequestOpNewqdiscDoRequest::lookup,
        );
        res
    }
    pub fn op_delqdisc_do_request(self, header: &PushTcmsg) -> RequestOpDelqdiscDoRequest<'buf> {
        let mut res = RequestOpDelqdiscDoRequest::new(self, header);
        res.request.do_writeback(
            res.protocol(),
            "op-delqdisc-do-request",
            RequestOpDelqdiscDoRequest::lookup,
        );
        res
    }
    pub fn op_getqdisc_dump_request(
        self,
        header: &PushTcmsg,
    ) -> RequestOpGetqdiscDumpRequest<'buf> {
        let mut res = RequestOpGetqdiscDumpRequest::new(self, header);
        res.request.do_writeback(
            res.protocol(),
            "op-getqdisc-dump-request",
            RequestOpGetqdiscDumpRequest::lookup,
        );
        res
    }
    pub fn op_getqdisc_do_request(self, header: &PushTcmsg) -> RequestOpGetqdiscDoRequest<'buf> {
        let mut res = RequestOpGetqdiscDoRequest::new(self, header);
        res.request.do_writeback(
            res.protocol(),
            "op-getqdisc-do-request",
            RequestOpGetqdiscDoRequest::lookup,
        );
        res
    }
    pub fn op_newtclass_do_request(self, header: &PushTcmsg) -> RequestOpNewtclassDoRequest<'buf> {
        let mut res = RequestOpNewtclassDoRequest::new(self, header);
        res.request.do_writeback(
            res.protocol(),
            "op-newtclass-do-request",
            RequestOpNewtclassDoRequest::lookup,
        );
        res
    }
    pub fn op_deltclass_do_request(self, header: &PushTcmsg) -> RequestOpDeltclassDoRequest<'buf> {
        let mut res = RequestOpDeltclassDoRequest::new(self, header);
        res.request.do_writeback(
            res.protocol(),
            "op-deltclass-do-request",
            RequestOpDeltclassDoRequest::lookup,
        );
        res
    }
    pub fn op_gettclass_do_request(self, header: &PushTcmsg) -> RequestOpGettclassDoRequest<'buf> {
        let mut res = RequestOpGettclassDoRequest::new(self, header);
        res.request.do_writeback(
            res.protocol(),
            "op-gettclass-do-request",
            RequestOpGettclassDoRequest::lookup,
        );
        res
    }
    pub fn op_newtfilter_do_request(
        self,
        header: &PushTcmsg,
    ) -> RequestOpNewtfilterDoRequest<'buf> {
        let mut res = RequestOpNewtfilterDoRequest::new(self, header);
        res.request.do_writeback(
            res.protocol(),
            "op-newtfilter-do-request",
            RequestOpNewtfilterDoRequest::lookup,
        );
        res
    }
    pub fn op_deltfilter_do_request(
        self,
        header: &PushTcmsg,
    ) -> RequestOpDeltfilterDoRequest<'buf> {
        let mut res = RequestOpDeltfilterDoRequest::new(self, header);
        res.request.do_writeback(
            res.protocol(),
            "op-deltfilter-do-request",
            RequestOpDeltfilterDoRequest::lookup,
        );
        res
    }
    pub fn op_gettfilter_dump_request(
        self,
        header: &PushTcmsg,
    ) -> RequestOpGettfilterDumpRequest<'buf> {
        let mut res = RequestOpGettfilterDumpRequest::new(self, header);
        res.request.do_writeback(
            res.protocol(),
            "op-gettfilter-dump-request",
            RequestOpGettfilterDumpRequest::lookup,
        );
        res
    }
    pub fn op_gettfilter_do_request(
        self,
        header: &PushTcmsg,
    ) -> RequestOpGettfilterDoRequest<'buf> {
        let mut res = RequestOpGettfilterDoRequest::new(self, header);
        res.request.do_writeback(
            res.protocol(),
            "op-gettfilter-do-request",
            RequestOpGettfilterDoRequest::lookup,
        );
        res
    }
    pub fn op_newchain_do_request(self, header: &PushTcmsg) -> RequestOpNewchainDoRequest<'buf> {
        let mut res = RequestOpNewchainDoRequest::new(self, header);
        res.request.do_writeback(
            res.protocol(),
            "op-newchain-do-request",
            RequestOpNewchainDoRequest::lookup,
        );
        res
    }
    pub fn op_delchain_do_request(self, header: &PushTcmsg) -> RequestOpDelchainDoRequest<'buf> {
        let mut res = RequestOpDelchainDoRequest::new(self, header);
        res.request.do_writeback(
            res.protocol(),
            "op-delchain-do-request",
            RequestOpDelchainDoRequest::lookup,
        );
        res
    }
    pub fn op_getchain_do_request(self, header: &PushTcmsg) -> RequestOpGetchainDoRequest<'buf> {
        let mut res = RequestOpGetchainDoRequest::new(self, header);
        res.request.do_writeback(
            res.protocol(),
            "op-getchain-do-request",
            RequestOpGetchainDoRequest::lookup,
        );
        res
    }
}
